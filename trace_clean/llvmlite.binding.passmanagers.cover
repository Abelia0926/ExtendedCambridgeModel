    1: from ctypes import (c_bool, c_char_p, c_int, c_size_t, c_uint, Structure, byref,
                           POINTER)
    1: from collections import namedtuple
    1: from enum import IntFlag
    1: from llvmlite.binding import ffi
    1: import os
    1: from tempfile import mkstemp
    1: from llvmlite.binding.common import _encode_string
       
    2: _prunestats = namedtuple('PruneStats',
    1:                          ('basicblock diamond fanout fanout_raise'))
       
       
    2: class PruneStats(_prunestats):
    1:     """ Holds statistics from reference count pruning.
           """
       
    1:     def __add__(self, other):
               if not isinstance(other, PruneStats):
                   msg = 'PruneStats can only be added to another PruneStats, got {}.'
                   raise TypeError(msg.format(type(other)))
               return PruneStats(self.basicblock + other.basicblock,
                                 self.diamond + other.diamond,
                                 self.fanout + other.fanout,
                                 self.fanout_raise + other.fanout_raise)
       
    1:     def __sub__(self, other):
   24:         if not isinstance(other, PruneStats):
                   msg = ('PruneStats can only be subtracted from another PruneStats, '
                          'got {}.')
                   raise TypeError(msg.format(type(other)))
   48:         return PruneStats(self.basicblock - other.basicblock,
   24:                           self.diamond - other.diamond,
   24:                           self.fanout - other.fanout,
   24:                           self.fanout_raise - other.fanout_raise)
       
       
    2: class _c_PruneStats(Structure):
    1:     _fields_ = [
    1:         ('basicblock', c_size_t),
    1:         ('diamond', c_size_t),
    1:         ('fanout', c_size_t),
    1:         ('fanout_raise', c_size_t)]
       
       
    1: def dump_refprune_stats(printout=False):
           """ Returns a namedtuple containing the current values for the refop pruning
           statistics. If kwarg `printout` is True the stats are printed to stderr,
           default is False.
           """
       
   48:     stats = _c_PruneStats(0, 0, 0, 0)
   48:     do_print = c_bool(printout)
       
   48:     ffi.lib.LLVMPY_DumpRefPruneStats(byref(stats), do_print)
   96:     return PruneStats(stats.basicblock, stats.diamond, stats.fanout,
   48:                       stats.fanout_raise)
       
       
    1: def set_time_passes(enable):
           """Enable or disable the pass timers.
       
           Parameters
           ----------
           enable : bool
               Set to True to enable the pass timers.
               Set to False to disable the pass timers.
           """
           ffi.lib.LLVMPY_SetTimePasses(c_bool(enable))
       
       
    1: def report_and_reset_timings():
           """Returns the pass timings report and resets the LLVM internal timers.
       
           Pass timers are enabled by ``set_time_passes()``. If the timers are not
           enabled, this function will return an empty string.
       
           Returns
           -------
           res : str
               LLVM generated timing report.
           """
           with ffi.OutputString() as buf:
               ffi.lib.LLVMPY_ReportAndResetTimings(buf)
               return str(buf)
       
       
    1: def create_module_pass_manager():
    2:     return ModulePassManager()
       
       
    1: def create_function_pass_manager(module):
   38:     return FunctionPassManager(module)
       
       
    2: class RefPruneSubpasses(IntFlag):
    1:     PER_BB       = 0b0001    # noqa: E221
    1:     DIAMOND      = 0b0010    # noqa: E221
    1:     FANOUT       = 0b0100    # noqa: E221
    1:     FANOUT_RAISE = 0b1000
    1:     ALL = PER_BB | DIAMOND | FANOUT | FANOUT_RAISE
       
       
    2: class PassManager(ffi.ObjectRef):
    1:     """PassManager
           """
       
    1:     def _dispose(self):
   38:         self._capi.LLVMPY_DisposePassManager(self)
       
    1:     def add_aa_eval_pass(self):
               """
               See https://llvm.org/docs/Passes.html#aa-eval-exhaustive-alias-analysis-precision-evaluator
       
               LLVM 14: `llvm::createAAEvalPass`
               """  # noqa E501
               ffi.lib.LLVMPY_AddAAEvalPass(self)
       
    1:     def add_basic_aa_pass(self):
               """
               See https://llvm.org/docs/Passes.html#basic-aa-basic-alias-analysis-stateless-aa-impl
       
               LLVM 14: `llvm::createBasicAAWrapperPass`
               """  # noqa E501
               ffi.lib.LLVMPY_AddBasicAAWrapperPass(self)
       
    1:     def add_constant_merge_pass(self):
               """
               See http://llvm.org/docs/Passes.html#constmerge-merge-duplicate-global-constants
       
               LLVM 14: `LLVMAddConstantMergePass`
               """  # noqa E501
               ffi.lib.LLVMPY_AddConstantMergePass(self)
       
    1:     def add_dead_arg_elimination_pass(self):
               """
               See http://llvm.org/docs/Passes.html#deadargelim-dead-argument-elimination
       
               LLVM 14: `LLVMAddDeadArgEliminationPass`
               """  # noqa E501
               ffi.lib.LLVMPY_AddDeadArgEliminationPass(self)
       
    1:     def add_dependence_analysis_pass(self):
               """
               See https://llvm.org/docs/Passes.html#da-dependence-analysis
       
               LLVM 14: `llvm::createDependenceAnalysisWrapperPass`
               """  # noqa E501
               ffi.lib.LLVMPY_AddDependenceAnalysisPass(self)
       
    1:     def add_dot_call_graph_pass(self):
               """
               See https://llvm.org/docs/Passes.html#dot-callgraph-print-call-graph-to-dot-file
       
               LLVM 14: `llvm::createCallGraphDOTPrinterPass`
               """  # noqa E501
               ffi.lib.LLVMPY_AddCallGraphDOTPrinterPass(self)
       
    1:     def add_dot_cfg_printer_pass(self):
               """
               See https://llvm.org/docs/Passes.html#dot-cfg-print-cfg-of-function-to-dot-file
       
               LLVM 14: `llvm::createCFGPrinterLegacyPassPass`
               """  # noqa E501
               ffi.lib.LLVMPY_AddCFGPrinterPass(self)
       
    1:     def add_dot_dom_printer_pass(self, show_body=False):
               """
               See https://llvm.org/docs/Passes.html#dot-dom-print-dominance-tree-of-function-to-dot-file
       
               LLVM 14: `llvm::createDomPrinterPass` and `llvm::createDomOnlyPrinterPass`
               """  # noqa E501
               ffi.lib.LLVMPY_AddDotDomPrinterPass(self, show_body)
       
    1:     def add_dot_postdom_printer_pass(self, show_body=False):
               """
               See https://llvm.org/docs/Passes.html#dot-postdom-print-postdominance-tree-of-function-to-dot-file
       
               LLVM 14: `llvm::createPostDomPrinterPass` and `llvm::createPostDomOnlyPrinterPass`
               """  # noqa E501
               ffi.lib.LLVMPY_AddDotPostDomPrinterPass(self, show_body)
       
    1:     def add_globals_mod_ref_aa_pass(self):
               """
               See https://llvm.org/docs/Passes.html#globalsmodref-aa-simple-mod-ref-analysis-for-globals
       
               LLVM 14: `llvm::createGlobalsAAWrapperPass`
               """  # noqa E501
               ffi.lib.LLVMPY_AddGlobalsModRefAAPass(self)
       
    1:     def add_iv_users_pass(self):
               """
               See https://llvm.org/docs/Passes.html#iv-users-induction-variable-users
       
               LLVM 14: `llvm::createIVUsersPass`
               """  # noqa E501
               ffi.lib.LLVMPY_AddIVUsersPass(self)
       
    1:     def add_lint_pass(self):
               """
               See https://llvm.org/docs/Passes.html#lint-statically-lint-checks-llvm-ir
       
               LLVM 14: `llvm::createLintLegacyPassPass`
               """  # noqa E501
               ffi.lib.LLVMPY_AddLintPass(self)
       
    1:     def add_lazy_value_info_pass(self):
               """
               See https://llvm.org/docs/Passes.html#lazy-value-info-lazy-value-information-analysis
       
               LLVM 14: `llvm::createLazyValueInfoPass`
               """  # noqa E501
               ffi.lib.LLVMPY_AddLazyValueInfoPass(self)
       
    1:     def add_module_debug_info_pass(self):
               """
               See https://llvm.org/docs/Passes.html#module-debuginfo-decodes-module-level-debug-info
       
               LLVM 14: `llvm::createModuleDebugInfoPrinterPass`
               """  # noqa E501
               ffi.lib.LLVMPY_AddModuleDebugInfoPrinterPass(self)
       
    1:     def add_region_info_pass(self):
               """
               See https://llvm.org/docs/Passes.html#regions-detect-single-entry-single-exit-regions
       
               LLVM 14: `llvm::createRegionInfoPass`
               """  # noqa E501
               ffi.lib.LLVMPY_AddRegionInfoPass(self)
       
    1:     def add_scalar_evolution_aa_pass(self):
               """
               See https://llvm.org/docs/Passes.html#scev-aa-scalarevolution-based-alias-analysis
       
               LLVM 14: `llvm::createSCEVAAWrapperPass`
               """  # noqa E501
               ffi.lib.LLVMPY_AddScalarEvolutionAAPass(self)
       
    1:     def add_aggressive_dead_code_elimination_pass(self):
               """
               See https://llvm.org/docs/Passes.html#adce-aggressive-dead-code-elimination
       
               LLVM 14: `llvm::createAggressiveDCEPass`
               """  # noqa E501
               ffi.lib.LLVMPY_AddAggressiveDCEPass(self)
       
    1:     def add_always_inliner_pass(self, insert_lifetime=True):
               """
               See https://llvm.org/docs/Passes.html#always-inline-inliner-for-always-inline-functions
       
               LLVM 14: `llvm::createAlwaysInlinerLegacyPass`
               """  # noqa E501
               ffi.lib.LLVMPY_AddAlwaysInlinerPass(self, insert_lifetime)
       
    1:     def add_arg_promotion_pass(self, max_elements=3):
               """
               See https://llvm.org/docs/Passes.html#argpromotion-promote-by-reference-arguments-to-scalars
       
               LLVM 14: `llvm::createArgumentPromotionPass`
               """  # noqa E501
               ffi.lib.LLVMPY_AddArgPromotionPass(self, max_elements)
       
    1:     def add_break_critical_edges_pass(self):
               """
               See https://llvm.org/docs/Passes.html#break-crit-edges-break-critical-edges-in-cfg
       
               LLVM 14: `llvm::createBreakCriticalEdgesPass`
               """  # noqa E501
               ffi.lib.LLVMPY_AddBreakCriticalEdgesPass(self)
       
    1:     def add_dead_store_elimination_pass(self):
               """
               See https://llvm.org/docs/Passes.html#dse-dead-store-elimination
       
               LLVM 14: `llvm::createDeadStoreEliminationPass`
               """  # noqa E501
               ffi.lib.LLVMPY_AddDeadStoreEliminationPass(self)
       
    1:     def add_reverse_post_order_function_attrs_pass(self):
               """
               See https://llvm.org/docs/Passes.html#function-attrs-deduce-function-attributes
       
               LLVM 14: `llvm::createReversePostOrderFunctionAttrsPass`
               """  # noqa E501
               ffi.lib.LLVMPY_AddReversePostOrderFunctionAttrsPass(self)
       
    1:     def add_function_attrs_pass(self):
               """
               See http://llvm.org/docs/Passes.html#functionattrs-deduce-function-attributes
       
               LLVM 14: `LLVMAddFunctionAttrsPass`
               """  # noqa E501
               ffi.lib.LLVMPY_AddFunctionAttrsPass(self)
       
    1:     def add_function_inlining_pass(self, threshold):
               """
               See http://llvm.org/docs/Passes.html#inline-function-integration-inlining
       
               LLVM 14: `createFunctionInliningPass`
               """  # noqa E501
               ffi.lib.LLVMPY_AddFunctionInliningPass(self, threshold)
       
    1:     def add_global_dce_pass(self):
               """
               See http://llvm.org/docs/Passes.html#globaldce-dead-global-elimination
       
               LLVM 14: `LLVMAddGlobalDCEPass`
               """  # noqa E501
               ffi.lib.LLVMPY_AddGlobalDCEPass(self)
       
    1:     def add_global_optimizer_pass(self):
               """
               See http://llvm.org/docs/Passes.html#globalopt-global-variable-optimizer
       
               LLVM 14: `LLVMAddGlobalOptimizerPass`
               """  # noqa E501
               ffi.lib.LLVMPY_AddGlobalOptimizerPass(self)
       
    1:     def add_ipsccp_pass(self):
               """
               See http://llvm.org/docs/Passes.html#ipsccp-interprocedural-sparse-conditional-constant-propagation
       
               LLVM 14: `LLVMAddIPSCCPPass`
               """  # noqa E501
               ffi.lib.LLVMPY_AddIPSCCPPass(self)
       
    1:     def add_dead_code_elimination_pass(self):
               """
               See http://llvm.org/docs/Passes.html#dce-dead-code-elimination
               LLVM 14: `llvm::createDeadCodeEliminationPass`
               """
               ffi.lib.LLVMPY_AddDeadCodeEliminationPass(self)
       
    1:     def add_aggressive_instruction_combining_pass(self):
               """
               See https://llvm.org/docs/Passes.html#aggressive-instcombine-combine-expression-patterns
       
               LLVM 14: `llvm::createAggressiveInstCombinerPass`
               """  # noqa E501
               ffi.lib.LLVMPY_AddAggressiveInstructionCombiningPass(self)
       
    1:     def add_internalize_pass(self):
               """
               See https://llvm.org/docs/Passes.html#internalize-internalize-global-symbols
       
               LLVM 14: `llvm::createInternalizePass`
               """  # noqa E501
               ffi.lib.LLVMPY_AddInternalizePass(self)
       
    1:     def add_cfg_simplification_pass(self):
               """
               See http://llvm.org/docs/Passes.html#simplifycfg-simplify-the-cfg
       
               LLVM 14: `LLVMAddCFGSimplificationPass`
               """
               ffi.lib.LLVMPY_AddCFGSimplificationPass(self)
       
    1:     def add_jump_threading_pass(self, threshold=-1):
               """
               See https://llvm.org/docs/Passes.html#jump-threading-jump-threading
       
               LLVM 14: `llvm::createJumpThreadingPass`
               """  # noqa E501
    1:         ffi.lib.LLVMPY_AddJumpThreadingPass(self, threshold)
       
    1:     def add_lcssa_pass(self):
               """
               See https://llvm.org/docs/Passes.html#lcssa-loop-closed-ssa-form-pass
       
               LLVM 14: `llvm::createLCSSAPass`
               """  # noqa E501
               ffi.lib.LLVMPY_AddLCSSAPass(self)
       
    1:     def add_gvn_pass(self):
               """
               See http://llvm.org/docs/Passes.html#gvn-global-value-numbering
       
               LLVM 14: `LLVMAddGVNPass`
               """
               ffi.lib.LLVMPY_AddGVNPass(self)
       
    1:     def add_instruction_combining_pass(self):
               """
               See http://llvm.org/docs/Passes.html#passes-instcombine
       
               LLVM 14: `LLVMAddInstructionCombiningPass`
               """
    1:         ffi.lib.LLVMPY_AddInstructionCombiningPass(self)
       
    1:     def add_licm_pass(self):
               """
               See http://llvm.org/docs/Passes.html#licm-loop-invariant-code-motion
       
               LLVM 14: `LLVMAddLICMPass`
               """  # noqa E501
               ffi.lib.LLVMPY_AddLICMPass(self)
       
    1:     def add_loop_deletion_pass(self):
               """
               See https://llvm.org/docs/Passes.html#loop-deletion-delete-dead-loops
       
               LLVM 14: `llvm::createLoopDeletionPass`
               """  # noqa E501
               ffi.lib.LLVMPY_AddLoopDeletionPass(self)
       
    1:     def add_loop_extractor_pass(self):
               """
               See https://llvm.org/docs/Passes.html#loop-extract-extract-loops-into-new-functions
       
               LLVM 14: `llvm::createLoopExtractorPass`
               """  # noqa E501
               ffi.lib.LLVMPY_AddLoopExtractorPass(self)
       
    1:     def add_single_loop_extractor_pass(self):
               """
               See https://llvm.org/docs/Passes.html#loop-extract-single-extract-at-most-one-loop-into-a-new-function
       
               LLVM 14: `llvm::createSingleLoopExtractorPass`
               """  # noqa E501
               ffi.lib.LLVMPY_AddSingleLoopExtractorPass(self)
       
    1:     def add_sccp_pass(self):
               """
               See http://llvm.org/docs/Passes.html#sccp-sparse-conditional-constant-propagation
       
               LLVM 14: `LLVMAddSCCPPass`
               """  # noqa E501
               ffi.lib.LLVMPY_AddSCCPPass(self)
       
    1:     def add_loop_strength_reduce_pass(self):
               """
               See https://llvm.org/docs/Passes.html#loop-reduce-loop-strength-reduction
       
               LLVM 14: `llvm::createLoopStrengthReducePass`
               """  # noqa E501
               ffi.lib.LLVMPY_AddLoopStrengthReducePass(self)
       
    1:     def add_loop_simplification_pass(self):
               """
               See https://llvm.org/docs/Passes.html#loop-simplify-canonicalize-natural-loops
       
               LLVM 14: `llvm::createLoopSimplifyPass`
               """  # noqa E501
               ffi.lib.LLVMPY_AddLoopSimplificationPass(self)
       
    1:     def add_loop_unroll_pass(self):
               """
               See https://llvm.org/docs/Passes.html#loop-unroll-unroll-loops
       
               LLVM 14: `LLVMAddLoopUnrollPass`
               """  # noqa E501
               ffi.lib.LLVMPY_AddLoopUnrollPass(self)
       
    1:     def add_loop_unroll_and_jam_pass(self):
               """
               See https://llvm.org/docs/Passes.html#loop-unroll-and-jam-unroll-and-jam-loops
       
               LLVM 14: `LLVMAddLoopUnrollAndJamPass`
               """  # noqa E501
               ffi.lib.LLVMPY_AddLoopUnrollAndJamPass(self)
       
    1:     def add_loop_unswitch_pass(self,
    1:                                optimize_for_size=False,
    1:                                has_branch_divergence=False):
               """
               See https://llvm.org/docs/Passes.html#loop-unswitch-unswitch-loops
       
               LLVM 14: `llvm::createLoopUnswitchPass`
               """  # noqa E501
               ffi.lib.LLVMPY_AddLoopUnswitchPass(self,
                                                  optimize_for_size,
                                                  has_branch_divergence)
       
    1:     def add_lower_atomic_pass(self):
               """
               See https://llvm.org/docs/Passes.html#loweratomic-lower-atomic-intrinsics-to-non-atomic-form
       
               LLVM 14: `llvm::createLowerAtomicPass`
               """  # noqa E501
               ffi.lib.LLVMPY_AddLowerAtomicPass(self)
       
    1:     def add_lower_invoke_pass(self):
               """
               See https://llvm.org/docs/Passes.html#lowerinvoke-lower-invokes-to-calls-for-unwindless-code-generators
       
               LLVM 14: `llvm::createLowerInvokePass`
               """  # noqa E501
               ffi.lib.LLVMPY_AddLowerInvokePass(self)
       
    1:     def add_lower_switch_pass(self):
               """
               See https://llvm.org/docs/Passes.html#lowerswitch-lower-switchinsts-to-branches
       
               LLVM 14: `llvm::createLowerSwitchPass`
               """  # noqa E501
               ffi.lib.LLVMPY_AddLowerSwitchPass(self)
       
    1:     def add_memcpy_optimization_pass(self):
               """
               See https://llvm.org/docs/Passes.html#memcpyopt-memcpy-optimization
       
               LLVM 14: `llvm::createMemCpyOptPass`
               """  # noqa E501
               ffi.lib.LLVMPY_AddMemCpyOptimizationPass(self)
       
    1:     def add_merge_functions_pass(self):
               """
               See https://llvm.org/docs/Passes.html#mergefunc-merge-functions
       
               LLVM 14: `llvm::createMergeFunctionsPass`
               """  # noqa E501
               ffi.lib.LLVMPY_AddMergeFunctionsPass(self)
       
    1:     def add_merge_returns_pass(self):
               """
               See https://llvm.org/docs/Passes.html#mergereturn-unify-function-exit-nodes
       
               LLVM 14: `llvm::createUnifyFunctionExitNodesPass`
               """  # noqa E501
               ffi.lib.LLVMPY_AddMergeReturnsPass(self)
       
    1:     def add_partial_inlining_pass(self):
               """
               See https://llvm.org/docs/Passes.html#partial-inliner-partial-inliner
       
               LLVM 14: `llvm::createPartialInliningPass`
               """  # noqa E501
               ffi.lib.LLVMPY_AddPartialInliningPass(self)
       
    1:     def add_prune_exception_handling_pass(self):
               """
               See https://llvm.org/docs/Passes.html#prune-eh-remove-unused-exception-handling-info
       
               LLVM 14: `llvm::createPruneEHPass`
               """  # noqa E501
               ffi.lib.LLVMPY_AddPruneExceptionHandlingPass(self)
       
    1:     def add_reassociate_expressions_pass(self):
               """
               See https://llvm.org/docs/Passes.html#reassociate-reassociate-expressions
       
               LLVM 14: `llvm::createReassociatePass`
               """  # noqa E501
               ffi.lib.LLVMPY_AddReassociatePass(self)
       
    1:     def add_demote_register_to_memory_pass(self):
               """
               See https://llvm.org/docs/Passes.html#rel-lookup-table-converter-relative-lookup-table-converter
       
               LLVM 14: `llvm::createDemoteRegisterToMemoryPass`
               """  # noqa E501
               ffi.lib.LLVMPY_AddDemoteRegisterToMemoryPass(self)
       
    1:     def add_sroa_pass(self):
               """
               See http://llvm.org/docs/Passes.html#scalarrepl-scalar-replacement-of-aggregates-dt
               Note that this pass corresponds to the ``opt -sroa`` command-line option,
               despite the link above.
       
               LLVM 14: `llvm::createSROAPass`
               """  # noqa E501
               ffi.lib.LLVMPY_AddSROAPass(self)
       
    1:     def add_sink_pass(self):
               """
               See https://llvm.org/docs/Passes.html#sink-code-sinking
       
               LLVM 14: `llvm::createSinkingPass`
               """  # noqa E501
               ffi.lib.LLVMPY_AddSinkPass(self)
       
    1:     def add_strip_symbols_pass(self, only_debug=False):
               """
               See https://llvm.org/docs/Passes.html#strip-strip-all-symbols-from-a-module
       
               LLVM 14: `llvm::createStripSymbolsPass`
               """  # noqa E501
               ffi.lib.LLVMPY_AddStripSymbolsPass(self, only_debug)
       
    1:     def add_strip_dead_debug_info_pass(self):
               """
               See https://llvm.org/docs/Passes.html#strip-dead-debug-info-strip-debug-info-for-unused-symbols
       
               LLVM 14: `llvm::createStripDeadDebugInfoPass`
               """  # noqa E501
               ffi.lib.LLVMPY_AddStripDeadDebugInfoPass(self)
       
    1:     def add_strip_dead_prototypes_pass(self):
               """
               See https://llvm.org/docs/Passes.html#strip-dead-prototypes-strip-unused-function-prototypes
       
               LLVM 14: `llvm::createStripDeadPrototypesPass`
               """  # noqa E501
               ffi.lib.LLVMPY_AddStripDeadPrototypesPass(self)
       
    1:     def add_strip_debug_declare_pass(self):
               """
               See https://llvm.org/docs/Passes.html#strip-debug-declare-strip-all-llvm-dbg-declare-intrinsics
       
               LLVM 14: `llvm::createStripDebugDeclarePass`
               """  # noqa E501
               ffi.lib.LLVMPY_AddStripDebugDeclarePrototypesPass(self)
       
    1:     def add_strip_nondebug_symbols_pass(self):
               """
               See https://llvm.org/docs/Passes.html#strip-nondebug-strip-all-symbols-except-dbg-symbols-from-a-module
       
               LLVM 14: `llvm::createStripNonDebugSymbolsPass`
               """  # noqa E501
               ffi.lib.LLVMPY_AddStripNondebugSymbolsPass(self)
       
    1:     def add_tail_call_elimination_pass(self):
               """
               See https://llvm.org/docs/Passes.html#tailcallelim-tail-call-elimination
       
               LLVM 14: `llvm::createTailCallEliminationPass`
               """  # noqa E501
               ffi.lib.LLVMPY_AddTailCallEliminationPass(self)
       
    1:     def add_type_based_alias_analysis_pass(self):
               """
               LLVM 14: `LLVMAddTypeBasedAliasAnalysisPass`
               """  # noqa E501
               ffi.lib.LLVMPY_AddTypeBasedAliasAnalysisPass(self)
       
    1:     def add_basic_alias_analysis_pass(self):
               """
               See http://llvm.org/docs/AliasAnalysis.html#the-basicaa-pass
       
               LLVM 14: `LLVMAddBasicAliasAnalysisPass`
               """
               ffi.lib.LLVMPY_AddBasicAliasAnalysisPass(self)
       
    1:     def add_loop_rotate_pass(self):
               """http://llvm.org/docs/Passes.html#loop-rotate-rotate-loops."""
    1:         ffi.lib.LLVMPY_LLVMAddLoopRotatePass(self)
       
    1:     def add_target_library_info(self, triple):
   40:         ffi.lib.LLVMPY_AddTargetLibraryInfoPass(self, _encode_string(triple))
       
    1:     def add_instruction_namer_pass(self):
               """
               See https://llvm.org/docs/Passes.html#instnamer-assign-names-to-anonymous-instructions.
       
               LLVM 14: `llvm::createInstructionNamerPass`
               """  # noqa E501
               ffi.lib.LLVMPY_AddInstructionNamerPass(self)
       
           # Non-standard LLVM passes
       
    2:     def add_refprune_pass(self, subpasses_flags=RefPruneSubpasses.ALL,
    1:                           subgraph_limit=1000):
               """Add Numba specific Reference count pruning pass.
       
               Parameters
               ----------
               subpasses_flags : RefPruneSubpasses
                   A bitmask to control the subpasses to be enabled.
               subgraph_limit : int
                   Limit the fanout pruners to working on a subgraph no bigger than
                   this number of basic-blocks to avoid spending too much time in very
                   large graphs. Default is 1000. Subject to change in future
                   versions.
               """
   40:         iflags = RefPruneSubpasses(subpasses_flags)
   40:         ffi.lib.LLVMPY_AddRefPrunePass(self, iflags, subgraph_limit)
       
       
    2: class ModulePassManager(PassManager):
       
    1:     def __init__(self, ptr=None):
    2:         if ptr is None:
    2:             ptr = ffi.lib.LLVMPY_CreatePassManager()
    2:         PassManager.__init__(self, ptr)
       
    2:     def run(self, module, remarks_file=None, remarks_format='yaml',
    1:             remarks_filter=''):
               """
               Run optimization passes on the given module.
       
               Parameters
               ----------
               module : llvmlite.binding.ModuleRef
                   The module to be optimized inplace
               remarks_file : str; optional
                   If not `None`, it is the file to store the optimization remarks.
               remarks_format : str; optional
                   The format to write; YAML is default
               remarks_filter : str; optional
                   The filter that should be applied to the remarks output.
               """
   50:         if remarks_file is None:
   50:             return ffi.lib.LLVMPY_RunPassManager(self, module)
               else:
                   r = ffi.lib.LLVMPY_RunPassManagerWithRemarks(
                       self, module, _encode_string(remarks_format),
                       _encode_string(remarks_filter),
                       _encode_string(remarks_file))
                   if r == -1:
                       raise IOError("Failed to initialize remarks file.")
                   return r > 0
       
    2:     def run_with_remarks(self, module, remarks_format='yaml',
    1:                          remarks_filter=''):
               """
               Run optimization passes on the given module and returns the result and
               the remarks data.
       
               Parameters
               ----------
               module : llvmlite.binding.ModuleRef
                   The module to be optimized
               remarks_format : str
                   The remarks output; YAML is the default
               remarks_filter : str; optional
                   The filter that should be applied to the remarks output.
               """
               remarkdesc, remarkfile = mkstemp()
               try:
                   with os.fdopen(remarkdesc, 'r'):
                       pass
                   r = self.run(module, remarkfile, remarks_format, remarks_filter)
                   if r == -1:
                       raise IOError("Failed to initialize remarks file.")
                   with open(remarkfile) as f:
                       return bool(r), f.read()
               finally:
                   os.unlink(remarkfile)
       
       
    2: class FunctionPassManager(PassManager):
       
    1:     def __init__(self, module):
   38:         ptr = ffi.lib.LLVMPY_CreateFunctionPassManager(module)
   38:         self._module = module
   38:         module._owned = True
   38:         PassManager.__init__(self, ptr)
       
    1:     def initialize(self):
               """
               Initialize the FunctionPassManager.  Returns True if it produced
               any changes (?).
               """
  304:         return ffi.lib.LLVMPY_InitializeFunctionPassManager(self)
       
    1:     def finalize(self):
               """
               Finalize the FunctionPassManager.  Returns True if it produced
               any changes (?).
               """
  304:         return ffi.lib.LLVMPY_FinalizeFunctionPassManager(self)
       
    2:     def run(self, function, remarks_file=None, remarks_format='yaml',
    1:             remarks_filter=''):
               """
               Run optimization passes on the given function.
       
               Parameters
               ----------
               function : llvmlite.binding.FunctionRef
                   The function to be optimized inplace
               remarks_file : str; optional
                   If not `None`, it is the file to store the optimization remarks.
               remarks_format : str; optional
                   The format of the remarks file; the default is YAML
               remarks_filter : str; optional
                   The filter that should be applied to the remarks output.
               """
  304:         if remarks_file is None:
  304:             return ffi.lib.LLVMPY_RunFunctionPassManager(self, function)
               else:
                   r = ffi.lib.LLVMPY_RunFunctionPassManagerWithRemarks(
                       self, function, _encode_string(remarks_format),
                       _encode_string(remarks_filter),
                       _encode_string(remarks_file))
                   if r == -1:
                       raise IOError("Failed to initialize remarks file.")
                   return bool(r)
       
    2:     def run_with_remarks(self, function, remarks_format='yaml',
    1:                          remarks_filter=''):
               """
               Run optimization passes on the given function and returns the result
               and the remarks data.
       
               Parameters
               ----------
               function : llvmlite.binding.FunctionRef
                   The function to be optimized inplace
               remarks_format : str; optional
                   The format of the remarks file; the default is YAML
               remarks_filter : str; optional
                   The filter that should be applied to the remarks output.
               """
               # LLVM is going to need to close this file and then reopen it, so we
               # can't use an unlinked temporary file.
               remarkdesc, remarkfile = mkstemp()
               try:
                   # We get an open handle, but we need LLVM to write first, so close
                   # it.
                   with os.fdopen(remarkdesc, 'r'):
                       pass
                   r = self.run(function, remarkfile, remarks_format, remarks_filter)
                   if r == -1:
                       raise IOError("Failed to initialize remarks file.")
                   with open(remarkfile) as f:
                       return bool(r), f.read()
               finally:
                   os.unlink(remarkfile)
       
       
       # ============================================================================
       # FFI
       
    1: ffi.lib.LLVMPY_CreatePassManager.restype = ffi.LLVMPassManagerRef
       
    1: ffi.lib.LLVMPY_CreateFunctionPassManager.argtypes = [ffi.LLVMModuleRef]
    1: ffi.lib.LLVMPY_CreateFunctionPassManager.restype = ffi.LLVMPassManagerRef
       
    1: ffi.lib.LLVMPY_DisposePassManager.argtypes = [ffi.LLVMPassManagerRef]
       
    2: ffi.lib.LLVMPY_RunPassManager.argtypes = [ffi.LLVMPassManagerRef,
    1:                                           ffi.LLVMModuleRef]
    1: ffi.lib.LLVMPY_RunPassManager.restype = c_bool
       
    2: ffi.lib.LLVMPY_RunPassManagerWithRemarks.argtypes = [ffi.LLVMPassManagerRef,
    1:                                                      ffi.LLVMModuleRef,
    1:                                                      c_char_p,
    1:                                                      c_char_p,
    1:                                                      c_char_p]
    1: ffi.lib.LLVMPY_RunPassManagerWithRemarks.restype = c_int
       
    1: ffi.lib.LLVMPY_InitializeFunctionPassManager.argtypes = [ffi.LLVMPassManagerRef]
    1: ffi.lib.LLVMPY_InitializeFunctionPassManager.restype = c_bool
       
    1: ffi.lib.LLVMPY_FinalizeFunctionPassManager.argtypes = [ffi.LLVMPassManagerRef]
    1: ffi.lib.LLVMPY_FinalizeFunctionPassManager.restype = c_bool
       
    2: ffi.lib.LLVMPY_RunFunctionPassManager.argtypes = [ffi.LLVMPassManagerRef,
    1:                                                   ffi.LLVMValueRef]
    1: ffi.lib.LLVMPY_RunFunctionPassManager.restype = c_bool
       
    1: ffi.lib.LLVMPY_RunFunctionPassManagerWithRemarks.argtypes = [
    1:     ffi.LLVMPassManagerRef, ffi.LLVMValueRef, c_char_p, c_char_p, c_char_p
       ]
    1: ffi.lib.LLVMPY_RunFunctionPassManagerWithRemarks.restype = c_int
       
    1: ffi.lib.LLVMPY_AddAAEvalPass.argtypes = [ffi.LLVMPassManagerRef]
    1: ffi.lib.LLVMPY_AddBasicAAWrapperPass.argtypes = [ffi.LLVMPassManagerRef]
    1: ffi.lib.LLVMPY_AddConstantMergePass.argtypes = [ffi.LLVMPassManagerRef]
    1: ffi.lib.LLVMPY_AddDeadArgEliminationPass.argtypes = [ffi.LLVMPassManagerRef]
    1: ffi.lib.LLVMPY_AddDependenceAnalysisPass.argtypes = [ffi.LLVMPassManagerRef]
    1: ffi.lib.LLVMPY_AddCallGraphDOTPrinterPass.argtypes = [ffi.LLVMPassManagerRef]
    1: ffi.lib.LLVMPY_AddCFGPrinterPass.argtypes = [ffi.LLVMPassManagerRef]
    1: ffi.lib.LLVMPY_AddDotDomPrinterPass.argtypes = [ffi.LLVMPassManagerRef, c_bool]
    1: ffi.lib.LLVMPY_AddDotPostDomPrinterPass.argtypes = [
    1:     ffi.LLVMPassManagerRef,
    1:     c_bool]
    1: ffi.lib.LLVMPY_AddGlobalsModRefAAPass.argtypes = [ffi.LLVMPassManagerRef]
    1: ffi.lib.LLVMPY_AddInstructionCountPass.argtypes = [ffi.LLVMPassManagerRef]
    1: ffi.lib.LLVMPY_AddIVUsersPass.argtypes = [ffi.LLVMPassManagerRef]
    1: ffi.lib.LLVMPY_AddLazyValueInfoPass.argtypes = [ffi.LLVMPassManagerRef]
    1: ffi.lib.LLVMPY_AddLintPass.argtypes = [ffi.LLVMPassManagerRef]
    1: ffi.lib.LLVMPY_AddModuleDebugInfoPrinterPass.argtypes = [ffi.LLVMPassManagerRef]
    1: ffi.lib.LLVMPY_AddRegionInfoPass.argtypes = [ffi.LLVMPassManagerRef]
    1: ffi.lib.LLVMPY_AddScalarEvolutionAAPass.argtypes = [ffi.LLVMPassManagerRef]
    1: ffi.lib.LLVMPY_AddAggressiveDCEPass.argtypes = [ffi.LLVMPassManagerRef]
    1: ffi.lib.LLVMPY_AddAlwaysInlinerPass.argtypes = [ffi.LLVMPassManagerRef, c_bool]
    1: ffi.lib.LLVMPY_AddArgPromotionPass.argtypes = [ffi.LLVMPassManagerRef, c_uint]
    1: ffi.lib.LLVMPY_AddBreakCriticalEdgesPass.argtypes = [ffi.LLVMPassManagerRef]
    1: ffi.lib.LLVMPY_AddDeadStoreEliminationPass.argtypes = [
    1:     ffi.LLVMPassManagerRef]
    1: ffi.lib.LLVMPY_AddReversePostOrderFunctionAttrsPass.argtypes = [
    1:     ffi.LLVMPassManagerRef]
    1: ffi.lib.LLVMPY_AddAggressiveInstructionCombiningPass.argtypes = [
    1:     ffi.LLVMPassManagerRef]
    1: ffi.lib.LLVMPY_AddInternalizePass.argtypes = [ffi.LLVMPassManagerRef]
    1: ffi.lib.LLVMPY_AddLCSSAPass.argtypes = [ffi.LLVMPassManagerRef]
    1: ffi.lib.LLVMPY_AddLoopDeletionPass.argtypes = [ffi.LLVMPassManagerRef]
    1: ffi.lib.LLVMPY_AddLoopExtractorPass.argtypes = [ffi.LLVMPassManagerRef]
    1: ffi.lib.LLVMPY_AddSingleLoopExtractorPass.argtypes = [ffi.LLVMPassManagerRef]
    1: ffi.lib.LLVMPY_AddLoopStrengthReducePass.argtypes = [ffi.LLVMPassManagerRef]
    1: ffi.lib.LLVMPY_AddLoopSimplificationPass.argtypes = [ffi.LLVMPassManagerRef]
    1: ffi.lib.LLVMPY_AddLoopUnrollPass.argtypes = [ffi.LLVMPassManagerRef]
    1: ffi.lib.LLVMPY_AddLoopUnrollAndJamPass.argtypes = [ffi.LLVMPassManagerRef]
    1: ffi.lib.LLVMPY_AddLoopUnswitchPass.argtypes = [
    1:     ffi.LLVMPassManagerRef,
    1:     c_bool,
    1:     c_bool]
    1: ffi.lib.LLVMPY_AddLowerAtomicPass.argtypes = [ffi.LLVMPassManagerRef]
    1: ffi.lib.LLVMPY_AddLowerInvokePass.argtypes = [ffi.LLVMPassManagerRef]
    1: ffi.lib.LLVMPY_AddLowerSwitchPass.argtypes = [ffi.LLVMPassManagerRef]
    1: ffi.lib.LLVMPY_AddMemCpyOptimizationPass.argtypes = [ffi.LLVMPassManagerRef]
    1: ffi.lib.LLVMPY_AddMergeFunctionsPass.argtypes = [ffi.LLVMPassManagerRef]
    1: ffi.lib.LLVMPY_AddMergeReturnsPass.argtypes = [ffi.LLVMPassManagerRef]
    1: ffi.lib.LLVMPY_AddPartialInliningPass.argtypes = [ffi.LLVMPassManagerRef]
    1: ffi.lib.LLVMPY_AddPruneExceptionHandlingPass.argtypes = [ffi.LLVMPassManagerRef]
    1: ffi.lib.LLVMPY_AddReassociatePass.argtypes = [ffi.LLVMPassManagerRef]
    1: ffi.lib.LLVMPY_AddDemoteRegisterToMemoryPass.argtypes = [ffi.LLVMPassManagerRef]
    1: ffi.lib.LLVMPY_AddSinkPass.argtypes = [ffi.LLVMPassManagerRef]
    1: ffi.lib.LLVMPY_AddStripSymbolsPass.argtypes = [ffi.LLVMPassManagerRef, c_bool]
    1: ffi.lib.LLVMPY_AddStripDeadDebugInfoPass.argtypes = [ffi.LLVMPassManagerRef]
    1: ffi.lib.LLVMPY_AddStripDeadPrototypesPass.argtypes = [ffi.LLVMPassManagerRef]
    1: ffi.lib.LLVMPY_AddStripDebugDeclarePrototypesPass.argtypes = [
    1:     ffi.LLVMPassManagerRef]
    1: ffi.lib.LLVMPY_AddStripNondebugSymbolsPass.argtypes = [ffi.LLVMPassManagerRef]
    1: ffi.lib.LLVMPY_AddTailCallEliminationPass.argtypes = [ffi.LLVMPassManagerRef]
    1: ffi.lib.LLVMPY_AddJumpThreadingPass.argtypes = [ffi.LLVMPassManagerRef, c_int]
    1: ffi.lib.LLVMPY_AddFunctionAttrsPass.argtypes = [ffi.LLVMPassManagerRef]
    1: ffi.lib.LLVMPY_AddFunctionInliningPass.argtypes = [
    1:     ffi.LLVMPassManagerRef, c_int]
    1: ffi.lib.LLVMPY_AddGlobalDCEPass.argtypes = [ffi.LLVMPassManagerRef]
    1: ffi.lib.LLVMPY_AddGlobalOptimizerPass.argtypes = [ffi.LLVMPassManagerRef]
    1: ffi.lib.LLVMPY_AddIPSCCPPass.argtypes = [ffi.LLVMPassManagerRef]
       
    1: ffi.lib.LLVMPY_AddDeadCodeEliminationPass.argtypes = [ffi.LLVMPassManagerRef]
    1: ffi.lib.LLVMPY_AddCFGSimplificationPass.argtypes = [ffi.LLVMPassManagerRef]
    1: ffi.lib.LLVMPY_AddGVNPass.argtypes = [ffi.LLVMPassManagerRef]
    1: ffi.lib.LLVMPY_AddInstructionCombiningPass.argtypes = [ffi.LLVMPassManagerRef]
    1: ffi.lib.LLVMPY_AddLICMPass.argtypes = [ffi.LLVMPassManagerRef]
    1: ffi.lib.LLVMPY_AddSCCPPass.argtypes = [ffi.LLVMPassManagerRef]
    1: ffi.lib.LLVMPY_AddSROAPass.argtypes = [ffi.LLVMPassManagerRef]
    1: ffi.lib.LLVMPY_AddTypeBasedAliasAnalysisPass.argtypes = [ffi.LLVMPassManagerRef]
    1: ffi.lib.LLVMPY_AddBasicAliasAnalysisPass.argtypes = [ffi.LLVMPassManagerRef]
    2: ffi.lib.LLVMPY_AddTargetLibraryInfoPass.argtypes = [ffi.LLVMPassManagerRef,
    1:                                                     c_char_p]
    1: ffi.lib.LLVMPY_AddInstructionNamerPass.argtypes = [ffi.LLVMPassManagerRef]
       
    2: ffi.lib.LLVMPY_AddRefPrunePass.argtypes = [ffi.LLVMPassManagerRef, c_int,
    1:                                            c_size_t]
       
    1: ffi.lib.LLVMPY_DumpRefPruneStats.argtypes = [POINTER(_c_PruneStats), c_bool]
