    1: """
       Implement python 3.8+ bytecode analysis
       """
    1: import dis
    1: from pprint import pformat
    1: import logging
    1: from collections import namedtuple, defaultdict, deque
    1: from functools import total_ordering
       
    1: from numba.core.utils import UniqueDict, PYVERSION, ALL_BINOPS_TO_OPERATORS
    1: from numba.core.controlflow import NEW_BLOCKERS, CFGraph
    1: from numba.core.ir import Loc
    1: from numba.core.errors import UnsupportedError
       
       
    1: _logger = logging.getLogger(__name__)
       
    1: _EXCEPT_STACK_OFFSET = 6
    1: _FINALLY_POP = _EXCEPT_STACK_OFFSET
    1: _NO_RAISE_OPS = frozenset({
           'LOAD_CONST',
           'NOP',
           'LOAD_DEREF',
           'PRECALL',
       })
       
    1: if PYVERSION in ((3, 12), ):
           from enum import Enum
       
           # Operands for CALL_INTRINSIC_1
           class CALL_INTRINSIC_1_Operand(Enum):
               INTRINSIC_STOPITERATION_ERROR = 3
               UNARY_POSITIVE = 5
               INTRINSIC_LIST_TO_TUPLE = 6
           ci1op = CALL_INTRINSIC_1_Operand
    1: elif PYVERSION in ((3, 9), (3, 10), (3, 11)):
    1:     pass
       else:
           raise NotImplementedError(PYVERSION)
       
       
    3: @total_ordering
    2: class BlockKind(object):
    1:     """Kinds of block to make related code safer than just `str`.
           """
    1:     _members = frozenset({
               'LOOP',
               'TRY', 'EXCEPT', 'FINALLY',
               'WITH', 'WITH_FINALLY',
           })
       
    1:     def __init__(self, value):
 1711:         assert value in self._members
 1711:         self._value = value
       
    1:     def __hash__(self):
               return hash((type(self), self._value))
       
    1:     def __lt__(self, other):
               if isinstance(other, BlockKind):
                   return self._value < other._value
               else:
                   raise TypeError('cannot compare to {!r}'.format(type(other)))
       
    1:     def __eq__(self, other):
               if isinstance(other, BlockKind):
                   return self._value == other._value
               else:
                   raise TypeError('cannot compare to {!r}'.format(type(other)))
       
    1:     def __repr__(self):
               return "BlockKind({})".format(self._value)
       
       
    2: class _lazy_pformat(object):
    1:     def __init__(self, *args, **kwargs):
  152:         self.args = args
  152:         self.kwargs = kwargs
       
    1:     def __str__(self):
               return pformat(*self.args, **self.kwargs)
       
       
    2: class Flow(object):
    1:     """Data+Control Flow analysis.
       
           Simulate execution to recover dataflow and controlflow information.
           """
    1:     def __init__(self, bytecode):
   24:         _logger.debug("bytecode dump:\n%s", bytecode.dump())
   24:         self._bytecode = bytecode
   24:         self.block_infos = UniqueDict()
       
    1:     def run(self):
               """Run a trace over the bytecode over all reachable path.
       
               The trace starts at bytecode offset 0 and gathers stack and control-
               flow information by partially interpreting each bytecode.
               Each ``State`` instance in the trace corresponds to a basic-block.
               The State instances forks when a jump instruction is encountered.
               A newly forked state is then added to the list of pending states.
               The trace ends when there are no more pending states.
               """
   48:         firststate = State(bytecode=self._bytecode, pc=0, nstack=0,
   24:                            blockstack=())
   24:         runner = TraceRunner(debug_filename=self._bytecode.func_id.filename)
   24:         runner.pending.append(firststate)
       
               # Enforce unique-ness on initial PC to avoid re-entering the PC with
               # a different stack-depth. We don't know if such a case is ever
               # possible, but no such case has been encountered in our tests.
   24:         first_encounter = UniqueDict()
               # Loop over each pending state at a initial PC.
               # Each state is tracing a basic block
  147:         while runner.pending:
  123:             _logger.debug("pending: %s", runner.pending)
  123:             state = runner.pending.popleft()
  123:             if state not in runner.finished:
  100:                 _logger.debug("stack: %s", state._stack)
  100:                 _logger.debug("state.pc_initial: %s", state)
  100:                 first_encounter[state.pc_initial] = state
                       # Loop over the state until it is terminated.
 1795:                 while True:
 1795:                     runner.dispatch(state)
                           # Terminated?
 1795:                     if state.has_terminated():
   86:                         break
                           else:
 1709:                         if self._run_handle_exception(runner, state):
                                   break
       
 1709:                         if self._is_implicit_new_block(state):
                                   # check if this is a with...as, abort if so
   14:                             self._guard_with_as(state)
                                   # else split
   14:                             state.split_new_block()
   14:                             break
  100:                 _logger.debug("end state. edges=%s", state.outgoing_edges)
  100:                 runner.finished.add(state)
  100:                 out_states = state.get_outgoing_states()
  100:                 runner.pending.extend(out_states)
       
               # Complete controlflow
   24:         self._build_cfg(runner.finished)
               # Prune redundant PHI-nodes
   24:         self._prune_phis(runner)
               # Post process
  224:         for state in sorted(runner.finished, key=lambda x: x.pc_initial):
  100:             self.block_infos[state.pc_initial] = si = adapt_state_infos(state)
  100:             _logger.debug("block_infos %s:\n%s", state, si)
       
    1:     if PYVERSION in ((3, 11), (3, 12)):
    1:         def _run_handle_exception(self, runner, state):
 3418:             if not state.in_with() and (
 1709:                     state.has_active_try() and
                           state.get_inst().opname not in _NO_RAISE_OPS):
                       # Is in a *try* block
                       state.fork(pc=state.get_inst().next)
                       runner._adjust_except_stack(state)
                       return True
                   else:
 1709:                 state.advance_pc()
       
                       # Must the new PC be a new block?
 1709:                 if not state.in_with() and state.is_in_exception():
                           _logger.debug("3.11 exception %s PC=%s",
                                         state.get_exception(), state._pc)
                           eh = state.get_exception()
                           eh_top = state.get_top_block('TRY')
                           if eh_top and eh_top['end'] == eh.target:
                               # Same exception
                               eh_block = None
                           else:
                               eh_block = state.make_block("TRY", end=eh.target)
                               eh_block['end_offset'] = eh.end
                               eh_block['stack_depth'] = eh.depth
                               eh_block['push_lasti'] = eh.lasti
                               state.fork(pc=state._pc, extra_block=eh_block)
                               return True
           elif PYVERSION in ((3, 9), (3, 10)):
               def _run_handle_exception(self, runner, state):
                   if (state.has_active_try() and
                           state.get_inst().opname not in _NO_RAISE_OPS):
                       # Is in a *try* block
                       state.fork(pc=state.get_inst().next)
                       tryblk = state.get_top_block('TRY')
                       state.pop_block_and_above(tryblk)
                       nstack = state.stack_depth
                       kwargs = {}
                       if nstack > tryblk['entry_stack']:
                           kwargs['npop'] = nstack - tryblk['entry_stack']
                       handler = tryblk['handler']
                       kwargs['npush'] = {
                           BlockKind('EXCEPT'): _EXCEPT_STACK_OFFSET,
                           BlockKind('FINALLY'): _FINALLY_POP
                       }[handler['kind']]
                       kwargs['extra_block'] = handler
                       state.fork(pc=tryblk['end'], **kwargs)
                       return True
                   else:
                       state.advance_pc()
           else:
               raise NotImplementedError(PYVERSION)
       
    1:     def _build_cfg(self, all_states):
   24:         graph = CFGraph()
  124:         for state in all_states:
  100:             b = state.pc_initial
  100:             graph.add_node(b)
  124:         for state in all_states:
  199:             for edge in state.outgoing_edges:
   99:                 graph.add_edge(state.pc_initial, edge.pc, 0)
   24:         graph.set_entry_point(0)
   24:         graph.process()
   24:         self.cfgraph = graph
       
    1:     def _prune_phis(self, runner):
               # Find phis that are unused in the local block
   24:         _logger.debug("Prune PHIs".center(60, '-'))
       
               # Compute dataflow for used phis and propagate
       
               # 1. Get used-phis for each block
               # Map block to used_phis
   24:         def get_used_phis_per_state():
   24:             used_phis = defaultdict(set)
   24:             phi_set = set()
  124:             for state in runner.finished:
  100:                 used = set(state._used_regs)
  100:                 phis = set(state._phis)
  100:                 used_phis[state] |= phis & used
  100:                 phi_set |= phis
   24:             return used_phis, phi_set
       
               # Find use-defs
   24:         def find_use_defs():
   24:             defmap = {}
   24:             phismap = defaultdict(set)
  124:             for state in runner.finished:
  144:                 for phi, rhs in state._outgoing_phis.items():
   44:                     if rhs not in phi_set:
                               # Is a definition
   12:                         defmap[phi] = state
   44:                     phismap[phi].add((rhs, state))
   24:             _logger.debug("defmap: %s", _lazy_pformat(defmap))
   24:             _logger.debug("phismap: %s", _lazy_pformat(phismap))
   24:             return defmap, phismap
       
   24:         def propagate_phi_map(phismap):
                   """An iterative dataflow algorithm to find the definition
                   (the source) of each PHI node.
                   """
   24:             blacklist = defaultdict(set)
       
   32:             while True:
   32:                 changing = False
  154:                 for phi, defsites in sorted(list(phismap.items())):
  281:                     for rhs, state in sorted(list(defsites)):
  159:                         if rhs in phi_set:
   57:                             defsites |= phismap[rhs]
   57:                             blacklist[phi].add((rhs, state))
  122:                     to_remove = blacklist[phi]
  122:                     if to_remove & defsites:
   49:                         defsites -= to_remove
   49:                         changing = True
       
   32:                 _logger.debug("changing phismap: %s", _lazy_pformat(phismap))
   32:                 if not changing:
   24:                     break
       
   24:         def apply_changes(used_phis, phismap):
   24:             keep = {}
  124:             for state, used_set in used_phis.items():
  111:                 for phi in used_set:
   11:                     keep[phi] = phismap[phi]
   24:             _logger.debug("keep phismap: %s", _lazy_pformat(keep))
   24:             new_out = defaultdict(dict)
   35:             for phi in keep:
   23:                 for rhs, state in keep[phi]:
   12:                     new_out[state][phi] = rhs
       
   24:             _logger.debug("new_out: %s", _lazy_pformat(new_out))
  124:             for state in runner.finished:
  100:                 state._outgoing_phis.clear()
  100:                 state._outgoing_phis.update(new_out[state])
       
   24:         used_phis, phi_set = get_used_phis_per_state()
   24:         _logger.debug("Used_phis: %s", _lazy_pformat(used_phis))
   24:         defmap, phismap = find_use_defs()
   24:         propagate_phi_map(phismap)
   24:         apply_changes(used_phis, phismap)
   24:         _logger.debug("DONE Prune PHIs".center(60, '-'))
       
    1:     def _is_implicit_new_block(self, state):
 1709:         inst = state.get_inst()
       
 1709:         if inst.offset in self._bytecode.labels:
   12:             return True
 1697:         elif inst.opname in NEW_BLOCKERS:
    2:             return True
               else:
 1695:             return False
       
    1:     def _guard_with_as(self, state):
               """Checks if the next instruction after a SETUP_WITH is something other
               than a POP_TOP, if it is something else it'll be some sort of store
               which is not supported (this corresponds to `with CTXMGR as VAR(S)`)."""
   14:         current_inst = state.get_inst()
   14:         if current_inst.opname in {"SETUP_WITH", "BEFORE_WITH"}:
                   next_op = self._bytecode[current_inst.next].opname
                   if next_op != "POP_TOP":
                       msg = ("The 'with (context manager) as "
                              "(variable):' construct is not "
                              "supported.")
                       raise UnsupportedError(msg)
       
       
    1: def _is_null_temp_reg(reg):
  107:     return reg.startswith("$null$")
       
       
    2: class TraceRunner(object):
    1:     """Trace runner contains the states for the trace and the opcode dispatch.
           """
    1:     def __init__(self, debug_filename):
   24:         self.debug_filename = debug_filename
   24:         self.pending = deque()
   24:         self.finished = set()
       
    1:     def get_debug_loc(self, lineno):
               return Loc(self.debug_filename, lineno)
       
    1:     def dispatch(self, state):
 1795:         if PYVERSION in ((3, 11), (3, 12)):
 1795:             if state._blockstack:
                       state: State
                       while state._blockstack:
                           topblk = state._blockstack[-1]
                           blk_end = topblk['end']
                           if blk_end is not None and blk_end <= state.pc_initial:
                               state._blockstack.pop()
                           else:
                               break
               elif PYVERSION in ((3, 9), (3, 10)):
                   pass
               else:
                   raise NotImplementedError(PYVERSION)
 1795:         inst = state.get_inst()
 1795:         if inst.opname != "CACHE":
  818:             _logger.debug("dispatch pc=%s, inst=%s", state._pc, inst)
  818:             _logger.debug("stack %s", state._stack)
 1795:         fn = getattr(self, "op_{}".format(inst.opname), None)
 1795:         if fn is not None:
 1795:             fn(state, inst)
               else:
                   msg = "Use of unsupported opcode (%s) found" % inst.opname
                   raise UnsupportedError(msg, loc=self.get_debug_loc(inst.lineno))
       
    1:     def _adjust_except_stack(self, state):
               """
               Adjust stack when entering an exception handler to match expectation
               by the bytecode.
               """
               tryblk = state.get_top_block('TRY')
               state.pop_block_and_above(tryblk)
               nstack = state.stack_depth
               kwargs = {}
               expected_depth = tryblk['stack_depth']
               if nstack > expected_depth:
                   # Pop extra item in the stack
                   kwargs['npop'] = nstack - expected_depth
               # Set extra stack itemcount due to the exception values.
               extra_stack = 1
               if tryblk['push_lasti']:
                   extra_stack += 1
               kwargs['npush'] = extra_stack
               state.fork(pc=tryblk['end'], **kwargs)
       
    1:     def op_NOP(self, state, inst):
   28:         state.append(inst)
       
    1:     def op_RESUME(self, state, inst):
   24:         state.append(inst)
       
    1:     def op_CACHE(self, state, inst):
  977:         state.append(inst)
       
    1:     def op_PRECALL(self, state, inst):
   62:         state.append(inst)
       
    1:     def op_PUSH_NULL(self, state, inst):
    6:         state.push(state.make_null())
    6:         state.append(inst)
       
    1:     def op_RETURN_GENERATOR(self, state, inst):
               # This impl doesn't follow what CPython does. CPython is hacking
               # the frame stack in the interpreter. From usage, it always
               # has a POP_TOP after it so we push a dummy value to the stack.
               #
               # Example bytecode:
               # >          0  NOP(arg=None, lineno=80)
               #            2  RETURN_GENERATOR(arg=None, lineno=80)
               #            4  POP_TOP(arg=None, lineno=80)
               #            6  RESUME(arg=0, lineno=80)
               state.push(state.make_temp())
               state.append(inst)
       
    1:     def op_FORMAT_VALUE(self, state, inst):
               """
               FORMAT_VALUE(flags): flags argument specifies format spec which is
               not supported yet. Currently, we just call str() on the value.
               Pops a value from stack and pushes results back.
               Required for supporting f-strings.
               https://docs.python.org/3/library/dis.html#opcode-FORMAT_VALUE
               """
               if inst.arg != 0:
                   msg = "format spec in f-strings not supported yet"
                   raise UnsupportedError(msg, loc=self.get_debug_loc(inst.lineno))
               value = state.pop()
               strvar = state.make_temp()
               res = state.make_temp()
               state.append(inst, value=value, res=res, strvar=strvar)
               state.push(res)
       
    1:     def op_BUILD_STRING(self, state, inst):
               """
               BUILD_STRING(count): Concatenates count strings from the stack and
               pushes the resulting string onto the stack.
               Required for supporting f-strings.
               https://docs.python.org/3/library/dis.html#opcode-BUILD_STRING
               """
               count = inst.arg
               strings = list(reversed([state.pop() for _ in range(count)]))
               # corner case: f""
               if count == 0:
                   tmps = [state.make_temp()]
               else:
                   tmps = [state.make_temp() for _ in range(count - 1)]
               state.append(inst, strings=strings, tmps=tmps)
               state.push(tmps[-1])
       
    1:     def op_POP_TOP(self, state, inst):
    2:         state.pop()
       
    1:     if PYVERSION in ((3, 11), (3, 12)):
    1:         def op_LOAD_GLOBAL(self, state, inst):
   58:             res = state.make_temp()
   58:             idx = inst.arg >> 1
   58:             state.append(inst, idx=idx, res=res)
                   # ignoring the NULL
   58:             if inst.arg & 1:
   55:                 state.push(state.make_null())
   58:             state.push(res)
           elif PYVERSION in ((3, 9), (3, 10)):
               def op_LOAD_GLOBAL(self, state, inst):
                   res = state.make_temp()
                   state.append(inst, res=res)
                   state.push(res)
           else:
               raise NotImplementedError(PYVERSION)
       
    1:     def op_COPY_FREE_VARS(self, state, inst):
    7:         state.append(inst)
       
    1:     def op_MAKE_CELL(self, state, inst):
               state.append(inst)
       
    1:     def op_LOAD_DEREF(self, state, inst):
   12:         res = state.make_temp()
   12:         state.append(inst, res=res)
   12:         state.push(res)
       
    1:     def op_LOAD_CONST(self, state, inst):
   57:         res = state.make_temp("const")
   57:         state.push(res)
   57:         state.append(inst, res=res)
       
    1:     def op_LOAD_ATTR(self, state, inst):
   48:         item = state.pop()
   48:         if PYVERSION in ((3, 12), ):
                   if inst.arg & 1:
                       state.push(state.make_null())
   48:         elif PYVERSION in ((3, 9), (3, 10), (3, 11)):
   48:             pass
               else:
                   raise NotImplementedError(PYVERSION)
   48:         res = state.make_temp()
   48:         state.append(inst, item=item, res=res)
   48:         state.push(res)
       
    1:     def op_LOAD_FAST(self, state, inst):
  197:         name = state.get_varname(inst)
  197:         res = state.make_temp(name)
  197:         state.append(inst, res=res)
  197:         state.push(res)
       
    1:     if PYVERSION in ((3, 12), ):
               op_LOAD_FAST_CHECK = op_LOAD_FAST
               op_LOAD_FAST_AND_CLEAR = op_LOAD_FAST
    1:     elif PYVERSION in ((3, 9), (3, 10), (3, 11)):
    1:         pass
           else:
               raise NotImplementedError(PYVERSION)
       
    1:     def op_DELETE_FAST(self, state, inst):
               state.append(inst)
       
    1:     def op_DELETE_ATTR(self, state, inst):
               target = state.pop()
               state.append(inst, target=target)
       
    1:     def op_STORE_ATTR(self, state, inst):
               target = state.pop()
               value = state.pop()
               state.append(inst, target=target, value=value)
       
    1:     def op_STORE_DEREF(self, state, inst):
               value = state.pop()
               state.append(inst, value=value)
       
    1:     def op_STORE_FAST(self, state, inst):
   48:         value = state.pop()
   48:         state.append(inst, value=value)
       
    1:     def op_SLICE_1(self, state, inst):
               """
               TOS = TOS1[TOS:]
               """
               tos = state.pop()
               tos1 = state.pop()
               res = state.make_temp()
               slicevar = state.make_temp()
               indexvar = state.make_temp()
               nonevar = state.make_temp()
               state.append(
                   inst,
                   base=tos1,
                   start=tos,
                   res=res,
                   slicevar=slicevar,
                   indexvar=indexvar,
                   nonevar=nonevar,
               )
               state.push(res)
       
    1:     def op_SLICE_2(self, state, inst):
               """
               TOS = TOS1[:TOS]
               """
               tos = state.pop()
               tos1 = state.pop()
               res = state.make_temp()
               slicevar = state.make_temp()
               indexvar = state.make_temp()
               nonevar = state.make_temp()
               state.append(
                   inst,
                   base=tos1,
                   stop=tos,
                   res=res,
                   slicevar=slicevar,
                   indexvar=indexvar,
                   nonevar=nonevar,
               )
               state.push(res)
       
    1:     def op_SLICE_3(self, state, inst):
               """
               TOS = TOS2[TOS1:TOS]
               """
               tos = state.pop()
               tos1 = state.pop()
               tos2 = state.pop()
               res = state.make_temp()
               slicevar = state.make_temp()
               indexvar = state.make_temp()
               state.append(
                   inst,
                   base=tos2,
                   start=tos1,
                   stop=tos,
                   res=res,
                   slicevar=slicevar,
                   indexvar=indexvar,
               )
               state.push(res)
       
    1:     def op_STORE_SLICE_0(self, state, inst):
               """
               TOS[:] = TOS1
               """
               tos = state.pop()
               value = state.pop()
               slicevar = state.make_temp()
               indexvar = state.make_temp()
               nonevar = state.make_temp()
               state.append(
                   inst,
                   base=tos,
                   value=value,
                   slicevar=slicevar,
                   indexvar=indexvar,
                   nonevar=nonevar,
               )
       
    1:     def op_STORE_SLICE_1(self, state, inst):
               """
               TOS1[TOS:] = TOS2
               """
               tos = state.pop()
               tos1 = state.pop()
               value = state.pop()
               slicevar = state.make_temp()
               indexvar = state.make_temp()
               nonevar = state.make_temp()
               state.append(
                   inst,
                   base=tos1,
                   start=tos,
                   slicevar=slicevar,
                   value=value,
                   indexvar=indexvar,
                   nonevar=nonevar,
               )
       
    1:     def op_STORE_SLICE_2(self, state, inst):
               """
               TOS1[:TOS] = TOS2
               """
               tos = state.pop()
               tos1 = state.pop()
               value = state.pop()
               slicevar = state.make_temp()
               indexvar = state.make_temp()
               nonevar = state.make_temp()
               state.append(
                   inst,
                   base=tos1,
                   stop=tos,
                   value=value,
                   slicevar=slicevar,
                   indexvar=indexvar,
                   nonevar=nonevar,
               )
       
    1:     def op_STORE_SLICE_3(self, state, inst):
               """
               TOS2[TOS1:TOS] = TOS3
               """
               tos = state.pop()
               tos1 = state.pop()
               tos2 = state.pop()
               value = state.pop()
               slicevar = state.make_temp()
               indexvar = state.make_temp()
               state.append(
                   inst,
                   base=tos2,
                   start=tos1,
                   stop=tos,
                   value=value,
                   slicevar=slicevar,
                   indexvar=indexvar,
               )
       
    1:     def op_DELETE_SLICE_0(self, state, inst):
               """
               del TOS[:]
               """
               tos = state.pop()
               slicevar = state.make_temp()
               indexvar = state.make_temp()
               nonevar = state.make_temp()
               state.append(
                   inst, base=tos, slicevar=slicevar, indexvar=indexvar,
                   nonevar=nonevar,
               )
       
    1:     def op_DELETE_SLICE_1(self, state, inst):
               """
               del TOS1[TOS:]
               """
               tos = state.pop()
               tos1 = state.pop()
               slicevar = state.make_temp()
               indexvar = state.make_temp()
               nonevar = state.make_temp()
               state.append(
                   inst,
                   base=tos1,
                   start=tos,
                   slicevar=slicevar,
                   indexvar=indexvar,
                   nonevar=nonevar,
               )
       
    1:     def op_DELETE_SLICE_2(self, state, inst):
               """
               del TOS1[:TOS]
               """
               tos = state.pop()
               tos1 = state.pop()
               slicevar = state.make_temp()
               indexvar = state.make_temp()
               nonevar = state.make_temp()
               state.append(
                   inst,
                   base=tos1,
                   stop=tos,
                   slicevar=slicevar,
                   indexvar=indexvar,
                   nonevar=nonevar,
               )
       
    1:     def op_DELETE_SLICE_3(self, state, inst):
               """
               del TOS2[TOS1:TOS]
               """
               tos = state.pop()
               tos1 = state.pop()
               tos2 = state.pop()
               slicevar = state.make_temp()
               indexvar = state.make_temp()
               state.append(
                   inst, base=tos2, start=tos1, stop=tos, slicevar=slicevar,
                   indexvar=indexvar
               )
       
    1:     def op_BUILD_SLICE(self, state, inst):
               """
               slice(TOS1, TOS) or slice(TOS2, TOS1, TOS)
               """
    6:         argc = inst.arg
    6:         if argc == 2:
    6:             tos = state.pop()
    6:             tos1 = state.pop()
    6:             start = tos1
    6:             stop = tos
    6:             step = None
               elif argc == 3:
                   tos = state.pop()
                   tos1 = state.pop()
                   tos2 = state.pop()
                   start = tos2
                   stop = tos1
                   step = tos
               else:
                   raise Exception("unreachable")
    6:         slicevar = state.make_temp()
    6:         res = state.make_temp()
   12:         state.append(
    6:             inst, start=start, stop=stop, step=step, res=res, slicevar=slicevar
               )
    6:         state.push(res)
       
    1:     if PYVERSION in ((3, 12), ):
               def op_BINARY_SLICE(self, state, inst):
                   end = state.pop()
                   start = state.pop()
                   container = state.pop()
                   temp_res = state.make_temp()
                   res = state.make_temp()
                   slicevar = state.make_temp()
                   state.append(
                       inst, start=start, end=end, container=container, res=res,
                       slicevar=slicevar, temp_res=temp_res
                   )
                   state.push(res)
    1:     elif PYVERSION in ((3, 9), (3, 10), (3, 11)):
    1:         pass
           else:
               raise NotImplementedError(PYVERSION)
       
    1:     if PYVERSION in ((3, 12), ):
               def op_STORE_SLICE(self, state, inst):
                   end = state.pop()
                   start = state.pop()
                   container = state.pop()
                   value = state.pop()
       
                   slicevar = state.make_temp()
                   res = state.make_temp()
                   state.append(
                       inst, start=start, end=end, container=container, value=value,
                       res=res, slicevar=slicevar,
                   )
    1:     elif PYVERSION in ((3, 9), (3, 10), (3, 11)):
    1:         pass
           else:
               raise NotImplementedError(PYVERSION)
       
    1:     def _op_POP_JUMP_IF(self, state, inst):
   32:         pred = state.pop()
   32:         state.append(inst, pred=pred)
       
   32:         target_inst = inst.get_jump_target()
   32:         next_inst = inst.next
               # if the next inst and the jump target are the same location, issue one
               # fork else issue a fork for the next and the target.
   32:         state.fork(pc=next_inst)
   32:         if target_inst != next_inst:
   32:             state.fork(pc=target_inst)
       
    1:     op_POP_JUMP_IF_TRUE = _op_POP_JUMP_IF
    1:     op_POP_JUMP_IF_FALSE = _op_POP_JUMP_IF
       
    1:     if PYVERSION in ((3, 12), ):
               op_POP_JUMP_IF_NONE = _op_POP_JUMP_IF
               op_POP_JUMP_IF_NOT_NONE = _op_POP_JUMP_IF
    1:     elif PYVERSION in ((3, 9), (3, 10), (3, 11)):
    1:         pass
           else:
               raise NotImplementedError(PYVERSION)
       
    1:     def _op_JUMP_IF_OR_POP(self, state, inst):
               pred = state.get_tos()
               state.append(inst, pred=pred)
               state.fork(pc=inst.next, npop=1)
               state.fork(pc=inst.get_jump_target())
       
    1:     op_JUMP_IF_FALSE_OR_POP = _op_JUMP_IF_OR_POP
    1:     op_JUMP_IF_TRUE_OR_POP = _op_JUMP_IF_OR_POP
       
    1:     def op_POP_JUMP_FORWARD_IF_NONE(self, state, inst):
               self._op_POP_JUMP_IF(state, inst)
       
    1:     def op_POP_JUMP_FORWARD_IF_NOT_NONE(self, state, inst):
               self._op_POP_JUMP_IF(state, inst)
       
    1:     def op_POP_JUMP_BACKWARD_IF_NONE(self, state, inst):
               self._op_POP_JUMP_IF(state, inst)
       
    1:     def op_POP_JUMP_BACKWARD_IF_NOT_NONE(self, state, inst):
               self._op_POP_JUMP_IF(state, inst)
       
    1:     def op_POP_JUMP_FORWARD_IF_FALSE(self, state, inst):
   29:         self._op_POP_JUMP_IF(state, inst)
       
    1:     def op_POP_JUMP_FORWARD_IF_TRUE(self, state, inst):
    1:         self._op_POP_JUMP_IF(state, inst)
       
    1:     def op_POP_JUMP_BACKWARD_IF_FALSE(self, state, inst):
               self._op_POP_JUMP_IF(state, inst)
       
    1:     def op_POP_JUMP_BACKWARD_IF_TRUE(self, state, inst):
    2:         self._op_POP_JUMP_IF(state, inst)
       
    1:     def op_JUMP_FORWARD(self, state, inst):
    4:         state.append(inst)
    4:         state.fork(pc=inst.get_jump_target())
       
    1:     def op_JUMP_BACKWARD(self, state, inst):
    7:         state.append(inst)
    7:         state.fork(pc=inst.get_jump_target())
       
    1:     def op_JUMP_ABSOLUTE(self, state, inst):
               state.append(inst)
               state.fork(pc=inst.get_jump_target())
       
    1:     def op_BREAK_LOOP(self, state, inst):
               # NOTE: bytecode removed since py3.8
               end = state.get_top_block('LOOP')['end']
               state.append(inst, end=end)
               state.pop_block()
               state.fork(pc=end)
       
    1:     def op_RETURN_VALUE(self, state, inst):
   36:         state.append(inst, retval=state.pop(), castval=state.make_temp())
   36:         state.terminate()
       
    1:     if PYVERSION in ((3, 12), ):
               def op_RETURN_CONST(self, state, inst):
                   res = state.make_temp("const")
                   state.append(inst, retval=res, castval=state.make_temp())
                   state.terminate()
    1:     elif PYVERSION in ((3, 9), (3, 10), (3, 11)):
    1:         pass
           else:
               raise NotImplementedError(PYVERSION)
       
    1:     def op_YIELD_VALUE(self, state, inst):
               val = state.pop()
               res = state.make_temp()
               state.append(inst, value=val, res=res)
               state.push(res)
       
    1:     if PYVERSION in ((3, 11), (3, 12)):
    1:         def op_RAISE_VARARGS(self, state, inst):
    2:             if inst.arg == 0:
                       exc = None
                       # No re-raising within a try-except block.
                       # But we allow bare reraise.
                       if state.has_active_try():
                           raise UnsupportedError(
                               "The re-raising of an exception is not yet supported.",
                               loc=self.get_debug_loc(inst.lineno),
                           )
    2:             elif inst.arg == 1:
    2:                 exc = state.pop()
                   else:
                       raise ValueError("Multiple argument raise is not supported.")
    2:             state.append(inst, exc=exc)
       
    2:             if state.has_active_try():
                       self._adjust_except_stack(state)
                   else:
    2:                 state.terminate()
       
           elif PYVERSION in ((3, 9), (3, 10)):
               def op_RAISE_VARARGS(self, state, inst):
                   in_exc_block = any([
                       state.get_top_block("EXCEPT") is not None,
                       state.get_top_block("FINALLY") is not None
                   ])
                   if inst.arg == 0:
                       exc = None
                       if in_exc_block:
                           raise UnsupportedError(
                               "The re-raising of an exception is not yet supported.",
                               loc=self.get_debug_loc(inst.lineno),
                           )
                   elif inst.arg == 1:
                       exc = state.pop()
                   else:
                       raise ValueError("Multiple argument raise is not supported.")
                   state.append(inst, exc=exc)
                   state.terminate()
           else:
               raise NotImplementedError(PYVERSION)
       
    1:     def op_BEGIN_FINALLY(self, state, inst):
               temps = []
               for i in range(_EXCEPT_STACK_OFFSET):
                   tmp = state.make_temp()
                   temps.append(tmp)
                   state.push(tmp)
               state.append(inst, temps=temps)
       
    1:     def op_END_FINALLY(self, state, inst):
               blk = state.pop_block()
               state.reset_stack(blk['entry_stack'])
       
    1:     if PYVERSION in ((3, 12), ):
               def op_END_FOR(self, state, inst):
                   state.pop()
                   state.pop()
    1:     elif PYVERSION in ((3, 9), (3, 10), (3, 11)):
    1:         pass
           else:
               raise NotImplementedError(PYVERSION)
       
    1:     def op_POP_FINALLY(self, state, inst):
               # we don't emulate the exact stack behavior
               if inst.arg != 0:
                   msg = ('Unsupported use of a bytecode related to try..finally'
                          ' or a with-context')
                   raise UnsupportedError(msg, loc=self.get_debug_loc(inst.lineno))
       
    1:     def op_CALL_FINALLY(self, state, inst):
               pass
       
    1:     def op_WITH_EXCEPT_START(self, state, inst):
               state.terminate()  # do not support
       
    1:     def op_WITH_CLEANUP_START(self, state, inst):
               # we don't emulate the exact stack behavior
               state.append(inst)
       
    1:     def op_WITH_CLEANUP_FINISH(self, state, inst):
               # we don't emulate the exact stack behavior
               state.append(inst)
       
    1:     def op_SETUP_LOOP(self, state, inst):
               # NOTE: bytecode removed since py3.8
               state.push_block(
                   state.make_block(
                       kind='LOOP',
                       end=inst.get_jump_target(),
                   )
               )
       
    1:     def op_BEFORE_WITH(self, state, inst):
               # Almost the same as py3.10 SETUP_WITH just lacking the finally block.
               cm = state.pop()    # the context-manager
       
               yielded = state.make_temp()
               exitfn = state.make_temp(prefix='setup_with_exitfn')
       
               state.push(exitfn)
               state.push(yielded)
       
               # Gather all exception entries for this WITH. There maybe multiple
               # entries; esp. for nested WITHs.
               bc = state._bytecode
               ehhead = bc.find_exception_entry(inst.next)
               ehrelated = [ehhead]
               for eh in bc.exception_entries:
                   if eh.target == ehhead.target:
                       ehrelated.append(eh)
               end = max(eh.end for eh in ehrelated)
               state.append(inst, contextmanager=cm, exitfn=exitfn, end=end)
       
               state.push_block(
                   state.make_block(
                       kind='WITH',
                       end=end,
                   )
               )
               # Forces a new block
               state.fork(pc=inst.next)
       
    1:     def op_SETUP_WITH(self, state, inst):
               cm = state.pop()    # the context-manager
       
               yielded = state.make_temp()
               exitfn = state.make_temp(prefix='setup_with_exitfn')
               state.append(inst, contextmanager=cm, exitfn=exitfn)
       
               # py39 doesn't have with-finally
               if PYVERSION < (3, 9):
                   state.push_block(
                       state.make_block(
                           kind='WITH_FINALLY',
                           end=inst.get_jump_target(),
                       )
                   )
       
               state.push(exitfn)
               state.push(yielded)
       
               state.push_block(
                   state.make_block(
                       kind='WITH',
                       end=inst.get_jump_target(),
                   )
               )
               # Forces a new block
               state.fork(pc=inst.next)
       
    1:     def _setup_try(self, kind, state, next, end):
               # Forces a new block
               # Fork to the body of the finally
               handler_block = state.make_block(
                   kind=kind,
                   end=None,
                   reset_stack=False,
               )
               # Forces a new block
               # Fork to the body of the finally
               state.fork(
                   pc=next,
                   extra_block=state.make_block(
                       kind='TRY',
                       end=end,
                       reset_stack=False,
                       handler=handler_block,
                   )
               )
       
    1:     def op_PUSH_EXC_INFO(self, state, inst):
               tos = state.pop()
               state.push(state.make_temp("exception"))
               state.push(tos)
       
    1:     def op_SETUP_FINALLY(self, state, inst):
               state.append(inst)
               self._setup_try(
                   'FINALLY', state, next=inst.next, end=inst.get_jump_target(),
               )
       
    1:     if PYVERSION in ((3, 11), (3, 12)):
    1:         def op_POP_EXCEPT(self, state, inst):
                   state.pop()
       
           elif PYVERSION in ((3, 9), (3, 10)):
               def op_POP_EXCEPT(self, state, inst):
                   blk = state.pop_block()
                   if blk['kind'] not in {BlockKind('EXCEPT'), BlockKind('FINALLY')}:
                       raise UnsupportedError(
                           f"POP_EXCEPT got an unexpected block: {blk['kind']}",
                           loc=self.get_debug_loc(inst.lineno),
                       )
                   state.pop()
                   state.pop()
                   state.pop()
                   # Forces a new block
                   state.fork(pc=inst.next)
           else:
               raise NotImplementedError(PYVERSION)
       
    1:     def op_POP_BLOCK(self, state, inst):
               blk = state.pop_block()
               if blk['kind'] == BlockKind('TRY'):
                   state.append(inst, kind='try')
               elif blk['kind'] == BlockKind('WITH'):
                   state.append(inst, kind='with')
               state.fork(pc=inst.next)
       
    1:     def op_BINARY_SUBSCR(self, state, inst):
   20:         index = state.pop()
   20:         target = state.pop()
   20:         res = state.make_temp()
   20:         state.append(inst, index=index, target=target, res=res)
   20:         state.push(res)
       
    1:     def op_STORE_SUBSCR(self, state, inst):
    6:         index = state.pop()
    6:         target = state.pop()
    6:         value = state.pop()
    6:         state.append(inst, target=target, index=index, value=value)
       
    1:     def op_DELETE_SUBSCR(self, state, inst):
               index = state.pop()
               target = state.pop()
               state.append(inst, target=target, index=index)
       
    1:     def op_CALL(self, state, inst):
   62:         narg = inst.arg
  207:         args = list(reversed([state.pop() for _ in range(narg)]))
   62:         callable_or_firstarg = state.pop()
   62:         null_or_callable = state.pop()
   62:         if _is_null_temp_reg(null_or_callable):
   62:             callable = callable_or_firstarg
               else:
                   callable = null_or_callable
                   args = [callable_or_firstarg, *args]
   62:         res = state.make_temp()
       
   62:         kw_names = state.pop_kw_names()
   62:         state.append(inst, func=callable, args=args, kw_names=kw_names, res=res)
   62:         state.push(res)
       
    1:     def op_KW_NAMES(self, state, inst):
    2:         state.set_kw_names(inst.arg)
       
    1:     def op_CALL_FUNCTION(self, state, inst):
               narg = inst.arg
               args = list(reversed([state.pop() for _ in range(narg)]))
               func = state.pop()
       
               res = state.make_temp()
               state.append(inst, func=func, args=args, res=res)
               state.push(res)
       
    1:     def op_CALL_FUNCTION_KW(self, state, inst):
               narg = inst.arg
               names = state.pop()  # tuple of names
               args = list(reversed([state.pop() for _ in range(narg)]))
               func = state.pop()
       
               res = state.make_temp()
               state.append(inst, func=func, args=args, names=names, res=res)
               state.push(res)
       
    1:     def op_CALL_FUNCTION_EX(self, state, inst):
    1:         if inst.arg & 1 and PYVERSION < (3, 10):
                   errmsg = "CALL_FUNCTION_EX with **kwargs not supported"
                   raise UnsupportedError(errmsg)
    1:         if inst.arg & 1:
                   varkwarg = state.pop()
               else:
    1:             varkwarg = None
    1:         vararg = state.pop()
    1:         func = state.pop()
       
    1:         if PYVERSION in ((3, 11), (3, 12)):
    1:             if _is_null_temp_reg(state.peek(1)):
    1:                 state.pop() # pop NULL, it's not used
               elif PYVERSION in ((3, 9), (3, 10)):
                   pass
               else:
                   raise NotImplementedError(PYVERSION)
       
    1:         res = state.make_temp()
    1:         state.append(inst, func=func, vararg=vararg, varkwarg=varkwarg, res=res)
    1:         state.push(res)
       
    1:     def _dup_topx(self, state, inst, count):
               orig = [state.pop() for _ in range(count)]
               orig.reverse()
               # We need to actually create new temporaries if we want the
               # IR optimization pass to work correctly (see issue #580)
               duped = [state.make_temp() for _ in range(count)]
               state.append(inst, orig=orig, duped=duped)
               for val in orig:
                   state.push(val)
               for val in duped:
                   state.push(val)
       
    1:     if PYVERSION in ((3, 12), ):
               def op_CALL_INTRINSIC_1(self, state, inst):
                   # See https://github.com/python/cpython/blob/v3.12.0rc2/Include/
                   # internal/pycore_intrinsics.h#L3-L17C36
                   try:
                       operand = CALL_INTRINSIC_1_Operand(inst.arg)
                   except TypeError:
                       raise NotImplementedError(f"op_CALL_INTRINSIC_1({inst.arg})")
                   if operand == ci1op.INTRINSIC_STOPITERATION_ERROR:
                       state.append(inst, operand=operand)
                       state.terminate()
                       return
                   elif operand == ci1op.UNARY_POSITIVE:
                       val = state.pop()
                       res = state.make_temp()
                       state.append(inst, operand=operand,
                                    value=val, res=res)
                       state.push(res)
                       return
                   elif operand == ci1op.INTRINSIC_LIST_TO_TUPLE:
                       tos = state.pop()
                       res = state.make_temp()
                       state.append(inst, operand=operand,
                                    const_list=tos, res=res)
                       state.push(res)
                       return
                   else:
                       raise NotImplementedError(operand)
       
    1:     elif PYVERSION in ((3, 9), (3, 10), (3, 11)):
    1:         pass
           else:
               raise NotImplementedError(PYVERSION)
       
    1:     def op_DUP_TOPX(self, state, inst):
               count = inst.arg
               assert 1 <= count <= 5, "Invalid DUP_TOPX count"
               self._dup_topx(state, inst, count)
       
    1:     def op_DUP_TOP(self, state, inst):
               self._dup_topx(state, inst, count=1)
       
    1:     def op_DUP_TOP_TWO(self, state, inst):
               self._dup_topx(state, inst, count=2)
       
    1:     def op_COPY(self, state, inst):
               state.push(state.peek(inst.arg))
       
    1:     def op_SWAP(self, state, inst):
               state.swap(inst.arg)
       
    1:     def op_ROT_TWO(self, state, inst):
               first = state.pop()
               second = state.pop()
               state.push(first)
               state.push(second)
       
    1:     def op_ROT_THREE(self, state, inst):
               first = state.pop()
               second = state.pop()
               third = state.pop()
               state.push(first)
               state.push(third)
               state.push(second)
       
    1:     def op_ROT_FOUR(self, state, inst):
               first = state.pop()
               second = state.pop()
               third = state.pop()
               forth = state.pop()
               state.push(first)
               state.push(forth)
               state.push(third)
               state.push(second)
       
    1:     def op_UNPACK_SEQUENCE(self, state, inst):
               count = inst.arg
               iterable = state.pop()
               stores = [state.make_temp() for _ in range(count)]
               tupleobj = state.make_temp()
               state.append(inst, iterable=iterable, stores=stores, tupleobj=tupleobj)
               for st in reversed(stores):
                   state.push(st)
       
    1:     def op_BUILD_TUPLE(self, state, inst):
   16:         count = inst.arg
   64:         items = list(reversed([state.pop() for _ in range(count)]))
   16:         tup = state.make_temp()
   16:         state.append(inst, items=items, res=tup)
   16:         state.push(tup)
       
    1:     def _build_tuple_unpack(self, state, inst):
               # Builds tuple from other tuples on the stack
               tuples = list(reversed([state.pop() for _ in range(inst.arg)]))
               temps = [state.make_temp() for _ in range(len(tuples) - 1)]
       
               # if the unpack is assign-like, e.g. x = (*y,), it needs handling
               # differently.
               is_assign = len(tuples) == 1
               if is_assign:
                   temps = [state.make_temp(),]
       
               state.append(inst, tuples=tuples, temps=temps, is_assign=is_assign)
               # The result is in the last temp var
               state.push(temps[-1])
       
    1:     def op_BUILD_TUPLE_UNPACK_WITH_CALL(self, state, inst):
               # just unpack the input tuple, call inst will be handled afterwards
               self._build_tuple_unpack(state, inst)
       
    1:     def op_BUILD_TUPLE_UNPACK(self, state, inst):
               self._build_tuple_unpack(state, inst)
       
    1:     def op_LIST_TO_TUPLE(self, state, inst):
               # "Pops a list from the stack and pushes a tuple containing the same
               #  values."
               tos = state.pop()
               res = state.make_temp() # new tuple var
               state.append(inst, const_list=tos, res=res)
               state.push(res)
       
    1:     def op_BUILD_CONST_KEY_MAP(self, state, inst):
               keys = state.pop()
               vals = list(reversed([state.pop() for _ in range(inst.arg)]))
               keytmps = [state.make_temp() for _ in range(inst.arg)]
               res = state.make_temp()
               state.append(inst, keys=keys, keytmps=keytmps, values=vals, res=res)
               state.push(res)
       
    1:     def op_BUILD_LIST(self, state, inst):
               count = inst.arg
               items = list(reversed([state.pop() for _ in range(count)]))
               lst = state.make_temp()
               state.append(inst, items=items, res=lst)
               state.push(lst)
       
    1:     def op_LIST_APPEND(self, state, inst):
               value = state.pop()
               index = inst.arg
               target = state.peek(index)
               appendvar = state.make_temp()
               res = state.make_temp()
               state.append(inst, target=target, value=value, appendvar=appendvar,
                            res=res)
       
    1:     def op_LIST_EXTEND(self, state, inst):
               value = state.pop()
               index = inst.arg
               target = state.peek(index)
               extendvar = state.make_temp()
               res = state.make_temp()
               state.append(inst, target=target, value=value, extendvar=extendvar,
                            res=res)
       
    1:     def op_BUILD_MAP(self, state, inst):
               dct = state.make_temp()
               count = inst.arg
               items = []
               # In 3.5+, BUILD_MAP takes <count> pairs from the stack
               for i in range(count):
                   v, k = state.pop(), state.pop()
                   items.append((k, v))
               state.append(inst, items=items[::-1], size=count, res=dct)
               state.push(dct)
       
    1:     def op_MAP_ADD(self, state, inst):
               TOS = state.pop()
               TOS1 = state.pop()
               key, value = (TOS1, TOS)
               index = inst.arg
               target = state.peek(index)
               setitemvar = state.make_temp()
               res = state.make_temp()
               state.append(inst, target=target, key=key, value=value,
                            setitemvar=setitemvar, res=res)
       
    1:     def op_BUILD_SET(self, state, inst):
               count = inst.arg
               # Note: related python bug http://bugs.python.org/issue26020
               items = list(reversed([state.pop() for _ in range(count)]))
               res = state.make_temp()
               state.append(inst, items=items, res=res)
               state.push(res)
       
    1:     def op_SET_UPDATE(self, state, inst):
               value = state.pop()
               index = inst.arg
               target = state.peek(index)
               updatevar = state.make_temp()
               res = state.make_temp()
               state.append(inst, target=target, value=value, updatevar=updatevar,
                            res=res)
       
    1:     def op_DICT_UPDATE(self, state, inst):
               value = state.pop()
               index = inst.arg
               target = state.peek(index)
               updatevar = state.make_temp()
               res = state.make_temp()
               state.append(inst, target=target, value=value, updatevar=updatevar,
                            res=res)
       
    1:     def op_GET_ITER(self, state, inst):
    5:         value = state.pop()
    5:         res = state.make_temp()
    5:         state.append(inst, value=value, res=res)
    5:         state.push(res)
       
    1:     def op_FOR_ITER(self, state, inst):
    5:         iterator = state.get_tos()
    5:         pair = state.make_temp()
    5:         indval = state.make_temp()
    5:         pred = state.make_temp()
   10:         state.append(inst, iterator=iterator, pair=pair, indval=indval,
    5:                      pred=pred)
    5:         state.push(indval)
    5:         end = inst.get_jump_target()
    5:         if PYVERSION in ((3, 12), ):
                   # Changed in version 3.12: Up until 3.11 the iterator was
                   # popped when it was exhausted. Now this is handled using END_FOR
                   # op code.
                   state.fork(pc=end)
    5:         elif PYVERSION in ((3, 9), (3, 10), (3, 11)):
    5:             state.fork(pc=end, npop=2)
               else:
                   raise NotImplementedError(PYVERSION)
    5:         state.fork(pc=inst.next)
       
    1:     def op_GEN_START(self, state, inst):
               """Pops TOS. If TOS was not None, raises an exception. The kind
               operand corresponds to the type of generator or coroutine and
               determines the error message. The legal kinds are 0 for generator,
               1 for coroutine, and 2 for async generator.
       
               New in version 3.10.
               """
               # no-op in Numba
               pass
       
    1:     def op_BINARY_OP(self, state, inst):
   39:         op = dis._nb_ops[inst.arg][1]
   39:         rhs = state.pop()
   39:         lhs = state.pop()
   39:         op_name = ALL_BINOPS_TO_OPERATORS[op].__name__
   39:         res = state.make_temp(prefix=f"binop_{op_name}")
   39:         state.append(inst, op=op, lhs=lhs, rhs=rhs, res=res)
   39:         state.push(res)
       
    1:     def _unaryop(self, state, inst):
    4:         val = state.pop()
    4:         res = state.make_temp()
    4:         state.append(inst, value=val, res=res)
    4:         state.push(res)
       
    1:     op_UNARY_NEGATIVE = _unaryop
    1:     op_UNARY_POSITIVE = _unaryop
    1:     op_UNARY_NOT = _unaryop
    1:     op_UNARY_INVERT = _unaryop
       
    1:     def _binaryop(self, state, inst):
   20:         rhs = state.pop()
   20:         lhs = state.pop()
   20:         res = state.make_temp()
   20:         state.append(inst, lhs=lhs, rhs=rhs, res=res)
   20:         state.push(res)
       
    1:     op_COMPARE_OP = _binaryop
    1:     op_IS_OP = _binaryop
    1:     op_CONTAINS_OP = _binaryop
       
    1:     op_INPLACE_ADD = _binaryop
    1:     op_INPLACE_SUBTRACT = _binaryop
    1:     op_INPLACE_MULTIPLY = _binaryop
    1:     op_INPLACE_DIVIDE = _binaryop
    1:     op_INPLACE_TRUE_DIVIDE = _binaryop
    1:     op_INPLACE_FLOOR_DIVIDE = _binaryop
    1:     op_INPLACE_MODULO = _binaryop
    1:     op_INPLACE_POWER = _binaryop
    1:     op_INPLACE_MATRIX_MULTIPLY = _binaryop
       
    1:     op_INPLACE_LSHIFT = _binaryop
    1:     op_INPLACE_RSHIFT = _binaryop
    1:     op_INPLACE_AND = _binaryop
    1:     op_INPLACE_OR = _binaryop
    1:     op_INPLACE_XOR = _binaryop
       
    1:     op_BINARY_ADD = _binaryop
    1:     op_BINARY_SUBTRACT = _binaryop
    1:     op_BINARY_MULTIPLY = _binaryop
    1:     op_BINARY_DIVIDE = _binaryop
    1:     op_BINARY_TRUE_DIVIDE = _binaryop
    1:     op_BINARY_FLOOR_DIVIDE = _binaryop
    1:     op_BINARY_MODULO = _binaryop
    1:     op_BINARY_POWER = _binaryop
    1:     op_BINARY_MATRIX_MULTIPLY = _binaryop
       
    1:     op_BINARY_LSHIFT = _binaryop
    1:     op_BINARY_RSHIFT = _binaryop
    1:     op_BINARY_AND = _binaryop
    1:     op_BINARY_OR = _binaryop
    1:     op_BINARY_XOR = _binaryop
       
    1:     def op_MAKE_FUNCTION(self, state, inst, MAKE_CLOSURE=False):
               if PYVERSION in ((3, 11), (3, 12)):
                   # https://github.com/python/cpython/commit/2f180ce
                   # name set via co_qualname
                   name = None
               elif PYVERSION in ((3, 9), (3, 10)):
                   name = state.pop()
               else:
                   raise NotImplementedError(PYVERSION)
               code = state.pop()
               closure = annotations = kwdefaults = defaults = None
               if inst.arg & 0x8:
                   closure = state.pop()
               if inst.arg & 0x4:
                   annotations = state.pop()
               if inst.arg & 0x2:
                   kwdefaults = state.pop()
               if inst.arg & 0x1:
                   defaults = state.pop()
               res = state.make_temp()
               state.append(
                   inst,
                   name=name,
                   code=code,
                   closure=closure,
                   annotations=annotations,
                   kwdefaults=kwdefaults,
                   defaults=defaults,
                   res=res,
               )
               state.push(res)
       
    1:     def op_MAKE_CLOSURE(self, state, inst):
               self.op_MAKE_FUNCTION(state, inst, MAKE_CLOSURE=True)
       
    1:     def op_LOAD_CLOSURE(self, state, inst):
               res = state.make_temp()
               state.append(inst, res=res)
               state.push(res)
       
    1:     def op_LOAD_ASSERTION_ERROR(self, state, inst):
               res = state.make_temp("assertion_error")
               state.append(inst, res=res)
               state.push(res)
       
    1:     def op_CHECK_EXC_MATCH(self, state, inst):
               pred = state.make_temp("predicate")
               tos = state.pop()
               tos1 = state.get_tos()
               state.append(inst, pred=pred, tos=tos, tos1=tos1)
               state.push(pred)
       
    1:     def op_JUMP_IF_NOT_EXC_MATCH(self, state, inst):
               # Tests whether the second value on the stack is an exception matching
               # TOS, and jumps if it is not. Pops two values from the stack.
               pred = state.make_temp("predicate")
               tos = state.pop()
               tos1 = state.pop()
               state.append(inst, pred=pred, tos=tos, tos1=tos1)
               state.fork(pc=inst.next)
               state.fork(pc=inst.get_jump_target())
       
    1:     if PYVERSION in ((3, 11), (3, 12)):
    1:         def op_RERAISE(self, state, inst):
                   # This isn't handled, but the state is set up anyway
                   exc = state.pop()
                   if inst.arg != 0:
                       state.pop()     # lasti
                   state.append(inst, exc=exc)
       
                   if state.has_active_try():
                       self._adjust_except_stack(state)
                   else:
                       state.terminate()
       
           elif PYVERSION in ((3, 9), (3, 10)):
               def op_RERAISE(self, state, inst):
                   # This isn't handled, but the state is set up anyway
                   exc = state.pop()
                   state.append(inst, exc=exc)
                   state.terminate()
           else:
               raise NotImplementedError(PYVERSION)
       
           # NOTE: Please see notes in `interpreter.py` surrounding the implementation
           # of LOAD_METHOD and CALL_METHOD.
       
    1:     if PYVERSION in ((3, 12), ):
               # LOAD_METHOD has become a pseudo-instruction in 3.12
               pass
    1:     elif PYVERSION in ((3, 11), ):
    1:         def op_LOAD_METHOD(self, state, inst):
    2:             item = state.pop()
    2:             extra = state.make_null()
    2:             state.push(extra)
    2:             res = state.make_temp()
    2:             state.append(inst, item=item, res=res)
    2:             state.push(res)
           elif PYVERSION in ((3, 9), (3, 10)):
               def op_LOAD_METHOD(self, state, inst):
                   self.op_LOAD_ATTR(state, inst)
           else:
               raise NotImplementedError(PYVERSION)
       
    1:     def op_CALL_METHOD(self, state, inst):
               self.op_CALL_FUNCTION(state, inst)
       
       
    3: @total_ordering
    2: class _State(object):
    1:     """State of the trace
           """
    1:     def __init__(self, bytecode, pc, nstack, blockstack, nullvals=()):
               """
               Parameters
               ----------
               bytecode : numba.bytecode.ByteCode
                   function bytecode
               pc : int
                   program counter
               nstack : int
                   stackdepth at entry
               blockstack : Sequence[Dict]
                   A sequence of dictionary denoting entries on the blockstack.
               """
  123:         self._bytecode = bytecode
  123:         self._pc_initial = pc
  123:         self._pc = pc
  123:         self._nstack_initial = nstack
  123:         self._stack = []
  123:         self._blockstack_initial = tuple(blockstack)
  123:         self._blockstack = list(blockstack)
  123:         self._temp_registers = []
  123:         self._insts = []
  123:         self._outedges = []
  123:         self._terminated = False
  123:         self._phis = {}
  123:         self._outgoing_phis = UniqueDict()
  123:         self._used_regs = set()
  167:         for i in range(nstack):
   44:             if i in nullvals:
                       phi = self.make_temp("null$")
                   else:
   44:                 phi = self.make_temp("phi")
   44:             self._phis[phi] = i
   44:             self.push(phi)
       
    1:     def __repr__(self):
               return "State(pc_initial={} nstack_initial={})".format(
                   self._pc_initial, self._nstack_initial
               )
       
    1:     def get_identity(self):
  882:         return (self._pc_initial, self._nstack_initial)
       
    1:     def __hash__(self):
  836:         return hash(self.get_identity())
       
    1:     def __lt__(self, other):
               return self.get_identity() < other.get_identity()
       
    1:     def __eq__(self, other):
   23:         return self.get_identity() == other.get_identity()
       
    2:     @property
    2:     def pc_initial(self):
               """The starting bytecode offset of this State.
               The PC given to the constructor.
               """
  499:         return self._pc_initial
       
    2:     @property
    2:     def instructions(self):
               """The list of instructions information as a 2-tuple of
               ``(pc : int, register_map : Dict)``
               """
  100:         return self._insts
       
    2:     @property
    2:     def outgoing_edges(self):
               """The list of outgoing edges.
       
               Returns
               -------
               edges : List[State]
               """
  200:         return self._outedges
       
    2:     @property
    2:     def outgoing_phis(self):
               """The dictionary of outgoing phi nodes.
       
               The keys are the name of the PHI nodes.
               The values are the outgoing states.
               """
  100:         return self._outgoing_phis
       
    2:     @property
    2:     def blockstack_initial(self):
               """A copy of the initial state of the blockstack
               """
  100:         return self._blockstack_initial
       
    2:     @property
    2:     def stack_depth(self):
               """The current size of the stack
       
               Returns
               -------
               res : int
               """
               return len(self._stack)
       
    1:     def find_initial_try_block(self):
               """Find the initial *try* block.
               """
  100:         for blk in reversed(self._blockstack_initial):
                   if blk['kind'] == BlockKind('TRY'):
                       return blk
       
    1:     def has_terminated(self):
 1795:         return self._terminated
       
    1:     def get_inst(self):
 5538:         return self._bytecode[self._pc]
       
    1:     def advance_pc(self):
 1709:         inst = self.get_inst()
 1709:         self._pc = inst.next
       
    1:     def make_temp(self, prefix=""):
  711:         if not prefix:
  622:             name = "${prefix}{offset}{opname}.{tempct}".format(
  311:                 prefix=prefix,
  311:                 offset=self._pc,
  311:                 opname=self.get_inst().opname.lower(),
  311:                 tempct=len(self._temp_registers),
                   )
               else:
  800:             name = "${prefix}{offset}.{tempct}".format(
  400:                 prefix=prefix,
  400:                 offset=self._pc,
  400:                 tempct=len(self._temp_registers),
                   )
       
  711:         self._temp_registers.append(name)
  711:         return name
       
    1:     def append(self, inst, **kwargs):
               """Append new inst"""
 1791:         self._insts.append((inst.offset, kwargs))
 1791:         self._used_regs |= set(_flatten_inst_regs(kwargs.values()))
       
    1:     def get_tos(self):
    5:         return self.peek(1)
       
    1:     def peek(self, k):
               """Return the k'th element on the stack
               """
    6:         return self._stack[-k]
       
    1:     def push(self, item):
               """Push to stack"""
  659:         self._stack.append(item)
       
    1:     def pop(self):
               """Pop the stack"""
  609:         return self._stack.pop()
       
    1:     def swap(self, idx):
               """Swap stack[idx] with the tos"""
               s = self._stack
               s[-1], s[-idx] = s[-idx], s[-1]
       
    1:     def push_block(self, synblk):
               """Push a block to blockstack
               """
               assert 'stack_depth' in synblk
               self._blockstack.append(synblk)
       
    1:     def reset_stack(self, depth):
               """Reset the stack to the given stack depth.
               Returning the popped items.
               """
               self._stack, popped = self._stack[:depth], self._stack[depth:]
               return popped
       
    1:     def make_block(self, kind, end, reset_stack=True, handler=None):
               """Make a new block
               """
               d = {
                   'kind': BlockKind(kind),
                   'end': end,
                   'entry_stack': len(self._stack),
               }
               if reset_stack:
                   d['stack_depth'] = len(self._stack)
               else:
                   d['stack_depth'] = None
               d['handler'] = handler
               return d
       
    1:     def pop_block(self):
               """Pop a block and unwind the stack
               """
               b = self._blockstack.pop()
               self.reset_stack(b['stack_depth'])
               return b
       
    1:     def pop_block_and_above(self, blk):
               """Find *blk* in the blockstack and remove it and all blocks above it
               from the stack.
               """
               idx = self._blockstack.index(blk)
               assert 0 <= idx < len(self._blockstack)
               self._blockstack = self._blockstack[:idx]
       
    1:     def get_top_block(self, kind):
               """Find the first block that matches *kind*
               """
 1711:         kind = BlockKind(kind)
 1711:         for bs in reversed(self._blockstack):
                   if bs['kind'] == kind:
                       return bs
       
    1:     def get_top_block_either(self, *kinds):
               """Find the first block that matches *kind*
               """
               kinds = {BlockKind(kind) for kind in kinds}
               for bs in reversed(self._blockstack):
                   if bs['kind'] in kinds:
                       return bs
       
    1:     def has_active_try(self):
               """Returns a boolean indicating if the top-block is a *try* block
               """
 1711:         return self.get_top_block('TRY') is not None
       
    1:     def get_varname(self, inst):
               """Get referenced variable name from the oparg
               """
  197:         return self._bytecode.co_varnames[inst.arg]
       
    1:     def terminate(self):
               """Mark block as terminated
               """
  137:         self._terminated = True
       
    1:     def fork(self, pc, npop=0, npush=0, extra_block=None):
               """Fork the state
               """
               # Handle changes on the stack
   99:         stack = list(self._stack)
   99:         if npop:
    5:             assert 0 <= npop <= len(self._stack)
    5:             nstack = len(self._stack) - npop
    5:             stack = stack[:nstack]
   99:         if npush:
                   assert 0 <= npush
                   for i in range(npush):
                       stack.append(self.make_temp())
               # Handle changes on the blockstack
   99:         blockstack = list(self._blockstack)
   99:         if PYVERSION in ((3, 11), (3, 12)):
                   # pop expired block in destination pc
   99:             while blockstack:
                       top = blockstack[-1]
                       end = top.get('end_offset') or top['end']
                       if pc >= end:
                           blockstack.pop()
                       else:
                           break
               elif PYVERSION in ((3, 9), (3, 10)):
                   pass # intentionally bypass
               else:
                   raise NotImplementedError(PYVERSION)
       
   99:         if extra_block:
                   blockstack.append(extra_block)
  198:         self._outedges.append(Edge(
   99:             pc=pc, stack=tuple(stack), npush=npush,
   99:             blockstack=tuple(blockstack),
               ))
   99:         self.terminate()
       
    1:     def split_new_block(self):
               """Split the state
               """
   14:         self.fork(pc=self._pc)
       
    1:     def get_outgoing_states(self):
               """Get states for each outgoing edges
               """
               # Should only call once
  100:         assert not self._outgoing_phis
  100:         ret = []
  199:         for edge in self._outedges:
  198:             state = State(bytecode=self._bytecode, pc=edge.pc,
   99:                           nstack=len(edge.stack), blockstack=edge.blockstack,
  286:                           nullvals=[i for i, v in enumerate(edge.stack)
   44:                                     if _is_null_temp_reg(v)])
   99:             ret.append(state)
                   # Map outgoing_phis
  143:             for phi, i in state._phis.items():
   44:                 self._outgoing_phis[phi] = edge.stack[i]
  100:         return ret
       
    1:     def get_outgoing_edgepushed(self):
               """
               Returns
               -------
               Dict[int, int]
                   where keys are the PC
                   values are the edge-pushed stack values
               """
       
  498:         return {edge.pc: tuple(edge.stack[-edge.npush:])
  199:                 for edge in self._outedges}
       
       
    2: class StatePy311(_State):
    1:     def __init__(self, *args, **kwargs):
  123:         super().__init__(*args, **kwargs)
  123:         self._kw_names = None
       
    1:     def pop_kw_names(self):
   62:         out = self._kw_names
   62:         self._kw_names = None
   62:         return out
       
    1:     def set_kw_names(self, val):
    2:         assert self._kw_names is None
    2:         self._kw_names = val
       
    1:     def is_in_exception(self):
 1709:         bc = self._bytecode
 1709:         return bc.find_exception_entry(self._pc) is not None
       
    1:     def get_exception(self):
               bc = self._bytecode
               return bc.find_exception_entry(self._pc)
       
    1:     def in_with(self):
 3418:         for ent in self._blockstack_initial:
                   if ent["kind"] == BlockKind("WITH"):
                       return True
       
    1:     def make_null(self):
   63:         return self.make_temp(prefix="null$")
       
       
    1: if PYVERSION >= (3, 11):
    1:     State = StatePy311
       elif PYVERSION < (3, 11):
           State = _State
       else:
           raise NotImplementedError(PYVERSION)
       
       
    1: Edge = namedtuple("Edge", ["pc", "stack", "blockstack", "npush"])
       
       
    2: class AdaptDFA(object):
    1:     """Adapt Flow to the old DFA class expected by Interpreter
           """
    1:     def __init__(self, flow):
   24:         self._flow = flow
       
    2:     @property
    2:     def infos(self):
  299:         return self._flow.block_infos
       
       
    2: AdaptBlockInfo = namedtuple(
    1:     "AdaptBlockInfo",
    1:     ["insts", "outgoing_phis", "blockstack", "active_try_block",
            "outgoing_edgepushed"],
       )
       
       
    1: def adapt_state_infos(state):
  200:     return AdaptBlockInfo(
  100:         insts=tuple(state.instructions),
  100:         outgoing_phis=state.outgoing_phis,
  100:         blockstack=state.blockstack_initial,
  100:         active_try_block=state.find_initial_try_block(),
  100:         outgoing_edgepushed=state.get_outgoing_edgepushed(),
           )
       
       
    1: def _flatten_inst_regs(iterable):
           """Flatten an iterable of registers used in an instruction
           """
 3266:     for item in iterable:
 1397:         if isinstance(item, str):
 1192:             yield item
  205:         elif isinstance(item, (tuple, list)):
  193:             for x in _flatten_inst_regs(item):
  115:                 yield x
       
       
    2: class AdaptCFA(object):
    1:     """Adapt Flow to the old CFA class expected by Interpreter
           """
    1:     def __init__(self, flow):
   24:         self._flow = flow
   24:         self._blocks = {}
  124:         for offset, blockinfo in flow.block_infos.items():
  100:             self._blocks[offset] = AdaptCFBlock(blockinfo, offset)
   24:         backbone = self._flow.cfgraph.backbone()
       
   24:         graph = flow.cfgraph
               # Find backbone
   24:         backbone = graph.backbone()
               # Filter out in loop blocks (Assuming no other cyclic control blocks)
               # This is to unavoid variables defined in loops being considered as
               # function scope.
   24:         inloopblocks = set()
  124:         for b in self.blocks.keys():
  100:             if graph.in_loops(b):
   28:                 inloopblocks.add(b)
   24:         self._backbone = backbone - inloopblocks
       
    2:     @property
    2:     def graph(self):
   24:         return self._flow.cfgraph
       
    2:     @property
    2:     def backbone(self):
  771:         return self._backbone
       
    2:     @property
    2:     def blocks(self):
  172:         return self._blocks
       
    1:     def iterliveblocks(self):
  124:         for b in sorted(self.blocks):
  100:             yield self.blocks[b]
       
    1:     def dump(self):
               self._flow.cfgraph.dump()
       
       
    2: class AdaptCFBlock(object):
    1:     def __init__(self, blockinfo, offset):
  100:         self.offset = offset
 1991:         self.body = tuple(i for i, _ in blockinfo.insts)
