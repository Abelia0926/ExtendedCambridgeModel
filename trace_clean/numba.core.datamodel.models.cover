    1: from functools import partial
    1: from collections import deque
       
    1: from llvmlite import ir
       
    1: from numba.core.datamodel.registry import register_default
    1: from numba.core import types, cgutils
    1: from numba.np import numpy_support
       
       
    2: class DataModel(object):
    1:     """
           DataModel describe how a FE type is represented in the LLVM IR at
           different contexts.
       
           Contexts are:
       
           - value: representation inside function body.  Maybe stored in stack.
           The representation here are flexible.
       
           - data: representation used when storing into containers (e.g. arrays).
       
           - argument: representation used for function argument.  All composite
           types are unflattened into multiple primitive types.
       
           - return: representation used for return argument.
       
           Throughput the compiler pipeline, a LLVM value is usually passed around
           in the "value" representation.  All "as_" prefix function converts from
           "value" representation.  All "from_" prefix function converts to the
           "value"  representation.
       
           """
    1:     def __init__(self, dmm, fe_type):
   80:         self._dmm = dmm
   80:         self._fe_type = fe_type
       
    2:     @property
    2:     def fe_type(self):
               return self._fe_type
       
    1:     def get_value_type(self):
               raise NotImplementedError(self)
       
    1:     def get_data_type(self):
   62:         return self.get_value_type()
       
    1:     def get_argument_type(self):
               """Return a LLVM type or nested tuple of LLVM type
               """
  971:         return self.get_value_type()
       
    1:     def get_return_type(self):
   42:         return self.get_value_type()
       
    1:     def as_data(self, builder, value):
               raise NotImplementedError(self)
       
    1:     def as_argument(self, builder, value):
               """
               Takes one LLVM value
               Return a LLVM value or nested tuple of LLVM value
               """
               raise NotImplementedError(self)
       
    1:     def as_return(self, builder, value):
               raise NotImplementedError(self)
       
    1:     def from_data(self, builder, value):
               raise NotImplementedError(self)
       
    1:     def from_argument(self, builder, value):
               """
               Takes a LLVM value or nested tuple of LLVM value
               Returns one LLVM value
               """
               raise NotImplementedError(self)
       
    1:     def from_return(self, builder, value):
               raise NotImplementedError(self)
       
    1:     def load_from_data_pointer(self, builder, ptr, align=None):
               """
               Load value from a pointer to data.
               This is the default implementation, sufficient for most purposes.
               """
   16:         return self.from_data(builder, builder.load(ptr, align=align))
       
    1:     def traverse(self, builder):
               """
               Traverse contained members.
               Returns a iterable of contained (types, getters).
               Each getter is a one-argument function accepting a LLVM value.
               """
 1961:         return []
       
    1:     def traverse_models(self):
               """
               Recursively list all models involved in this model.
               """
 1053:         return [self._dmm[t] for t in self.traverse_types()]
       
    1:     def traverse_types(self):
               """
               Recursively list all frontend types involved in this model.
               """
  310:         types = [self._fe_type]
  310:         queue = deque([self])
  743:         while len(queue) > 0:
  433:             dm = queue.popleft()
       
  685:             for i_dm in dm.inner_models():
  252:                 if i_dm._fe_type not in types:
  123:                     queue.append(i_dm)
  123:                     types.append(i_dm._fe_type)
       
  310:         return types
       
    1:     def inner_models(self):
               """
               List all *inner* models.
               """
  367:         return []
       
    1:     def get_nrt_meminfo(self, builder, value):
               """
               Returns the MemInfo object or None if it is not tracked.
               It is only defined for types.meminfo_pointer
               """
               return None
       
    1:     def has_nrt_meminfo(self):
 2552:         return False
       
    1:     def contains_nrt_meminfo(self):
               """
               Recursively check all contained types for need for NRT meminfo.
               """
  947:         return any(model.has_nrt_meminfo() for model in self.traverse_models())
       
    1:     def _compared_fields(self):
               return (type(self), self._fe_type)
       
    1:     def __hash__(self):
               return hash(tuple(self._compared_fields()))
       
    1:     def __eq__(self, other):
               if type(self) is type(other):
                   return self._compared_fields() == other._compared_fields()
               else:
                   return False
       
    1:     def __ne__(self, other):
               return not self.__eq__(other)
       
       
    3: @register_default(types.Omitted)
    2: class OmittedArgDataModel(DataModel):
    1:     """
           A data model for omitted arguments.  Only the "argument" representation
           is defined, other representations raise a NotImplementedError.
           """
           # Omitted arguments are using a dummy value type
    1:     def get_value_type(self):
               return ir.LiteralStructType([])
       
           # Omitted arguments don't produce any LLVM function argument.
    1:     def get_argument_type(self):
   63:         return ()
       
    1:     def as_argument(self, builder, val):
   14:         return ()
       
    1:     def from_argument(self, builder, val):
    7:         assert val == (), val
    7:         return None
       
       
    3: @register_default(types.Boolean)
    2: @register_default(types.BooleanLiteral)
    2: class BooleanModel(DataModel):
    1:     _bit_type = ir.IntType(1)
    1:     _byte_type = ir.IntType(8)
       
    1:     def get_value_type(self):
   51:         return self._bit_type
       
    1:     def get_data_type(self):
   34:         return self._byte_type
       
    1:     def get_return_type(self):
   10:         return self.get_data_type()
       
    1:     def get_argument_type(self):
   16:         return self.get_data_type()
       
    1:     def as_data(self, builder, value):
    8:         return builder.zext(value, self.get_data_type())
       
    1:     def as_argument(self, builder, value):
    4:         return self.as_data(builder, value)
       
    1:     def as_return(self, builder, value):
    4:         return self.as_data(builder, value)
       
    1:     def from_data(self, builder, value):
   15:         ty = self.get_value_type()
   15:         resalloca = cgutils.alloca_once(builder, ty)
   15:         cond = builder.icmp_unsigned('==', value, value.type(0))
   30:         with builder.if_else(cond) as (then, otherwise):
   30:             with then:
   15:                 builder.store(ty(0), resalloca)
   30:             with otherwise:
   15:                 builder.store(ty(1), resalloca)
   15:         return builder.load(resalloca)
       
    1:     def from_argument(self, builder, value):
    2:         return self.from_data(builder, value)
       
    1:     def from_return(self, builder, value):
   13:         return self.from_data(builder, value)
       
       
    2: class PrimitiveModel(DataModel):
    1:     """A primitive type can be represented natively in the target in all
           usage contexts.
           """
       
    1:     def __init__(self, dmm, fe_type, be_type):
   60:         super(PrimitiveModel, self).__init__(dmm, fe_type)
   60:         self.be_type = be_type
       
    1:     def get_value_type(self):
 1666:         return self.be_type
       
    1:     def as_data(self, builder, value):
   93:         return value
       
    1:     def as_argument(self, builder, value):
  281:         return value
       
    1:     def as_return(self, builder, value):
   22:         return value
       
    1:     def from_data(self, builder, value):
  199:         return value
       
    1:     def from_argument(self, builder, value):
  132:         return value
       
    1:     def from_return(self, builder, value):
   33:         return value
       
       
    2: class ProxyModel(DataModel):
    1:     """
           Helper class for models which delegate to another model.
           """
       
    1:     def get_value_type(self):
               return self._proxied_model.get_value_type()
       
    1:     def get_data_type(self):
               return self._proxied_model.get_data_type()
       
    1:     def get_return_type(self):
               return self._proxied_model.get_return_type()
       
    1:     def get_argument_type(self):
               return self._proxied_model.get_argument_type()
       
    1:     def as_data(self, builder, value):
               return self._proxied_model.as_data(builder, value)
       
    1:     def as_argument(self, builder, value):
               return self._proxied_model.as_argument(builder, value)
       
    1:     def as_return(self, builder, value):
               return self._proxied_model.as_return(builder, value)
       
    1:     def from_data(self, builder, value):
               return self._proxied_model.from_data(builder, value)
       
    1:     def from_argument(self, builder, value):
               return self._proxied_model.from_argument(builder, value)
       
    1:     def from_return(self, builder, value):
               return self._proxied_model.from_return(builder, value)
       
       
    3: @register_default(types.EnumMember)
    2: @register_default(types.IntEnumMember)
    2: class EnumModel(ProxyModel):
    1:     """
           Enum members are represented exactly like their values.
           """
    1:     def __init__(self, dmm, fe_type):
               super(EnumModel, self).__init__(dmm, fe_type)
               self._proxied_model = dmm.lookup(fe_type.dtype)
       
       
    3: @register_default(types.Opaque)
    2: @register_default(types.PyObject)
    2: @register_default(types.RawPointer)
    2: @register_default(types.NoneType)
    2: @register_default(types.StringLiteral)
    2: @register_default(types.EllipsisType)
    2: @register_default(types.Function)
    2: @register_default(types.Type)
    2: @register_default(types.Object)
    2: @register_default(types.Module)
    2: @register_default(types.Phantom)
    2: @register_default(types.UndefVar)
    2: @register_default(types.ContextManager)
    2: @register_default(types.Dispatcher)
    2: @register_default(types.ObjModeDispatcher)
    2: @register_default(types.ExceptionClass)
    2: @register_default(types.Dummy)
    2: @register_default(types.ExceptionInstance)
    2: @register_default(types.ExternalFunction)
    2: @register_default(types.EnumClass)
    2: @register_default(types.IntEnumClass)
    2: @register_default(types.NumberClass)
    2: @register_default(types.TypeRef)
    2: @register_default(types.NamedTupleClass)
    2: @register_default(types.DType)
    2: @register_default(types.RecursiveCall)
    2: @register_default(types.MakeFunctionLiteral)
    2: @register_default(types.Poison)
    2: class OpaqueModel(PrimitiveModel):
    1:     """
           Passed as opaque pointers
           """
    1:     _ptr_type = ir.IntType(8).as_pointer()
       
    1:     def __init__(self, dmm, fe_type):
   47:         be_type = self._ptr_type
   47:         super(OpaqueModel, self).__init__(dmm, fe_type, be_type)
       
       
    3: @register_default(types.MemInfoPointer)
    2: class MemInfoModel(OpaqueModel):
       
    1:     def inner_models(self):
   19:         return [self._dmm.lookup(self._fe_type.dtype)]
       
    1:     def has_nrt_meminfo(self):
  103:         return True
       
    1:     def get_nrt_meminfo(self, builder, value):
   84:         return value
       
       
    3: @register_default(types.Integer)
    2: @register_default(types.IntegerLiteral)
    2: class IntegerModel(PrimitiveModel):
    1:     def __init__(self, dmm, fe_type):
    9:         be_type = ir.IntType(fe_type.bitwidth)
    9:         super(IntegerModel, self).__init__(dmm, fe_type, be_type)
       
       
    3: @register_default(types.Float)
    2: class FloatModel(PrimitiveModel):
    1:     def __init__(self, dmm, fe_type):
    1:         if fe_type == types.float32:
                   be_type = ir.FloatType()
    1:         elif fe_type == types.float64:
    1:             be_type = ir.DoubleType()
               else:
                   raise NotImplementedError(fe_type)
    1:         super(FloatModel, self).__init__(dmm, fe_type, be_type)
       
       
    3: @register_default(types.CPointer)
    2: class PointerModel(PrimitiveModel):
    1:     def __init__(self, dmm, fe_type):
    3:         self._pointee_model = dmm.lookup(fe_type.dtype)
    3:         self._pointee_be_type = self._pointee_model.get_data_type()
    3:         be_type = self._pointee_be_type.as_pointer()
    3:         super(PointerModel, self).__init__(dmm, fe_type, be_type)
       
       
    3: @register_default(types.EphemeralPointer)
    2: class EphemeralPointerModel(PointerModel):
       
    1:     def get_data_type(self):
               return self._pointee_be_type
       
    1:     def as_data(self, builder, value):
               value = builder.load(value)
               return self._pointee_model.as_data(builder, value)
       
    1:     def from_data(self, builder, value):
               raise NotImplementedError("use load_from_data_pointer() instead")
       
    1:     def load_from_data_pointer(self, builder, ptr, align=None):
               return builder.bitcast(ptr, self.get_value_type())
       
       
    3: @register_default(types.EphemeralArray)
    2: class EphemeralArrayModel(PointerModel):
       
    1:     def __init__(self, dmm, fe_type):
               super(EphemeralArrayModel, self).__init__(dmm, fe_type)
               self._data_type = ir.ArrayType(self._pointee_be_type,
                                              self._fe_type.count)
       
    1:     def get_data_type(self):
               return self._data_type
       
    1:     def as_data(self, builder, value):
               values = [builder.load(cgutils.gep_inbounds(builder, value, i))
                         for i in range(self._fe_type.count)]
               return cgutils.pack_array(builder, values)
       
    1:     def from_data(self, builder, value):
               raise NotImplementedError("use load_from_data_pointer() instead")
       
    1:     def load_from_data_pointer(self, builder, ptr, align=None):
               return builder.bitcast(ptr, self.get_value_type())
       
       
    3: @register_default(types.ExternalFunctionPointer)
    2: class ExternalFuncPointerModel(PrimitiveModel):
    1:     def __init__(self, dmm, fe_type):
               sig = fe_type.sig
               # Since the function is non-Numba, there is no adaptation
               # of arguments and return value, hence get_value_type().
               retty = dmm.lookup(sig.return_type).get_value_type()
               args = [dmm.lookup(t).get_value_type() for t in sig.args]
               be_type = ir.PointerType(ir.FunctionType(retty, args))
               super(ExternalFuncPointerModel, self).__init__(dmm, fe_type, be_type)
       
       
    3: @register_default(types.UniTuple)
    2: @register_default(types.NamedUniTuple)
    2: @register_default(types.StarArgUniTuple)
    2: class UniTupleModel(DataModel):
    1:     def __init__(self, dmm, fe_type):
    2:         super(UniTupleModel, self).__init__(dmm, fe_type)
    2:         self._elem_model = dmm.lookup(fe_type.dtype)
    2:         self._count = len(fe_type)
    4:         self._value_type = ir.ArrayType(self._elem_model.get_value_type(),
    2:                                         self._count)
    4:         self._data_type = ir.ArrayType(self._elem_model.get_data_type(),
    2:                                        self._count)
       
    1:     def get_value_type(self):
   65:         return self._value_type
       
    1:     def get_data_type(self):
   14:         return self._data_type
       
    1:     def get_return_type(self):
               return self.get_value_type()
       
    1:     def get_argument_type(self):
  179:         return (self._elem_model.get_argument_type(),) * self._count
       
    1:     def as_argument(self, builder, value):
   48:         out = []
  136:         for i in range(self._count):
   88:             v = builder.extract_value(value, [i])
   88:             v = self._elem_model.as_argument(builder, v)
   88:             out.append(v)
   48:         return out
       
    1:     def from_argument(self, builder, value):
   24:         out = ir.Constant(self.get_value_type(), ir.Undefined)
   68:         for i, v in enumerate(value):
   44:             v = self._elem_model.from_argument(builder, v)
   44:             out = builder.insert_value(out, v, [i])
   24:         return out
       
    1:     def as_data(self, builder, value):
   12:         out = ir.Constant(self.get_data_type(), ir.Undefined)
   36:         for i in range(self._count):
   24:             val = builder.extract_value(value, [i])
   24:             dval = self._elem_model.as_data(builder, val)
   24:             out = builder.insert_value(out, dval, [i])
   12:         return out
       
    1:     def from_data(self, builder, value):
   24:         out = ir.Constant(self.get_value_type(), ir.Undefined)
   72:         for i in range(self._count):
   48:             val = builder.extract_value(value, [i])
   48:             dval = self._elem_model.from_data(builder, val)
   48:             out = builder.insert_value(out, dval, [i])
   24:         return out
       
    1:     def as_return(self, builder, value):
               return value
       
    1:     def from_return(self, builder, value):
               return value
       
    1:     def traverse(self, builder):
  190:         def getter(i, value):
  352:             return builder.extract_value(value, i)
 1274:         return [(self._fe_type.dtype, partial(getter, i))
  542:                 for i in range(self._count)]
       
    1:     def inner_models(self):
   24:         return [self._elem_model]
       
       
    2: class CompositeModel(DataModel):
    1:     """Any model that is composed of multiple other models should subclass from
           this.
           """
    1:     pass
       
       
    2: class StructModel(CompositeModel):
    1:     _value_type = None
    1:     _data_type = None
       
    1:     def __init__(self, dmm, fe_type, members):
   11:         super(StructModel, self).__init__(dmm, fe_type)
   11:         if members:
   11:             self._fields, self._members = zip(*members)
               else:
                   self._fields = self._members = ()
   90:         self._models = tuple([self._dmm.lookup(t) for t in self._members])
       
    1:     def get_member_fe_type(self, name):
               """
               StructModel-specific: get the Numba type of the field named *name*.
               """
               pos = self.get_field_position(name)
               return self._members[pos]
       
    1:     def get_value_type(self):
 1115:         if self._value_type is None:
  169:             self._value_type = ir.LiteralStructType([t.get_value_type()
   79:                                                     for t in self._models])
 1115:         return self._value_type
       
    1:     def get_data_type(self):
   33:         if self._data_type is None:
   50:             self._data_type = ir.LiteralStructType([t.get_data_type()
   24:                                                     for t in self._models])
   33:         return self._data_type
       
    1:     def get_argument_type(self):
  729:         return tuple([t.get_argument_type() for t in self._models])
       
    1:     def get_return_type(self):
   25:         return self.get_data_type()
       
    1:     def _as(self, methname, builder, value):
   30:         extracted = []
  256:         for i, dm in enumerate(self._models):
  452:             extracted.append(getattr(dm, methname)(builder,
  226:                                                    self.get(builder, value, i)))
   30:         return tuple(extracted)
       
    1:     def _from(self, methname, builder, value):
   28:         struct = ir.Constant(self.get_value_type(), ir.Undefined)
       
  264:         for i, (dm, val) in enumerate(zip(self._models, value)):
  236:             v = getattr(dm, methname)(builder, val)
  236:             struct = self.set(builder, struct, v, i)
       
   28:         return struct
       
    1:     def as_data(self, builder, value):
               """
               Converts the LLVM struct in `value` into a representation suited for
               storing into arrays.
       
               Note
               ----
               Current implementation rarely changes how types are represented for
               "value" and "data".  This is usually a pointless rebuild of the
               immutable LLVM struct value.  Luckily, LLVM optimization removes all
               redundancy.
       
               Sample usecase: Structures nested with pointers to other structures
               that can be serialized into  a flat representation when storing into
               array.
               """
               elems = self._as("as_data", builder, value)
               struct = ir.Constant(self.get_data_type(), ir.Undefined)
               for i, el in enumerate(elems):
                   struct = builder.insert_value(struct, el, [i])
               return struct
       
    1:     def from_data(self, builder, value):
               """
               Convert from "data" representation back into "value" representation.
               Usually invoked when loading from array.
       
               See notes in `as_data()`
               """
               vals = [builder.extract_value(value, [i])
                       for i in range(len(self._members))]
               return self._from("from_data", builder, vals)
       
    1:     def load_from_data_pointer(self, builder, ptr, align=None):
               values = []
               for i, model in enumerate(self._models):
                   elem_ptr = cgutils.gep_inbounds(builder, ptr, 0, i)
                   val = model.load_from_data_pointer(builder, elem_ptr, align)
                   values.append(val)
       
               struct = ir.Constant(self.get_value_type(), ir.Undefined)
               for i, val in enumerate(values):
                   struct = self.set(builder, struct, val, i)
               return struct
       
    1:     def as_argument(self, builder, value):
   22:         return self._as("as_argument", builder, value)
       
    1:     def from_argument(self, builder, value):
   11:         return self._from("from_argument", builder, value)
       
    1:     def as_return(self, builder, value):
    8:         elems = self._as("as_data", builder, value)
    8:         struct = ir.Constant(self.get_data_type(), ir.Undefined)
   80:         for i, el in enumerate(elems):
   72:             struct = builder.insert_value(struct, el, [i])
    8:         return struct
       
    1:     def from_return(self, builder, value):
  369:         vals = [builder.extract_value(value, [i])
  176:                 for i in range(len(self._members))]
   17:         return self._from("from_data", builder, vals)
       
    1:     def get(self, builder, val, pos):
               """Get a field at the given position or the fieldname
       
               Args
               ----
               builder:
                   LLVM IRBuilder
               val:
                   value to be inserted
               pos: int or str
                   field index or field name
       
               Returns
               -------
               Extracted value
               """
 1138:         if isinstance(pos, str):
  912:             pos = self.get_field_position(pos)
 2276:         return builder.extract_value(val, [pos],
 1138:                                      name="extracted." + self._fields[pos])
       
    1:     def set(self, builder, stval, val, pos):
               """Set a field at the given position or the fieldname
       
               Args
               ----
               builder:
                   LLVM IRBuilder
               stval:
                   LLVM struct value
               val:
                   value to be inserted
               pos: int or str
                   field index or field name
       
               Returns
               -------
               A new LLVM struct with the value inserted
               """
  236:         if isinstance(pos, str):
                   pos = self.get_field_position(pos)
  472:         return builder.insert_value(stval, val, [pos],
  236:                                     name="inserted." + self._fields[pos])
       
    1:     def get_field_position(self, field):
 2453:         try:
 2453:             return self._fields.index(field)
               except ValueError:
                   raise KeyError("%s does not have a field named %r"
                                  % (self.__class__.__name__, field))
       
    2:     @property
    2:     def field_count(self):
               return len(self._fields)
       
    1:     def get_type(self, pos):
               """Get the frontend type (numba type) of a field given the position
                or the fieldname
       
               Args
               ----
               pos: int or str
                   field index or field name
               """
  918:         if isinstance(pos, str):
  918:             pos = self.get_field_position(pos)
  918:         return self._members[pos]
       
    1:     def get_model(self, pos):
               """
               Get the datamodel of a field given the position or the fieldname.
       
               Args
               ----
               pos: int or str
                   field index or field name
               """
               return self._models[pos]
       
    1:     def traverse(self, builder):
  158:         def getter(k, value):
  912:             if value.type != self.get_value_type():
                       args = self.get_value_type(), value.type
                       raise TypeError("expecting {0} but got {1}".format(*args))
  912:             return self.get(builder, value, k)
       
 1228:         return [(self.get_type(k), partial(getter, k)) for k in self._fields]
       
    1:     def inner_models(self):
   23:         return self._models
       
       
    3: @register_default(types.Complex)
    2: class ComplexModel(StructModel):
    1:     _element_type = NotImplemented
       
    1:     def __init__(self, dmm, fe_type):
               members = [
                   ('real', fe_type.underlying_float),
                   ('imag', fe_type.underlying_float),
               ]
               super(ComplexModel, self).__init__(dmm, fe_type, members)
       
       
    3: @register_default(types.LiteralList)
    2: @register_default(types.LiteralStrKeyDict)
    2: @register_default(types.Tuple)
    2: @register_default(types.NamedTuple)
    2: @register_default(types.StarArgTuple)
    2: class TupleModel(StructModel):
    1:     def __init__(self, dmm, fe_type):
   38:         members = [('f' + str(i), t) for i, t in enumerate(fe_type)]
    3:         super(TupleModel, self).__init__(dmm, fe_type, members)
       
       
    3: @register_default(types.UnionType)
    2: class UnionModel(StructModel):
    1:     def __init__(self, dmm, fe_type):
               members = [
                   ('tag', types.uintp),
                   # XXX: it should really be a MemInfoPointer(types.voidptr)
                   ('payload', types.Tuple.from_types(fe_type.types)),
               ]
               super(UnionModel, self).__init__(dmm, fe_type, members)
       
       
       
    3: @register_default(types.Pair)
    2: class PairModel(StructModel):
    1:     def __init__(self, dmm, fe_type):
    2:         members = [('first', fe_type.first_type),
    1:                    ('second', fe_type.second_type)]
    1:         super(PairModel, self).__init__(dmm, fe_type, members)
       
       
    3: @register_default(types.ListPayload)
    2: class ListPayloadModel(StructModel):
    1:     def __init__(self, dmm, fe_type):
               # The fields are mutable but the payload is always manipulated
               # by reference.  This scheme allows mutations of an array to
               # be seen by its iterators.
               members = [
                   ('size', types.intp),
                   ('allocated', types.intp),
                   # This member is only used only for reflected lists
                   ('dirty', types.boolean),
                   # Actually an inlined var-sized array
                   ('data', fe_type.container.dtype),
               ]
               super(ListPayloadModel, self).__init__(dmm, fe_type, members)
       
       
    3: @register_default(types.List)
    2: class ListModel(StructModel):
    1:     def __init__(self, dmm, fe_type):
               payload_type = types.ListPayload(fe_type)
               members = [
                   # The meminfo data points to a ListPayload
                   ('meminfo', types.MemInfoPointer(payload_type)),
                   # This member is only used only for reflected lists
                   ('parent', types.pyobject),
               ]
               super(ListModel, self).__init__(dmm, fe_type, members)
       
       
    3: @register_default(types.ListIter)
    2: class ListIterModel(StructModel):
    1:     def __init__(self, dmm, fe_type):
               payload_type = types.ListPayload(fe_type.container)
               members = [
                   # The meminfo data points to a ListPayload (shared with the
                   # original list object)
                   ('meminfo', types.MemInfoPointer(payload_type)),
                   ('index', types.EphemeralPointer(types.intp)),
                   ]
               super(ListIterModel, self).__init__(dmm, fe_type, members)
       
       
    3: @register_default(types.SetEntry)
    2: class SetEntryModel(StructModel):
    1:     def __init__(self, dmm, fe_type):
               dtype = fe_type.set_type.dtype
               members = [
                   # -1 = empty, -2 = deleted
                   ('hash', types.intp),
                   ('key', dtype),
               ]
               super(SetEntryModel, self).__init__(dmm, fe_type, members)
       
       
    3: @register_default(types.SetPayload)
    2: class SetPayloadModel(StructModel):
    1:     def __init__(self, dmm, fe_type):
               entry_type = types.SetEntry(fe_type.container)
               members = [
                   # Number of active + deleted entries
                   ('fill', types.intp),
                   # Number of active entries
                   ('used', types.intp),
                   # Allocated size - 1 (size being a power of 2)
                   ('mask', types.intp),
                   # Search finger
                   ('finger', types.intp),
                   # This member is only used only for reflected sets
                   ('dirty', types.boolean),
                   # Actually an inlined var-sized array
                   ('entries', entry_type),
               ]
               super(SetPayloadModel, self).__init__(dmm, fe_type, members)
       
    3: @register_default(types.Set)
    2: class SetModel(StructModel):
    1:     def __init__(self, dmm, fe_type):
               payload_type = types.SetPayload(fe_type)
               members = [
                   # The meminfo data points to a SetPayload
                   ('meminfo', types.MemInfoPointer(payload_type)),
                   # This member is only used only for reflected sets
                   ('parent', types.pyobject),
               ]
               super(SetModel, self).__init__(dmm, fe_type, members)
       
    3: @register_default(types.SetIter)
    2: class SetIterModel(StructModel):
    1:     def __init__(self, dmm, fe_type):
               payload_type = types.SetPayload(fe_type.container)
               members = [
                   # The meminfo data points to a SetPayload (shared with the
                   # original set object)
                   ('meminfo', types.MemInfoPointer(payload_type)),
                   # The index into the entries table
                   ('index', types.EphemeralPointer(types.intp)),
                   ]
               super(SetIterModel, self).__init__(dmm, fe_type, members)
       
       
    3: @register_default(types.Array)
    2: @register_default(types.Buffer)
    2: @register_default(types.ByteArray)
    2: @register_default(types.Bytes)
    2: @register_default(types.MemoryView)
    2: @register_default(types.PyArray)
    2: class ArrayModel(StructModel):
    1:     def __init__(self, dmm, fe_type):
    3:         ndim = fe_type.ndim
    3:         members = [
    3:             ('meminfo', types.MemInfoPointer(fe_type.dtype)),
    3:             ('parent', types.pyobject),
    3:             ('nitems', types.intp),
    3:             ('itemsize', types.intp),
    3:             ('data', types.CPointer(fe_type.dtype)),
    3:             ('shape', types.UniTuple(types.intp, ndim)),
    3:             ('strides', types.UniTuple(types.intp, ndim)),
       
               ]
    3:         super(ArrayModel, self).__init__(dmm, fe_type, members)
       
       
    3: @register_default(types.ArrayFlags)
    2: class ArrayFlagsModel(StructModel):
    1:     def __init__(self, dmm, fe_type):
               members = [
                   ('parent', fe_type.array_type),
               ]
               super(ArrayFlagsModel, self).__init__(dmm, fe_type, members)
       
       
    3: @register_default(types.NestedArray)
    2: class NestedArrayModel(ArrayModel):
    1:     def __init__(self, dmm, fe_type):
               self._be_type = dmm.lookup(fe_type.dtype).get_data_type()
               super(NestedArrayModel, self).__init__(dmm, fe_type)
       
    1:     def as_storage_type(self):
               """Return the LLVM type representation for the storage of
               the nestedarray.
               """
               ret = ir.ArrayType(self._be_type, self._fe_type.nitems)
               return ret
       
       
    3: @register_default(types.Optional)
    2: class OptionalModel(StructModel):
    1:     def __init__(self, dmm, fe_type):
               members = [
                   ('data', fe_type.type),
                   ('valid', types.boolean),
               ]
               self._value_model = dmm.lookup(fe_type.type)
               super(OptionalModel, self).__init__(dmm, fe_type, members)
       
    1:     def get_return_type(self):
               return self._value_model.get_return_type()
       
    1:     def as_return(self, builder, value):
               raise NotImplementedError
       
    1:     def from_return(self, builder, value):
               return self._value_model.from_return(builder, value)
       
    1:     def traverse(self, builder):
               def get_data(value):
                   valid = get_valid(value)
                   data = self.get(builder, value, "data")
                   return builder.select(valid, data, ir.Constant(data.type, None))
               def get_valid(value):
                   return self.get(builder, value, "valid")
       
               return [(self.get_type("data"), get_data),
                       (self.get_type("valid"), get_valid)]
       
       
    3: @register_default(types.Record)
    2: class RecordModel(CompositeModel):
    1:     def __init__(self, dmm, fe_type):
               super(RecordModel, self).__init__(dmm, fe_type)
               self._models = [self._dmm.lookup(t) for _, t in fe_type.members]
               self._be_type = ir.ArrayType(ir.IntType(8), fe_type.size)
               self._be_ptr_type = self._be_type.as_pointer()
       
    1:     def get_value_type(self):
               """Passed around as reference to underlying data
               """
               return self._be_ptr_type
       
    1:     def get_argument_type(self):
               return self._be_ptr_type
       
    1:     def get_return_type(self):
               return self._be_ptr_type
       
    1:     def get_data_type(self):
               return self._be_type
       
    1:     def as_data(self, builder, value):
               return builder.load(value)
       
    1:     def from_data(self, builder, value):
               raise NotImplementedError("use load_from_data_pointer() instead")
       
    1:     def as_argument(self, builder, value):
               return value
       
    1:     def from_argument(self, builder, value):
               return value
       
    1:     def as_return(self, builder, value):
               return value
       
    1:     def from_return(self, builder, value):
               return value
       
    1:     def load_from_data_pointer(self, builder, ptr, align=None):
               return builder.bitcast(ptr, self.get_value_type())
       
       
    3: @register_default(types.UnicodeCharSeq)
    2: class UnicodeCharSeq(DataModel):
    1:     def __init__(self, dmm, fe_type):
               super(UnicodeCharSeq, self).__init__(dmm, fe_type)
               charty = ir.IntType(numpy_support.sizeof_unicode_char * 8)
               self._be_type = ir.ArrayType(charty, fe_type.count)
       
    1:     def get_value_type(self):
               return self._be_type
       
    1:     def get_data_type(self):
               return self._be_type
       
    1:     def as_data(self, builder, value):
               return value
       
    1:     def from_data(self, builder, value):
               return value
       
    1:     def as_return(self, builder, value):
               return value
       
    1:     def from_return(self, builder, value):
               return value
       
    1:     def as_argument(self, builder, value):
               return value
       
    1:     def from_argument(self, builder, value):
               return value
       
       
    3: @register_default(types.CharSeq)
    2: class CharSeq(DataModel):
    1:     def __init__(self, dmm, fe_type):
               super(CharSeq, self).__init__(dmm, fe_type)
               charty = ir.IntType(8)
               self._be_type = ir.ArrayType(charty, fe_type.count)
       
    1:     def get_value_type(self):
               return self._be_type
       
    1:     def get_data_type(self):
               return self._be_type
       
    1:     def as_data(self, builder, value):
               return value
       
    1:     def from_data(self, builder, value):
               return value
       
    1:     def as_return(self, builder, value):
               return value
       
    1:     def from_return(self, builder, value):
               return value
       
    1:     def as_argument(self, builder, value):
               return value
       
    1:     def from_argument(self, builder, value):
               return value
       
       
    2: class CContiguousFlatIter(StructModel):
    1:     def __init__(self, dmm, fe_type, need_indices):
    1:         assert fe_type.array_type.layout == 'C'
    1:         array_type = fe_type.array_type
    1:         dtype = array_type.dtype
    1:         ndim = array_type.ndim
    2:         members = [('array', array_type),
    1:                    ('stride', types.intp),
    1:                    ('index', types.EphemeralPointer(types.intp)),
                          ]
    1:         if need_indices:
                   # For ndenumerate()
                   members.append(('indices', types.EphemeralArray(types.intp, ndim)))
    1:         super(CContiguousFlatIter, self).__init__(dmm, fe_type, members)
       
       
    2: class FlatIter(StructModel):
    1:     def __init__(self, dmm, fe_type):
               array_type = fe_type.array_type
               dtype = array_type.dtype
               ndim = array_type.ndim
               members = [('array', array_type),
                          ('pointers', types.EphemeralArray(types.CPointer(dtype), ndim)),
                          ('indices', types.EphemeralArray(types.intp, ndim)),
                          ('exhausted', types.EphemeralPointer(types.boolean)),
               ]
               super(FlatIter, self).__init__(dmm, fe_type, members)
       
       
    3: @register_default(types.UniTupleIter)
    2: class UniTupleIter(StructModel):
    1:     def __init__(self, dmm, fe_type):
               members = [('index', types.EphemeralPointer(types.intp)),
                          ('tuple', fe_type.container,)]
               super(UniTupleIter, self).__init__(dmm, fe_type, members)
       
       
    3: @register_default(types.misc.SliceLiteral)
    2: @register_default(types.SliceType)
    2: class SliceModel(StructModel):
    1:     def __init__(self, dmm, fe_type):
    2:         members = [('start', types.intp),
    1:                    ('stop', types.intp),
    1:                    ('step', types.intp),
                          ]
    1:         super(SliceModel, self).__init__(dmm, fe_type, members)
       
       
    3: @register_default(types.NPDatetime)
    2: @register_default(types.NPTimedelta)
    2: class NPDatetimeModel(PrimitiveModel):
    1:     def __init__(self, dmm, fe_type):
               be_type = ir.IntType(64)
               super(NPDatetimeModel, self).__init__(dmm, fe_type, be_type)
       
       
    3: @register_default(types.ArrayIterator)
    2: class ArrayIterator(StructModel):
    1:     def __init__(self, dmm, fe_type):
               # We use an unsigned index to avoid the cost of negative index tests.
               members = [('index', types.EphemeralPointer(types.uintp)),
                          ('array', fe_type.array_type)]
               super(ArrayIterator, self).__init__(dmm, fe_type, members)
       
       
    3: @register_default(types.EnumerateType)
    2: class EnumerateType(StructModel):
    1:     def __init__(self, dmm, fe_type):
               members = [('count', types.EphemeralPointer(types.intp)),
                          ('iter', fe_type.source_type)]
       
               super(EnumerateType, self).__init__(dmm, fe_type, members)
       
       
    3: @register_default(types.ZipType)
    2: class ZipType(StructModel):
    1:     def __init__(self, dmm, fe_type):
               members = [('iter%d' % i, source_type.iterator_type)
                          for i, source_type in enumerate(fe_type.source_types)]
               super(ZipType, self).__init__(dmm, fe_type, members)
       
       
    3: @register_default(types.RangeIteratorType)
    2: class RangeIteratorType(StructModel):
    1:     def __init__(self, dmm, fe_type):
    1:         int_type = fe_type.yield_type
    2:         members = [('iter', types.EphemeralPointer(int_type)),
    1:                    ('stop', int_type),
    1:                    ('step', int_type),
    1:                    ('count', types.EphemeralPointer(int_type))]
    1:         super(RangeIteratorType, self).__init__(dmm, fe_type, members)
       
       
    3: @register_default(types.Generator)
    2: class GeneratorModel(CompositeModel):
    1:     def __init__(self, dmm, fe_type):
               super(GeneratorModel, self).__init__(dmm, fe_type)
               # XXX Fold this in DataPacker?
               self._arg_models = [self._dmm.lookup(t) for t in fe_type.arg_types
                                   if not isinstance(t, types.Omitted)]
               self._state_models = [self._dmm.lookup(t) for t in fe_type.state_types]
       
               self._args_be_type = ir.LiteralStructType(
                   [t.get_data_type() for t in self._arg_models])
               self._state_be_type = ir.LiteralStructType(
                   [t.get_data_type() for t in self._state_models])
               # The whole generator closure
               self._be_type = ir.LiteralStructType(
                   [self._dmm.lookup(types.int32).get_value_type(),
                    self._args_be_type, self._state_be_type])
               self._be_ptr_type = self._be_type.as_pointer()
       
    1:     def get_value_type(self):
               """
               The generator closure is passed around as a reference.
               """
               return self._be_ptr_type
       
    1:     def get_argument_type(self):
               return self._be_ptr_type
       
    1:     def get_return_type(self):
               return self._be_type
       
    1:     def get_data_type(self):
               return self._be_type
       
    1:     def as_argument(self, builder, value):
               return value
       
    1:     def from_argument(self, builder, value):
               return value
       
    1:     def as_return(self, builder, value):
               return self.as_data(builder, value)
       
    1:     def from_return(self, builder, value):
               return self.from_data(builder, value)
       
    1:     def as_data(self, builder, value):
               return builder.load(value)
       
    1:     def from_data(self, builder, value):
               stack = cgutils.alloca_once(builder, value.type)
               builder.store(value, stack)
               return stack
       
       
    3: @register_default(types.ArrayCTypes)
    2: class ArrayCTypesModel(StructModel):
    1:     def __init__(self, dmm, fe_type):
               # ndim = fe_type.ndim
               members = [('data', types.CPointer(fe_type.dtype)),
                          ('meminfo', types.MemInfoPointer(fe_type.dtype))]
               super(ArrayCTypesModel, self).__init__(dmm, fe_type, members)
       
       
    3: @register_default(types.RangeType)
    2: class RangeModel(StructModel):
    1:     def __init__(self, dmm, fe_type):
    1:         int_type = fe_type.iterator_type.yield_type
    2:         members = [('start', int_type),
    1:                    ('stop', int_type),
    1:                    ('step', int_type)]
    1:         super(RangeModel, self).__init__(dmm, fe_type, members)
       
       
       # =============================================================================
       
    3: @register_default(types.NumpyNdIndexType)
    2: class NdIndexModel(StructModel):
    1:     def __init__(self, dmm, fe_type):
               ndim = fe_type.ndim
               members = [('shape', types.UniTuple(types.intp, ndim)),
                          ('indices', types.EphemeralArray(types.intp, ndim)),
                          ('exhausted', types.EphemeralPointer(types.boolean)),
                          ]
               super(NdIndexModel, self).__init__(dmm, fe_type, members)
       
       
    2: @register_default(types.NumpyFlatType)
    2: def handle_numpy_flat_type(dmm, ty):
    1:     if ty.array_type.layout == 'C':
    1:         return CContiguousFlatIter(dmm, ty, need_indices=False)
           else:
               return FlatIter(dmm, ty)
       
    2: @register_default(types.NumpyNdEnumerateType)
    2: def handle_numpy_ndenumerate_type(dmm, ty):
           if ty.array_type.layout == 'C':
               return CContiguousFlatIter(dmm, ty, need_indices=True)
           else:
               return FlatIter(dmm, ty)
       
    2: @register_default(types.BoundFunction)
    2: def handle_bound_function(dmm, ty):
           # The same as the underlying type
    2:     return dmm[ty.this]
       
       
    3: @register_default(types.NumpyNdIterType)
    2: class NdIter(StructModel):
    1:     def __init__(self, dmm, fe_type):
               array_types = fe_type.arrays
               ndim = fe_type.ndim
               shape_len = ndim if fe_type.need_shaped_indexing else 1
               members = [('exhausted', types.EphemeralPointer(types.boolean)),
                          ('arrays', types.Tuple(array_types)),
                          # The iterator's main shape and indices
                          ('shape', types.UniTuple(types.intp, shape_len)),
                          ('indices', types.EphemeralArray(types.intp, shape_len)),
                          ]
               # Indexing state for the various sub-iterators
               # XXX use a tuple instead?
               for i, sub in enumerate(fe_type.indexers):
                   kind, start_dim, end_dim, _ = sub
                   member_name = 'index%d' % i
                   if kind == 'flat':
                       # A single index into the flattened array
                       members.append((member_name, types.EphemeralPointer(types.intp)))
                   elif kind in ('scalar', 'indexed', '0d'):
                       # Nothing required
                       pass
                   else:
                       assert 0
               # Slots holding values of the scalar args
               # XXX use a tuple instead?
               for i, ty in enumerate(fe_type.arrays):
                   if not isinstance(ty, types.Array):
                       member_name = 'scalar%d' % i
                       members.append((member_name, types.EphemeralPointer(ty)))
       
               super(NdIter, self).__init__(dmm, fe_type, members)
       
       
    3: @register_default(types.DeferredType)
    2: class DeferredStructModel(CompositeModel):
    1:     def __init__(self, dmm, fe_type):
               super(DeferredStructModel, self).__init__(dmm, fe_type)
               self.typename = "deferred.{0}".format(id(fe_type))
               self.actual_fe_type = fe_type.get()
       
    1:     def get_value_type(self):
               return ir.global_context.get_identified_type(self.typename + '.value')
       
    1:     def get_data_type(self):
               return ir.global_context.get_identified_type(self.typename + '.data')
       
    1:     def get_argument_type(self):
               return self._actual_model.get_argument_type()
       
    1:     def as_argument(self, builder, value):
               inner = self.get(builder, value)
               return self._actual_model.as_argument(builder, inner)
       
    1:     def from_argument(self, builder, value):
               res = self._actual_model.from_argument(builder, value)
               return self.set(builder, self.make_uninitialized(), res)
       
    1:     def from_data(self, builder, value):
               self._define()
               elem = self.get(builder, value)
               value = self._actual_model.from_data(builder, elem)
               out = self.make_uninitialized()
               return self.set(builder, out, value)
       
    1:     def as_data(self, builder, value):
               self._define()
               elem = self.get(builder, value)
               value = self._actual_model.as_data(builder, elem)
               out = self.make_uninitialized(kind='data')
               return self.set(builder, out, value)
       
    1:     def from_return(self, builder, value):
               return value
       
    1:     def as_return(self, builder, value):
               return value
       
    1:     def get(self, builder, value):
               return builder.extract_value(value, [0])
       
    1:     def set(self, builder, value, content):
               return builder.insert_value(value, content, [0])
       
    1:     def make_uninitialized(self, kind='value'):
               self._define()
               if kind == 'value':
                   ty = self.get_value_type()
               else:
                   ty = self.get_data_type()
               return ir.Constant(ty, ir.Undefined)
       
    1:     def _define(self):
               valty = self.get_value_type()
               self._define_value_type(valty)
               datty = self.get_data_type()
               self._define_data_type(datty)
       
    1:     def _define_value_type(self, value_type):
               if value_type.is_opaque:
                   value_type.set_body(self._actual_model.get_value_type())
       
    1:     def _define_data_type(self, data_type):
               if data_type.is_opaque:
                   data_type.set_body(self._actual_model.get_data_type())
       
    2:     @property
    2:     def _actual_model(self):
               return self._dmm.lookup(self.actual_fe_type)
       
    1:     def traverse(self, builder):
               return [(self.actual_fe_type,
                        lambda value: builder.extract_value(value, [0]))]
       
       
    3: @register_default(types.StructRefPayload)
    2: class StructPayloadModel(StructModel):
    1:     """Model for the payload of a mutable struct
           """
    1:     def __init__(self, dmm, fe_typ):
               members = tuple(fe_typ.field_dict.items())
               super().__init__(dmm, fe_typ, members)
       
       
    2: class StructRefModel(StructModel):
    1:     """Model for a mutable struct.
           A reference to the payload
           """
    1:     def __init__(self, dmm, fe_typ):
               dtype = fe_typ.get_data_type()
               members = [
                   ("meminfo", types.MemInfoPointer(dtype)),
               ]
               super().__init__(dmm, fe_typ, members)
       
