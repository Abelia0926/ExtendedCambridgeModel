    1: """
       Calling conventions for Numba-compiled functions.
       """
       
    1: from collections import namedtuple
    1: from collections.abc import Iterable
    1: import itertools
    1: import hashlib
       
    1: from llvmlite import ir
       
    1: from numba.core import types, cgutils, errors
    1: from numba.core.base import PYOBJECT, GENERIC_POINTER
       
       
    1: TryStatus = namedtuple('TryStatus', ['in_try', 'excinfo'])
       
       
    2: Status = namedtuple("Status",
    1:                     ("code",
                            # If the function returned ok (a value or None)
                            "is_ok",
                            # If the function returned None
                            "is_none",
                            # If the function errored out (== not is_ok)
                            "is_error",
                            # If the generator exited with StopIteration
                            "is_stop_iteration",
                            # If the function errored with an already set exception
                            "is_python_exc",
                            # If the function errored with a user exception
                            "is_user_exc",
                            # The pointer to the exception info structure (for user
                            # exceptions)
                            "excinfoptr",
                            ))
       
    1: int32_t = ir.IntType(32)
    1: int64_t = ir.IntType(64)
    1: errcode_t = int32_t
       
       
    1: def _const_int(code):
    5:     return ir.Constant(errcode_t, code)
       
       
    1: RETCODE_OK = _const_int(0)
    1: RETCODE_EXC = _const_int(-1)
    1: RETCODE_NONE = _const_int(-2)
       # StopIteration
    1: RETCODE_STOPIT = _const_int(-3)
       
    1: FIRST_USEREXC = 1
       
    1: RETCODE_USEREXC = _const_int(FIRST_USEREXC)
       
       
    2: class BaseCallConv(object):
       
    1:     def __init__(self, context):
  387:         self.context = context
       
    1:     def return_optional_value(self, builder, retty, valty, value):
               if valty == types.none:
                   # Value is none
                   self.return_native_none(builder)
       
               elif retty == valty:
                   # Value is an optional, need a runtime switch
                   optval = self.context.make_helper(builder, retty, value=value)
       
                   validbit = cgutils.as_bool_bit(builder, optval.valid)
                   with builder.if_then(validbit):
                       retval = self.context.get_return_value(builder, retty.type,
                                                              optval.data)
                       self.return_value(builder, retval)
       
                   self.return_native_none(builder)
       
               elif not isinstance(valty, types.Optional):
                   # Value is not an optional, need a cast
                   if valty != retty.type:
                       value = self.context.cast(builder, value, fromty=valty,
                                                 toty=retty.type)
                   retval = self.context.get_return_value(builder, retty.type, value)
                   self.return_value(builder, retval)
       
               else:
                   raise NotImplementedError("returning {0} for {1}".format(valty,
                                                                            retty))
       
    1:     def return_native_none(self, builder):
               self._return_errcode_raw(builder, RETCODE_NONE)
       
    1:     def return_exc(self, builder):
               self._return_errcode_raw(builder, RETCODE_EXC)
       
    1:     def return_stop_iteration(self, builder):
               self._return_errcode_raw(builder, RETCODE_STOPIT)
       
    1:     def get_return_type(self, ty):
               """
               Get the actual type of the return argument for Numba type *ty*.
               """
   77:         restype = self.context.data_model_manager[ty].get_return_type()
   77:         return restype.as_pointer()
       
    1:     def init_call_helper(self, builder):
               """
               Initialize and return a call helper object for the given builder.
               """
   24:         ch = self._make_call_helper(builder)
   24:         builder.__call_helper = ch
   24:         return ch
       
    1:     def _get_call_helper(self, builder):
               return builder.__call_helper
       
    1:     def unpack_exception(self, builder, pyapi, status):
               return pyapi.unserialize(status.excinfoptr)
       
    1:     def raise_error(self, builder, pyapi, status):
               """
               Given a non-ok *status*, raise the corresponding Python exception.
               """
   13:         bbend = builder.function.append_basic_block()
       
   26:         with builder.if_then(status.is_user_exc):
                   # Unserialize user exception.
                   # Make sure another error may not interfere.
   13:             pyapi.err_clear()
   13:             exc = self.unpack_exception(builder, pyapi, status)
   39:             with cgutils.if_likely(builder,
   13:                                    cgutils.is_not_null(builder, exc)):
   13:                 pyapi.raise_object(exc)  # steals ref
   13:             builder.branch(bbend)
       
   26:         with builder.if_then(status.is_stop_iteration):
   13:             pyapi.err_set_none("PyExc_StopIteration")
   13:             builder.branch(bbend)
       
   26:         with builder.if_then(status.is_python_exc):
                   # Error already raised => nothing to do
   13:             builder.branch(bbend)
       
   26:         pyapi.err_set_string("PyExc_SystemError",
   13:                              "unknown error when calling native function")
   13:         builder.branch(bbend)
       
   13:         builder.position_at_end(bbend)
       
    1:     def decode_arguments(self, builder, argtypes, func):
               """
               Get the decoded (unpacked) Python arguments with *argtypes*
               from LLVM function *func*.  A tuple of LLVM values is returned.
               """
   24:         raw_args = self.get_arguments(func)
   24:         arginfo = self._get_arg_packer(argtypes)
   24:         return arginfo.from_arguments(builder, raw_args)
       
    1:     def _get_arg_packer(self, argtypes):
               """
               Get an argument packer for the given argument types.
               """
  216:         return self.context.get_arg_packer(argtypes)
       
       
    2: class MinimalCallConv(BaseCallConv):
    1:     """
           A minimal calling convention, suitable for e.g. GPU targets.
           The implemented function signature is:
       
               retcode_t (<Python return type>*, ... <Python arguments>)
       
           The return code will be one of the RETCODE_* constants or a
           function-specific user exception id (>= RETCODE_USEREXC).
       
           Caller is responsible for allocating a slot for the return value
           (passed as a pointer in the first argument).
           """
       
    1:     def _make_call_helper(self, builder):
               return _MinimalCallHelper()
       
    1:     def return_value(self, builder, retval):
               retptr = builder.function.args[0]
               assert retval.type == retptr.type.pointee, \
                   (str(retval.type), str(retptr.type.pointee))
               builder.store(retval, retptr)
               self._return_errcode_raw(builder, RETCODE_OK)
       
    2:     def return_user_exc(self, builder, exc, exc_args=None, loc=None,
    1:                         func_name=None):
               if exc is not None and not issubclass(exc, BaseException):
                   raise TypeError("exc should be None or exception class, got %r"
                                   % (exc,))
               if exc_args is not None and not isinstance(exc_args, tuple):
                   raise TypeError("exc_args should be None or tuple, got %r"
                                   % (exc_args,))
       
               # Build excinfo struct
               if loc is not None:
                   fname = loc._raw_function_name()
                   if fname is None:
                       # could be exec(<string>) or REPL, try func_name
                       fname = func_name
       
                   locinfo = (fname, loc.filename, loc.line)
                   if None in locinfo:
                       locinfo = None
               else:
                   locinfo = None
       
               call_helper = self._get_call_helper(builder)
               exc_id = call_helper._add_exception(exc, exc_args, locinfo)
               self._return_errcode_raw(builder, _const_int(exc_id))
       
    1:     def return_status_propagate(self, builder, status):
               self._return_errcode_raw(builder, status.code)
       
    1:     def _return_errcode_raw(self, builder, code):
               if isinstance(code, int):
                   code = _const_int(code)
               builder.ret(code)
       
    1:     def _get_return_status(self, builder, code):
               """
               Given a return *code*, get a Status instance.
               """
               norm = builder.icmp_signed('==', code, RETCODE_OK)
               none = builder.icmp_signed('==', code, RETCODE_NONE)
               ok = builder.or_(norm, none)
               err = builder.not_(ok)
               exc = builder.icmp_signed('==', code, RETCODE_EXC)
               is_stop_iteration = builder.icmp_signed('==', code, RETCODE_STOPIT)
               is_user_exc = builder.icmp_signed('>=', code, RETCODE_USEREXC)
       
               status = Status(code=code,
                               is_ok=ok,
                               is_error=err,
                               is_python_exc=exc,
                               is_none=none,
                               is_user_exc=is_user_exc,
                               is_stop_iteration=is_stop_iteration,
                               excinfoptr=None)
               return status
       
    1:     def get_function_type(self, restype, argtypes):
               """
               Get the implemented Function type for *restype* and *argtypes*.
               """
               arginfo = self._get_arg_packer(argtypes)
               argtypes = list(arginfo.argument_types)
               resptr = self.get_return_type(restype)
               fnty = ir.FunctionType(errcode_t, [resptr] + argtypes)
               return fnty
       
    1:     def decorate_function(self, fn, args, fe_argtypes, noalias=False):
               """
               Set names and attributes of function arguments.
               """
               assert not noalias
               arginfo = self._get_arg_packer(fe_argtypes)
               arginfo.assign_names(self.get_arguments(fn),
                                    ['arg.' + a for a in args])
               fn.args[0].name = ".ret"
       
    1:     def get_arguments(self, func):
               """
               Get the Python-level arguments of LLVM *func*.
               """
               return func.args[1:]
       
    1:     def call_function(self, builder, callee, resty, argtys, args):
               """
               Call the Numba-compiled *callee*.
               """
               retty = callee.args[0].type.pointee
               retvaltmp = cgutils.alloca_once(builder, retty)
               # initialize return value
               builder.store(cgutils.get_null_value(retty), retvaltmp)
       
               arginfo = self._get_arg_packer(argtys)
               args = arginfo.as_arguments(builder, args)
               realargs = [retvaltmp] + list(args)
               code = builder.call(callee, realargs)
               status = self._get_return_status(builder, code)
               retval = builder.load(retvaltmp)
               out = self.context.get_returned_value(builder, resty, retval)
               return status, out
       
       
    2: class _MinimalCallHelper(object):
    1:     """
           A call helper object for the "minimal" calling convention.
           User exceptions are represented as integer codes and stored in
           a mapping for retrieval from the caller.
           """
       
    1:     def __init__(self):
               self.exceptions = {}
       
    1:     def _add_exception(self, exc, exc_args, locinfo):
               """
               Add a new user exception to this helper. Returns an integer that can be
               used to refer to the added exception in future.
       
               Parameters
               ----------
               exc :
                   exception type
               exc_args : None or tuple
                   exception args
               locinfo : tuple
                   location information
               """
               exc_id = len(self.exceptions) + FIRST_USEREXC
               self.exceptions[exc_id] = exc, exc_args, locinfo
               return exc_id
       
    1:     def get_exception(self, exc_id):
               """
               Get information about a user exception. Returns a tuple of
               (exception type, exception args, location information).
       
               Parameters
               ----------
               id : integer
                   The ID of the exception to look up
               """
               try:
                   return self.exceptions[exc_id]
               except KeyError:
                   msg = "unknown error %d in native function" % exc_id
                   exc = SystemError
                   exc_args = (msg,)
                   locinfo = None
                   return exc, exc_args, locinfo
       
       
       # The structure type constructed by PythonAPI.serialize_uncached()
       # i.e a {i8* pickle_buf, i32 pickle_bufsz, i8* hash_buf, i8* fn, i32 alloc_flag}
    1: PICKLE_BUF_IDX = 0
    1: PICKLE_BUFSZ_IDX = 1
    1: HASH_BUF_IDX = 2
    1: UNWRAP_FUNC_IDX = 3
    1: ALLOC_FLAG_IDX = 4
    2: excinfo_t = ir.LiteralStructType(
    1:     [GENERIC_POINTER, int32_t, GENERIC_POINTER, GENERIC_POINTER, int32_t])
    1: excinfo_ptr_t = ir.PointerType(excinfo_t)
       
       
    2: class CPUCallConv(BaseCallConv):
    1:     """
           The calling convention for CPU targets.
           The implemented function signature is:
       
               retcode_t (<Python return type>*, excinfo **, ... <Python arguments>)
       
           The return code will be one of the RETCODE_* constants.
           If RETCODE_USEREXC, the exception info pointer will be filled with
           a pointer to a constant struct describing the raised exception.
       
           Caller is responsible for allocating slots for the return value
           and the exception info pointer (passed as first and second arguments,
           respectively).
           """
    1:     _status_ids = itertools.count(1)
       
    1:     def _make_call_helper(self, builder):
   24:         return None
       
    1:     def return_value(self, builder, retval):
   34:         retptr = self._get_return_argument(builder.function)
   34:         assert retval.type == retptr.type.pointee, \
                   (str(retval.type), str(retptr.type.pointee))
   34:         builder.store(retval, retptr)
   34:         self._return_errcode_raw(builder, RETCODE_OK)
       
    1:     def build_excinfo_struct(self, exc, exc_args, loc, func_name):
               # Build excinfo struct
   36:         if loc is not None:
    1:             fname = loc._raw_function_name()
    1:             if fname is None:
                       # could be exec(<string>) or REPL, try func_name
                       fname = func_name
       
    1:             locinfo = (fname, loc.filename, loc.line)
    1:             if None in locinfo:
                       locinfo = None
               else:
   35:             locinfo = None
       
   36:         exc = (exc, exc_args, locinfo)
   36:         return exc
       
    2:     def set_static_user_exc(self, builder, exc, exc_args=None, loc=None,
    1:                             func_name=None):
   36:         if exc is not None and not issubclass(exc, BaseException):
                   raise TypeError("exc should be None or exception class, got %r"
                                   % (exc,))
   36:         if exc_args is not None and not isinstance(exc_args, tuple):
                   raise TypeError("exc_args should be None or tuple, got %r"
                                   % (exc_args,))
               # None is indicative of no args, set the exc_args to an empty tuple
               # as PyObject_CallObject(exc, exc_args) requires the second argument to
               # be a tuple (or nullptr, but doing this makes it consistent)
   36:         if exc_args is None:
    1:             exc_args = tuple()
       
               # An exception in Numba is defined as the excinfo_t struct defined
               # above. Some arguments in this struct are not used, depending on
               # which kind of exception is being raised. A static exception uses
               # only the first three members whilst a dynamic exception uses all
               # members:
               #
               #             static exc - last 2 args are NULL and 0
               #             vvv  vvv  vvv
               # excinfo_t: {i8*, i32, i8*, i8*, i32}
               #                       ^^^  ^^^  ^^^
               #                       dynamic exc only - first 2 args are used for
               #                                          static info
               #
               # Comment below details how the struct is used in the case of a dynamic
               # exception. For dynamic exceptions, see
               # CPUCallConv::set_dynamic_user_exc
               #
               # {i8*, ___, ___, ___, ___}
               #   ^  serialized info about the exception (loc, kind, compile time
               #                                           args)
               #
               # {___, i32, ___, ___, ___}
               #        ^  len(serialized_exception)
               #
               # {___, ___, i8*, ___, ___}
               #             ^  Store a list of native values in a dynamic exception.
               #                Or a hash(serialized_exception) in a static exc.
               #
               # {___, ___, ___, i8*, ___}
               #                  ^  "NULL" as this member is not used in a static exc
               #
               # {___, ___, ___, ___, i32}
               #                       ^  Number of dynamic args in the exception. For
               #                          static exceptions, this value is "0"
       
   36:         pyapi = self.context.get_python_api(builder)
   36:         exc = self.build_excinfo_struct(exc, exc_args, loc, func_name)
   36:         struct_gv = pyapi.serialize_object(exc)
   36:         excptr = self._get_excinfo_argument(builder.function)
   36:         store = builder.store(struct_gv, excptr)
   36:         md = builder.module.add_metadata([ir.IntType(1)(1)])
   36:         store.set_metadata("numba_exception_output", md)
       
    2:     def return_user_exc(self, builder, exc, exc_args=None, loc=None,
    1:                         func_name=None):
   36:         try_info = getattr(builder, '_in_try_block', False)
   72:         self.set_static_user_exc(builder, exc, exc_args=exc_args,
   36:                                  loc=loc, func_name=func_name)
   36:         self.check_try_status(builder)
   36:         if try_info:
                   # This is a hack for old-style impl.
                   # We will branch directly to the exception handler.
                   builder.branch(try_info['target'])
               else:
                   # Return from the current function
   36:             self._return_errcode_raw(builder, RETCODE_USEREXC)
       
    1:     def unpack_dynamic_exception(self, builder, pyapi, status):
   13:         excinfo_ptr = status.excinfoptr
       
               # load the serialized exception buffer from the module and create
               # a python bytes object
   26:         picklebuf = builder.extract_value(
   13:             builder.load(excinfo_ptr), PICKLE_BUF_IDX)
   26:         picklebuf_sz = builder.extract_value(
   13:             builder.load(excinfo_ptr), PICKLE_BUFSZ_IDX)
   26:         static_exc_bytes = pyapi.bytes_from_string_and_size(
   13:             picklebuf, builder.sext(picklebuf_sz, pyapi.py_ssize_t))
       
               # Load dynamic args (i8*) and the unwrap function
   26:         dyn_args = builder.extract_value(
   13:             builder.load(excinfo_ptr), HASH_BUF_IDX)
   26:         func_ptr = builder.extract_value(
   13:             builder.load(excinfo_ptr), UNWRAP_FUNC_IDX)
       
               # Convert the unwrap function to a function pointer and call it.
               # Function returns a python tuple with dynamic arguments converted to
               # CPython objects
   13:         fnty = ir.FunctionType(PYOBJECT, [GENERIC_POINTER])
   13:         fn = builder.bitcast(func_ptr, fnty.as_pointer())
   13:         py_tuple = builder.call(fn, [dyn_args])
       
               # We check at this stage if creating the Python tuple was successful
               # or not. Note the exception is raised by calling PyErr_SetString
               # directly as the current function is the CPython wrapper.
   13:         failed = cgutils.is_null(builder, py_tuple)
   26:         with cgutils.if_unlikely(builder, failed):
   13:             msg = ('Error creating Python tuple from runtime exception '
                          'arguments')
   13:             pyapi.err_set_string("PyExc_RuntimeError", msg)
                   # Return NULL to indicate an error was raised
   13:             fnty = builder.function.function_type
   13:             if not isinstance(fnty.return_type, ir.VoidType):
                       # in some ufuncs, the return type is void
   13:                 builder.ret(cgutils.get_null_value(fnty.return_type))
                   else:
                       builder.ret_void()
       
               # merge static and dynamic variables
   13:         excinfo = pyapi.build_dynamic_excinfo_struct(static_exc_bytes, py_tuple)
       
               # At this point, one can free the entire excinfo_ptr struct
   13:         if self.context.enable_nrt:
                   # One can safely emit a free instruction as it is only executed
                   # if its in a dynamic exception branch
   26:             self.context.nrt.free(
   13:                 builder, builder.bitcast(excinfo_ptr, pyapi.voidptr))
   13:         return excinfo
       
    1:     def unpack_exception(self, builder, pyapi, status):
               # Emit code that checks the alloc flag (last excinfo member)
               # if alloc_flag > 0:
               #     (dynamic) unpack the exception to retrieve runtime information
               #               and merge with static info
               # else:
               #     (static) unserialize the exception using pythonapi.unserialize
       
   13:         excinfo_ptr = status.excinfoptr
   26:         alloc_flag = builder.extract_value(builder.load(excinfo_ptr),
   13:                                            ALLOC_FLAG_IDX)
   13:         gt = builder.icmp_signed('>', alloc_flag, int32_t(0))
   26:         with builder.if_else(gt) as (then, otherwise):
   26:             with then:
   13:                 dyn_exc = self.unpack_dynamic_exception(builder, pyapi, status)
   13:                 bb_then = builder.block
   26:             with otherwise:
   13:                 static_exc = pyapi.unserialize(excinfo_ptr)
   13:                 bb_else = builder.block
   13:         phi = builder.phi(static_exc.type)
   13:         phi.add_incoming(dyn_exc, bb_then)
   13:         phi.add_incoming(static_exc, bb_else)
   13:         return phi
       
    1:     def emit_unwrap_dynamic_exception_fn(self, module, st_type, nb_types):
               # Create a function that converts a list of runtime arguments to a tuple
               # of PyObjects. i.e.:
               #
               #   @njit('void(float, int64)')
               #   def func(a, b):
               #       raise ValueError(a, 123, b)
               #
               # The last three arguments of the exception info structure will hold:
               #   {___, ___, i8*, i8*, i32}
               #               ^ A ptr to a {f32, i64} struct
               #                    ^ function ptr that converts i8* -> {f32, i64}* ->
               #                      python tuple
               #                          ^ Number of dynamic arguments = 2
               #
       
               _hash = hashlib.sha1(str(st_type).encode()).hexdigest()
               name = f'__excinfo_unwrap_args{_hash}'
               if name in module.globals:
                   return module.globals.get(name)
       
               fnty = ir.FunctionType(GENERIC_POINTER, [GENERIC_POINTER])
               fn = ir.Function(module, fnty, name)
       
               # prevent the function from being inlined
               fn.attributes.add('nounwind')
               fn.attributes.add('noinline')
       
               bb_entry = fn.append_basic_block('')
               builder = ir.IRBuilder(bb_entry)
               pyapi = self.context.get_python_api(builder)
       
               # i8* -> {native arg1 type, native arg2 type, ...}
               st_type_ptr = st_type.as_pointer()
               st_ptr = builder.bitcast(fn.args[0], st_type_ptr)
               # compile time values are stored as None
               nb_types = [typ for typ in nb_types if typ is not None]
       
               # convert native values into CPython objects
               objs = []
               env_manager = self.context.get_env_manager(builder,
                                                          return_pyobject=True)
               for i, typ in enumerate(nb_types):
                   val = builder.extract_value(builder.load(st_ptr), i)
                   obj = pyapi.from_native_value(typ, val, env_manager=env_manager)
       
                   # If object cannot be boxed, raise an exception
                   if obj == cgutils.get_null_value(obj.type):
                       # When not supported, abort compilation
                       msg = f'Cannot convert native {typ} to a Python object.'
                       raise errors.TypingError(msg)
       
                   objs.append(obj)
       
               # at this point, a pointer to the list of runtime values can be freed
               self.context.nrt.free(builder,
                                     self._get_return_argument(builder.function))
       
               # Create a tuple of CPython objects
               tup = pyapi.tuple_pack(objs)
               builder.ret(tup)
       
               return fn
       
    1:     def emit_wrap_args_insts(self, builder, pyapi, struct_type, exc_args):
               """
               Create an anonymous struct containing the given LLVM *values*.
               """
               st_size = pyapi.py_ssize_t(self.context.get_abi_sizeof(struct_type))
       
               st_ptr = builder.bitcast(
                   self.context.nrt.allocate(builder, st_size),
                   struct_type.as_pointer())
       
               # skip compile-time values
               exc_args = [arg for arg in exc_args if isinstance(arg, ir.Value)]
       
               zero = int32_t(0)
               for idx, arg in enumerate(exc_args):
                   builder.store(arg, builder.gep(st_ptr, [zero, int32_t(idx)]))
       
               return st_ptr
       
    2:     def set_dynamic_user_exc(self, builder, exc, exc_args, nb_types, loc=None,
    1:                              func_name=None):
               """
               Compute the required bits to emit an exception with dynamic (runtime)
               values
               """
               if not issubclass(exc, BaseException):
                   raise TypeError("exc should be an exception class, got %r"
                                   % (exc,))
               if exc_args is not None and not isinstance(exc_args, tuple):
                   raise TypeError("exc_args should be None or tuple, got %r"
                                   % (exc_args,))
       
               # An exception in Numba is defined as the excinfo_t struct defined
               # above. Some arguments in this struct are not used, depending on
               # which kind of exception is being raised. A static exception uses
               # only the first three members whilst a dynamic exception uses all
               # members:
               #
               #             static exc - last 2 args are NULL and 0
               #             vvv  vvv  vvv
               # excinfo_t: {i8*, i32, i8*, i8*, i32}
               #                       ^^^  ^^^  ^^^
               #                       dynamic exc only - first 2 args are used for
               #                                          static info
               #
               # Comment below details how the struct is used in the case of a dynamic
               # exception. For static exception, see CPUCallConv::set_static_user_exc
               #
               # {i8*, ___, ___, ___, ___}
               #   ^  serialized info about the exception (loc, kind, compile time
               #                                           args)
               #
               # {___, i32, ___, ___, ___}
               #        ^  len(serialized_exception)
               #
               # {___, ___, i8*, ___, ___}
               #             ^  Store a list of native values in a dynamic exception.
               #                Or a hash(serialized_exception) in a static exc.
               #
               # {___, ___, ___, i8*, ___}
               #                  ^  Pointer to function that convert native values
               #                     into PyObject*. NULL in the case of a static
               #                     exception
               #
               # {___, ___, ___, ___, i32}
               #                       ^  Number of dynamic args in the exception.
               #                          Default is "0"
               #
               # The following code will:
               # 1) Serialize compile time information and store them in the first
               #    two args {i8*, i32, ___, ___, ___} of excinfo_t
               # 2) Emit the required code for converting native values to CPython
               #    objects. Those objects are stored in the last three args
               #    {___, ___, i8*, i8*, i32} of excinfo_t
               # 3) Allocate a new excinfo_t struct
               # 4) Fill excinfo_t struct and copy the pointer to the excinfo** arg
       
               # serialize comp. time args
               pyapi = self.context.get_python_api(builder)
               exc = self.build_excinfo_struct(exc, exc_args, loc, func_name)
               excinfo_pp = self._get_excinfo_argument(builder.function)
               struct_gv = builder.load(pyapi.serialize_object(exc))
       
               # Create the struct for runtime args and emit a function to convert it
               # into a Python tuple
               struct_type = ir.LiteralStructType([arg.type for arg in exc_args if
                                                   isinstance(arg, ir.Value)])
               st_ptr = self.emit_wrap_args_insts(builder, pyapi, struct_type,
                                                  exc_args)
               unwrap_fn = self.emit_unwrap_dynamic_exception_fn(
                   builder.module, struct_type, nb_types)
       
               # allocate the excinfo struct
               exc_size = pyapi.py_ssize_t(self.context.get_abi_sizeof(excinfo_t))
               excinfo_p = builder.bitcast(
                   self.context.nrt.allocate(builder, exc_size),
                   excinfo_ptr_t)
       
               # fill the args
               zero = int32_t(0)
               exc_fields = (builder.extract_value(struct_gv, PICKLE_BUF_IDX),
                             builder.extract_value(struct_gv, PICKLE_BUFSZ_IDX),
                             builder.bitcast(st_ptr, GENERIC_POINTER),
                             builder.bitcast(unwrap_fn, GENERIC_POINTER),
                             int32_t(len(struct_type)))
               for idx, arg in enumerate(exc_fields):
                   builder.store(arg, builder.gep(excinfo_p, [zero, int32_t(idx)]))
               builder.store(excinfo_p, excinfo_pp)
       
    1:     def return_dynamic_user_exc(self, builder, exc, exc_args, nb_types,
    1:                                 loc=None, func_name=None):
               """
               Same as ::return_user_exc but for dynamic exceptions
               """
               self.set_dynamic_user_exc(builder, exc, exc_args, nb_types,
                                         loc=loc, func_name=func_name)
               self._return_errcode_raw(builder, RETCODE_USEREXC)
       
    1:     def _get_try_state(self, builder):
   75:         try:
   75:             return builder.__eh_try_state
   16:         except AttributeError:
   32:             ptr = cgutils.alloca_once(
   16:                 builder, cgutils.intp_t, name='try_state', zfill=True,
                   )
   16:             builder.__eh_try_state = ptr
   16:             return ptr
       
    1:     def check_try_status(self, builder):
   75:         try_state_ptr = self._get_try_state(builder)
   75:         try_depth = builder.load(try_state_ptr)
               # try_depth > 0
   75:         in_try = builder.icmp_unsigned('>', try_depth, try_depth.type(0))
       
   75:         excinfoptr = self._get_excinfo_argument(builder.function)
   75:         excinfo = builder.load(excinfoptr)
       
   75:         return TryStatus(in_try=in_try, excinfo=excinfo)
       
    1:     def set_try_status(self, builder):
               try_state_ptr = self._get_try_state(builder)
               # Increment try depth
               old = builder.load(try_state_ptr)
               new = builder.add(old, old.type(1))
               builder.store(new, try_state_ptr)
       
    1:     def unset_try_status(self, builder):
               try_state_ptr = self._get_try_state(builder)
               # Decrement try depth
               old = builder.load(try_state_ptr)
               new = builder.sub(old, old.type(1))
               builder.store(new, try_state_ptr)
       
               # Needs to reset the exception state so that the exception handler
               # will run normally.
               excinfoptr = self._get_excinfo_argument(builder.function)
               null = cgutils.get_null_value(excinfoptr.type.pointee)
               builder.store(null, excinfoptr)
       
    1:     def return_status_propagate(self, builder, status):
   39:         trystatus = self.check_try_status(builder)
   39:         excptr = self._get_excinfo_argument(builder.function)
   39:         builder.store(status.excinfoptr, excptr)
   78:         with builder.if_then(builder.not_(trystatus.in_try)):
   39:             self._return_errcode_raw(builder, status.code)
       
    1:     def _return_errcode_raw(self, builder, code):
  109:         builder.ret(code)
       
    1:     def _get_return_status(self, builder, code, excinfoptr):
               """
               Given a return *code* and *excinfoptr*, get a Status instance.
               """
   52:         norm = builder.icmp_signed('==', code, RETCODE_OK)
   52:         none = builder.icmp_signed('==', code, RETCODE_NONE)
   52:         exc = builder.icmp_signed('==', code, RETCODE_EXC)
   52:         is_stop_iteration = builder.icmp_signed('==', code, RETCODE_STOPIT)
   52:         ok = builder.or_(norm, none)
   52:         err = builder.not_(ok)
   52:         is_user_exc = builder.icmp_signed('>=', code, RETCODE_USEREXC)
  104:         excinfoptr = builder.select(is_user_exc, excinfoptr,
   52:                                     ir.Constant(excinfo_ptr_t, ir.Undefined))
       
  104:         status = Status(code=code,
   52:                         is_ok=ok,
   52:                         is_error=err,
   52:                         is_python_exc=exc,
   52:                         is_none=none,
   52:                         is_user_exc=is_user_exc,
   52:                         is_stop_iteration=is_stop_iteration,
   52:                         excinfoptr=excinfoptr)
   52:         return status
       
    1:     def get_function_type(self, restype, argtypes):
               """
               Get the implemented Function type for *restype* and *argtypes*.
               """
   77:         arginfo = self._get_arg_packer(argtypes)
   77:         argtypes = list(arginfo.argument_types)
   77:         resptr = self.get_return_type(restype)
  154:         fnty = ir.FunctionType(errcode_t,
  154:                                [resptr, ir.PointerType(excinfo_ptr_t)]
   77:                                + argtypes)
   77:         return fnty
       
    1:     def decorate_function(self, fn, args, fe_argtypes, noalias=False):
               """
               Set names of function arguments, and add useful attributes to them.
               """
   63:         arginfo = self._get_arg_packer(fe_argtypes)
  126:         arginfo.assign_names(self.get_arguments(fn),
  274:                              ['arg.' + a for a in args])
   63:         retarg = self._get_return_argument(fn)
   63:         retarg.name = "retptr"
   63:         retarg.add_attribute("nocapture")
   63:         retarg.add_attribute("noalias")
   63:         excarg = self._get_excinfo_argument(fn)
   63:         excarg.name = "excinfo"
   63:         excarg.add_attribute("nocapture")
   63:         excarg.add_attribute("noalias")
       
   63:         if noalias:
                   args = self.get_arguments(fn)
                   for a in args:
                       if isinstance(a.type, ir.PointerType):
                           a.add_attribute("nocapture")
                           a.add_attribute("noalias")
       
               # Add metadata to mark functions that may need NRT
               # thus disabling aggressive refct pruning in removerefctpass.py
   63:         def type_may_always_need_nrt(ty):
                   # Returns True if it's a non-Array type that is contains MemInfo
  148:             if not isinstance(ty, types.Array):
  133:                 dmm = self.context.data_model_manager
  133:                 if dmm[ty].contains_nrt_meminfo():
                           return True
  148:             return False
       
  126:         args_may_always_need_nrt = any(
   63:             map(type_may_always_need_nrt, fe_argtypes)
               )
       
   63:         if args_may_always_need_nrt:
                   nmd = fn.module.add_named_metadata(
                       'numba_args_may_always_need_nrt',
                   )
                   nmd.add(fn.module.add_metadata([fn]))
       
    1:     def get_arguments(self, func):
               """
               Get the Python-level arguments of LLVM *func*.
               """
   87:         return func.args[2:]
       
    1:     def _get_return_argument(self, func):
  149:         return func.args[0]
       
    1:     def _get_excinfo_argument(self, func):
  213:         return func.args[1]
       
    1:     def call_function(self, builder, callee, resty, argtys, args,
    1:                       attrs=None):
               """
               Call the Numba-compiled *callee*.
               Parameters:
               -----------
               attrs: LLVM style string or iterable of individual attributes, default
                      is None which specifies no attributes. Examples:
                      LLVM style string: "noinline fast"
                      Equivalent iterable: ("noinline", "fast")
               """
               # XXX better fix for callees that are not function values
               #     (pointers to function; thus have no `.args` attribute)
   52:         retty = self._get_return_argument(callee.function_type).pointee
       
   52:         retvaltmp = cgutils.alloca_once(builder, retty)
               # initialize return value to zeros
   52:         builder.store(cgutils.get_null_value(retty), retvaltmp)
       
  104:         excinfoptr = cgutils.alloca_once(builder, ir.PointerType(excinfo_t),
   52:                                          name="excinfo")
       
   52:         arginfo = self._get_arg_packer(argtys)
   52:         args = list(arginfo.as_arguments(builder, args))
   52:         realargs = [retvaltmp, excinfoptr] + args
               # deal with attrs, it's fine to specify a load in a string like
               # "noinline fast" as per LLVM or equally as an iterable of individual
               # attributes.
   52:         if attrs is None:
   39:             _attrs = ()
   13:         elif isinstance(attrs, Iterable) and not isinstance(attrs, str):
   13:             _attrs = tuple(attrs)
               else:
                   raise TypeError("attrs must be an iterable of strings or None")
   52:         code = builder.call(callee, realargs, attrs=_attrs)
  104:         status = self._get_return_status(builder, code,
   52:                                          builder.load(excinfoptr))
   52:         retval = builder.load(retvaltmp)
   52:         out = self.context.get_returned_value(builder, resty, retval)
   52:         return status, out
       
       
    2: class ErrorModel(object):
       
    1:     def __init__(self, call_conv):
   35:         self.call_conv = call_conv
       
    1:     def fp_zero_division(self, builder, exc_args=None, loc=None):
   10:         if self.raise_on_fp_zero_division:
   20:             self.call_conv.return_user_exc(builder, ZeroDivisionError, exc_args,
   10:                                            loc)
   10:             return True
               else:
                   return False
       
       
    2: class PythonErrorModel(ErrorModel):
    1:     """
           The Python error model.  Any invalid FP input raises an exception.
           """
    1:     raise_on_fp_zero_division = True
       
       
    2: class NumpyErrorModel(ErrorModel):
    1:     """
           In the Numpy error model, floating-point errors don't raise an
           exception.  The FPU exception state is inspected by Numpy at the
           end of a ufunc's execution and a warning is raised if appropriate.
       
           Note there's no easy way to set the FPU exception state from LLVM.
           Instructions known to set an FP exception can be optimized away:
               https://llvm.org/bugs/show_bug.cgi?id=6050
               http://lists.llvm.org/pipermail/llvm-dev/2014-September/076918.html
               http://lists.llvm.org/pipermail/llvm-commits/Week-of-Mon-20140929/237997.html
           """
    1:     raise_on_fp_zero_division = False
       
       
    1: error_models = {
    1:     'python': PythonErrorModel,
    1:     'numpy': NumpyErrorModel,
       }
       
       
    1: def create_error_model(model_name, context):
           """
           Create an error model instance for the given target context.
           """
   35:     return error_models[model_name](context.call_conv)
