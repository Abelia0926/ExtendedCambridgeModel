    1: """
       Define typing templates
       """
       
    1: from abc import ABC, abstractmethod
    1: import functools
    1: import sys
    1: import inspect
    1: import os.path
    1: from collections import namedtuple
    1: from collections.abc import Sequence
    1: from types import MethodType, FunctionType, MappingProxyType
       
    1: import numba
    1: from numba.core import types, utils, targetconfig
    1: from numba.core.errors import (
           TypingError,
           InternalError,
           InternalTargetMismatchError,
       )
    1: from numba.core.cpu_options import InlineOptions
       
       # info store for inliner callback functions e.g. cost model
    2: _inline_info = namedtuple('inline_info',
    1:                           'func_ir typemap calltypes signature')
       
       
    2: class Signature(object):
    1:     """
           The signature of a function call or operation, i.e. its argument types
           and return type.
           """
       
           # XXX Perhaps the signature should be a BoundArguments, instead
           # of separate args and pysig...
    1:     __slots__ = '_return_type', '_args', '_recvr', '_pysig'
       
    1:     def __init__(self, return_type, args, recvr, pysig=None):
  995:         if isinstance(args, list):
                   args = tuple(args)
  995:         self._return_type = return_type
  995:         self._args = args
  995:         self._recvr = recvr
  995:         self._pysig = pysig
       
    2:     @property
    2:     def return_type(self):
 1890:         return self._return_type
       
    2:     @property
    2:     def args(self):
 6723:         return self._args
       
    2:     @property
    2:     def recvr(self):
  554:         return self._recvr
       
    2:     @property
    2:     def pysig(self):
  210:         return self._pysig
       
    1:     def replace(self, **kwargs):
               """Copy and replace the given attributes provided as keyword arguments.
               Returns an updated copy.
               """
  172:         curstate = dict(return_type=self.return_type,
   86:                         args=self.args,
   86:                         recvr=self.recvr,
   86:                         pysig=self.pysig)
   86:         curstate.update(kwargs)
   86:         return Signature(**curstate)
       
    1:     def __getstate__(self):
               """
               Needed because of __slots__.
               """
               return self._return_type, self._args, self._recvr, self._pysig
       
    1:     def __setstate__(self, state):
               """
               Needed because of __slots__.
               """
    3:         self._return_type, self._args, self._recvr, self._pysig = state
       
    1:     def __hash__(self):
   38:         return hash((self.args, self.return_type))
       
    1:     def __eq__(self, other):
   10:         if isinstance(other, Signature):
   40:             return (self.args == other.args and
   10:                     self.return_type == other.return_type and
   10:                     self.recvr == other.recvr and
   10:                     self.pysig == other.pysig)
       
    1:     def __ne__(self, other):
               return not (self == other)
       
    1:     def __repr__(self):
  165:         return "%s -> %s" % (self.args, self.return_type)
       
    2:     @property
    2:     def is_method(self):
               """
               Whether this signature represents a bound method or a regular
               function.
               """
               return self.recvr is not None
       
    1:     def as_method(self):
               """
               Convert this signature to a bound method signature.
               """
    4:         if self.recvr is not None:
                   return self
    8:         sig = signature(self.return_type, *self.args[1:],
    4:                         recvr=self.args[0])
       
               # Adjust the python signature
    4:         params = list(self.pysig.parameters.values())[1:]
    8:         sig = sig.replace(
    8:             pysig=utils.pySignature(
    4:                 parameters=params,
    4:                 return_annotation=self.pysig.return_annotation,
                   ),
               )
    4:         return sig
       
    1:     def as_function(self):
               """
               Convert this signature to a regular function signature.
               """
  338:         if self.recvr is None:
  336:             return self
    2:         sig = signature(self.return_type, *((self.recvr,) + self.args))
    2:         return sig
       
    1:     def as_type(self):
               """
               Convert this signature to a first-class function type.
               """
               return types.FunctionType(self)
       
    1:     def __unliteral__(self):
               return signature(types.unliteral(self.return_type),
                                *map(types.unliteral, self.args))
       
    1:     def dump(self, tab=''):
               c = self.as_type()._code
               print(f'{tab}DUMP {type(self).__name__} [type code: {c}]')
               print(f'{tab}  Argument types:')
               for a in self.args:
                   a.dump(tab=tab + '  | ')
               print(f'{tab}  Return type:')
               self.return_type.dump(tab=tab + '  | ')
               print(f'{tab}END DUMP')
       
    1:     def is_precise(self):
               for atype in self.args:
                   if not atype.is_precise():
                       return False
               return self.return_type.is_precise()
       
       
    1: def make_concrete_template(name, key, signatures):
   62:     baseclasses = (ConcreteTemplate,)
   62:     gvars = dict(key=key, cases=list(signatures))
   62:     return type(name, baseclasses, gvars)
       
       
    1: def make_callable_template(key, typer, recvr=None):
           """
           Create a callable template with the given key and typer function.
           """
    6:     def generic(self):
    6:         return typer
       
    6:     name = "%s_CallableTemplate" % (key,)
    6:     bases = (CallableTemplate,)
    6:     class_dict = dict(key=key, generic=generic, recvr=recvr)
    6:     return type(name, bases, class_dict)
       
       
    1: def signature(return_type, *args, **kws):
  909:     recvr = kws.pop('recvr', None)
  909:     assert not kws
  909:     return Signature(return_type, args, recvr=recvr)
       
       
    1: def fold_arguments(pysig, args, kws, normal_handler, default_handler,
                          stararg_handler):
           """
           Given the signature *pysig*, explicit *args* and *kws*, resolve
           omitted arguments and keyword arguments. A tuple of positional
           arguments is returned.
           Various handlers allow to process arguments:
           - normal_handler(index, param, value) is called for normal arguments
           - default_handler(index, param, default) is called for omitted arguments
           - stararg_handler(index, param, values) is called for a "*args" argument
           """
   93:     if isinstance(kws, Sequence):
               # Normalize dict kws
               kws = dict(kws)
       
           # deal with kwonly args
   93:     params = pysig.parameters
   93:     kwonly = []
  287:     for name, p in params.items():
  194:         if p.kind == p.KEYWORD_ONLY:
                   kwonly.append(name)
       
   93:     if kwonly:
               bind_args = args[:-len(kwonly)]
           else:
   93:         bind_args = args
   93:     bind_kws = kws.copy()
   93:     if kwonly:
               for idx, n in enumerate(kwonly):
                   bind_kws[n] = args[len(kwonly) + idx]
       
           # now bind
   93:     ba = pysig.bind(*bind_args, **bind_kws)
  287:     for i, param in enumerate(pysig.parameters.values()):
  194:         name = param.name
  194:         default = param.default
  194:         if param.kind == param.VAR_POSITIONAL:
                   # stararg may be omitted, in which case its "default" value
                   # is simply the empty tuple
                   if name in ba.arguments:
                       argval = ba.arguments[name]
                       # NOTE: avoid wrapping the tuple type for stararg in another
                       #       tuple.
                       if (len(argval) == 1 and
                               isinstance(argval[0], (types.StarArgTuple,
                                                      types.StarArgUniTuple))):
                           argval = tuple(argval[0])
                   else:
                       argval = ()
                   out = stararg_handler(i, param, argval)
       
                   ba.arguments[name] = out
  194:         elif name in ba.arguments:
                   # Non-stararg, present
  145:             ba.arguments[name] = normal_handler(i, param, ba.arguments[name])
               else:
                   # Non-stararg, omitted
   49:             assert default is not param.empty
   49:             ba.arguments[name] = default_handler(i, param, default)
           # Collect args in the right order
  667:     args = tuple(ba.arguments[param.name]
  287:                  for param in pysig.parameters.values())
   93:     return args
       
       
    2: class FunctionTemplate(ABC):
           # Set to true to disable unsafe cast.
           # subclass overide-able
    1:     unsafe_casting = True
           # Set to true to require exact match without casting.
           # subclass overide-able
    1:     exact_match_required = False
           # Set to true to prefer literal arguments.
           # Useful for definitions that specialize on literal but also support
           # non-literals.
           # subclass overide-able
    1:     prefer_literal = False
           # metadata
    1:     metadata = {}
       
    1:     def __init__(self, context):
 2681:         self.context = context
       
    1:     def _select(self, cases, args, kws):
  274:         options = {
  274:             'unsafe_casting': self.unsafe_casting,
  274:             'exact_match_required': self.exact_match_required,
               }
  548:         selected = self.context.resolve_overload(self.key, cases, args, kws,
  274:                                                  **options)
  274:         return selected
       
    1:     def get_impl_key(self, sig):
               """
               Return the key for looking up the implementation for the given
               signature on the target context.
               """
               # Lookup the key on the class, to avoid binding it with `self`.
  395:         key = type(self).key
               # On Python 2, we must also take care about unbound methods
  395:         if isinstance(key, MethodType):
                   assert key.im_self is None
                   key = key.im_func
  395:         return key
       
    2:     @classmethod
    2:     def get_source_code_info(cls, impl):
               """
               Gets the source information about function impl.
               Returns:
       
               code - str: source code as a string
               firstlineno - int: the first line number of the function impl
               path - str: the path to file containing impl
       
               if any of the above are not available something generic is returned
               """
               try:
                   code, firstlineno = inspect.getsourcelines(impl)
               except OSError: # missing source, probably a string
                   code = "None available (built from string?)"
                   firstlineno = 0
               path = inspect.getsourcefile(impl)
               if path is None:
                   path = "<unknown> (built from string?)"
               return code, firstlineno, path
       
    2:     @abstractmethod
    2:     def get_template_info(self):
               """
               Returns a dictionary with information specific to the template that will
               govern how error messages are displayed to users. The dictionary must
               be of the form:
               info = {
                   'kind': "unknown", # str: The kind of template, e.g. "Overload"
                   'name': "unknown", # str: The name of the source function
                   'sig': "unknown",  # str: The signature(s) of the source function
                   'filename': "unknown", # str: The filename of the source function
                   'lines': ("start", "end"), # tuple(int, int): The start and
                                                end line of the source function.
                   'docstring': "unknown" # str: The docstring of the source function
               }
               """
               pass
       
    1:     def __str__(self):
               info = self.get_template_info()
               srcinfo = f"{info['filename']}:{info['lines'][0]}"
               return f"<{self.__class__.__name__} {srcinfo}>"
       
    1:     __repr__ = __str__
       
       
    2: class AbstractTemplate(FunctionTemplate):
    1:     """
           Defines method ``generic(self, args, kws)`` which compute a possible
           signature base on input types.  The signature does not have to match the
           input types. It is compared against the input types afterwards.
           """
       
    1:     def apply(self, args, kws):
 2237:         generic = getattr(self, "generic")
 2237:         sig = generic(args, kws)
               # Enforce that *generic()* must return None or Signature
 2237:         if sig is not None:
  278:             if not isinstance(sig, Signature):
                       raise AssertionError(
                           "generic() must return a Signature or None. "
                           "{} returned {}".format(generic, type(sig)),
                       )
       
               # Unpack optional type if no matching signature
 7950:         if not sig and any(isinstance(x, types.Optional) for x in args):
                   def unpack_opt(x):
                       if isinstance(x, types.Optional):
                           return x.type
                       else:
                           return x
       
                   args = list(map(unpack_opt, args))
                   assert not kws  # Not supported yet
                   sig = generic(args, kws)
       
 2237:         return sig
       
    1:     def get_template_info(self):
               impl = getattr(self, "generic")
               basepath = os.path.dirname(os.path.dirname(numba.__file__))
       
               code, firstlineno, path = self.get_source_code_info(impl)
               sig = str(utils.pysignature(impl))
               info = {
                   'kind': "overload",
                   'name': getattr(impl, '__qualname__', impl.__name__),
                   'sig': sig,
                   'filename': utils.safe_relpath(path, start=basepath),
                   'lines': (firstlineno, firstlineno + len(code) - 1),
                   'docstring': impl.__doc__
               }
               return info
       
       
    2: class CallableTemplate(FunctionTemplate):
    1:     """
           Base class for a template defining a ``generic(self)`` method
           returning a callable to be called with the actual ``*args`` and
           ``**kwargs`` representing the call signature.  The callable has
           to return a return type, a full signature, or None.  The signature
           does not have to match the input types. It is compared against the
           input types afterwards.
           """
    1:     recvr = None
       
    1:     def apply(self, args, kws):
    6:         generic = getattr(self, "generic")
    6:         typer = generic()
    6:         match_sig = inspect.signature(typer)
    6:         try:
    6:             match_sig.bind(*args, **kws)
               except TypeError as e:
                   # bind failed, raise, if there's a
                   # ValueError then there's likely unrecoverable
                   # problems
                   raise TypingError(str(e)) from e
       
    6:         sig = typer(*args, **kws)
       
               # Unpack optional type if no matching signature
    6:         if sig is None:
                   if any(isinstance(x, types.Optional) for x in args):
                       def unpack_opt(x):
                           if isinstance(x, types.Optional):
                               return x.type
                           else:
                               return x
       
                       args = list(map(unpack_opt, args))
                       sig = typer(*args, **kws)
                   if sig is None:
                       return
       
               # Get the pysig
    6:         try:
    6:             pysig = typer.pysig
    4:         except AttributeError:
    4:             pysig = utils.pysignature(typer)
       
               # Fold any keyword arguments
    6:         bound = pysig.bind(*args, **kws)
    6:         if bound.kwargs:
                   raise TypingError("unsupported call signature")
    6:         if not isinstance(sig, Signature):
                   # If not a signature, `sig` is assumed to be the return type
    6:             if not isinstance(sig, types.Type):
                       raise TypeError("invalid return type for callable template: "
                                       "got %r" % (sig,))
    6:             sig = signature(sig, *bound.args)
    6:         if self.recvr is not None:
                   sig = sig.replace(recvr=self.recvr)
               # Hack any omitted parameters out of the typer's pysig,
               # as lowering expects an exact match between formal signature
               # and actual args.
    6:         if len(bound.args) < len(pysig.parameters):
                   parameters = list(pysig.parameters.values())[:len(bound.args)]
                   pysig = pysig.replace(parameters=parameters)
    6:         sig = sig.replace(pysig=pysig)
    6:         cases = [sig]
    6:         return self._select(cases, bound.args, bound.kwargs)
       
    1:     def get_template_info(self):
               impl = getattr(self, "generic")
               basepath = os.path.dirname(os.path.dirname(numba.__file__))
               code, firstlineno, path = self.get_source_code_info(impl)
               sig = str(utils.pysignature(impl))
               info = {
                   'kind': "overload",
                   'name': getattr(self.key, '__name__',
                                   getattr(impl, '__qualname__', impl.__name__),),
                   'sig': sig,
                   'filename': utils.safe_relpath(path, start=basepath),
                   'lines': (firstlineno, firstlineno + len(code) - 1),
                   'docstring': impl.__doc__
               }
               return info
       
       
    2: class ConcreteTemplate(FunctionTemplate):
    1:     """
           Defines attributes "cases" as a list of signature to match against the
           given input types.
           """
       
    1:     def apply(self, args, kws):
  268:         cases = getattr(self, 'cases')
  268:         return self._select(cases, args, kws)
       
    1:     def get_template_info(self):
               import operator
               name = getattr(self.key, '__name__', "unknown")
               op_func = getattr(operator, name, None)
       
               kind = "Type restricted function"
               if op_func is not None:
                   if self.key is op_func:
                       kind = "operator overload"
               info = {
                   'kind': kind,
                   'name': name,
                   'sig': "unknown",
                   'filename': "unknown",
                   'lines': ("unknown", "unknown"),
                   'docstring': "unknown"
               }
               return info
       
       
    2: class _EmptyImplementationEntry(InternalError):
    1:     def __init__(self, reason):
               super(_EmptyImplementationEntry, self).__init__(
                   "_EmptyImplementationEntry({!r})".format(reason),
               )
       
       
    2: class _OverloadFunctionTemplate(AbstractTemplate):
    1:     """
           A base class of templates for overload functions.
           """
       
    1:     def _validate_sigs(self, typing_func, impl_func):
               # check that the impl func and the typing func have the same signature!
   11:         typing_sig = utils.pysignature(typing_func)
   11:         impl_sig = utils.pysignature(impl_func)
               # the typing signature is considered golden and must be adhered to by
               # the implementation...
               # Things that are valid:
               # 1. args match exactly
               # 2. kwargs match exactly in name and default value
               # 3. Use of *args in the same location by the same name in both typing
               #    and implementation signature
               # 4. Use of *args in the implementation signature to consume any number
               #    of arguments in the typing signature.
               # Things that are invalid:
               # 5. Use of *args in the typing signature that is not replicated
               #    in the implementing signature
               # 6. Use of **kwargs
       
   11:         def get_args_kwargs(sig):
   22:             kws = []
   22:             args = []
   22:             pos_arg = None
   68:             for x in sig.parameters.values():
   46:                 if x.default == utils.pyParameter.empty:
   26:                     args.append(x)
   26:                     if x.kind == utils.pyParameter.VAR_POSITIONAL:
                               pos_arg = x
   26:                     elif x.kind == utils.pyParameter.VAR_KEYWORD:
                               msg = ("The use of VAR_KEYWORD (e.g. **kwargs) is "
                                      "unsupported. (offending argument name is '%s')")
                               raise InternalError(msg % x)
                       else:
   20:                     kws.append(x)
   22:             return args, kws, pos_arg
       
   11:         ty_args, ty_kws, ty_pos = get_args_kwargs(typing_sig)
   11:         im_args, im_kws, im_pos = get_args_kwargs(impl_sig)
       
   11:         sig_fmt = ("Typing signature:         %s\n"
                          "Implementation signature: %s")
   11:         sig_str = sig_fmt % (typing_sig, impl_sig)
       
   11:         err_prefix = "Typing and implementation arguments differ in "
       
   11:         a = ty_args
   11:         b = im_args
   11:         if ty_pos:
                   if not im_pos:
                       # case 5. described above
                       msg = ("VAR_POSITIONAL (e.g. *args) argument kind (offending "
                              "argument name is '%s') found in the typing function "
                              "signature, but is not in the implementing function "
                              "signature.\n%s") % (ty_pos, sig_str)
                       raise InternalError(msg)
               else:
   11:             if im_pos:
                       # no *args in typing but there's a *args in the implementation
                       # this is case 4. described above
                       b = im_args[:im_args.index(im_pos)]
                       try:
                           a = ty_args[:ty_args.index(b[-1]) + 1]
                       except ValueError:
                           # there's no b[-1] arg name in the ty_args, something is
                           # very wrong, we can't work out a diff (*args consumes
                           # unknown quantity of args) so just report first error
                           specialized = "argument names.\n%s\nFirst difference: '%s'"
                           msg = err_prefix + specialized % (sig_str, b[-1])
                           raise InternalError(msg)
       
   11:         def gen_diff(typing, implementing):
                   diff = set(typing) ^ set(implementing)
                   return "Difference: %s" % diff
       
   11:         if a != b:
                   specialized = "argument names.\n%s\n%s" % (sig_str, gen_diff(a, b))
                   raise InternalError(err_prefix + specialized)
       
               # ensure kwargs are the same
   32:         ty = [x.name for x in ty_kws]
   32:         im = [x.name for x in im_kws]
   11:         if ty != im:
                   specialized = "keyword argument names.\n%s\n%s"
                   msg = err_prefix + specialized % (sig_str, gen_diff(ty_kws, im_kws))
                   raise InternalError(msg)
   53:         same = [x.default for x in ty_kws] == [x.default for x in im_kws]
   11:         if not same:
                   specialized = "keyword argument default values.\n%s\n%s"
                   msg = err_prefix + specialized % (sig_str, gen_diff(ty_kws, im_kws))
                   raise InternalError(msg)
       
    1:     def generic(self, args, kws):
               """
               Type the overloaded function by compiling the appropriate
               implementation for the given args.
               """
 1044:         from numba.core.typed_passes import PreLowerStripPhis
       
 1044:         disp, new_args = self._get_impl(args, kws)
 1044:         if disp is None:
  998:             return
               # Compile and type it for the given types
   46:         disp_type = types.Dispatcher(disp)
               # Store the compiled overload for use in the lowering phase if there's
               # no inlining required (else functions are being compiled which will
               # never be used as they are inlined)
   46:         if not self._inline.is_never_inline:
                   # need to run the compiler front end up to type inference to compute
                   # a signature
                   from numba.core import typed_passes, compiler
                   from numba.core.inline_closurecall import InlineWorker
                   fcomp = disp._compiler
                   flags = compiler.Flags()
       
                   # Updating these causes problems?!
                   #fcomp.targetdescr.options.parse_as_flags(flags,
                   #                                         fcomp.targetoptions)
                   #flags = fcomp._customize_flags(flags)
       
                   # spoof a compiler pipline like the one that will be in use
                   tyctx = fcomp.targetdescr.typing_context
                   tgctx = fcomp.targetdescr.target_context
                   compiler_inst = fcomp.pipeline_class(tyctx, tgctx, None, None, None,
                                                        flags, None, )
                   inline_worker = InlineWorker(tyctx, tgctx, fcomp.locals,
                                                compiler_inst, flags, None,)
       
                   # If the inlinee contains something to trigger literal arg dispatch
                   # then the pipeline call will unconditionally fail due to a raised
                   # ForceLiteralArg exception. Therefore `resolve` is run first, as
                   # type resolution must occur at some point, this will hit any
                   # `literally` calls and because it's going via the dispatcher will
                   # handle them correctly i.e. ForceLiteralArg propagates. This having
                   # the desired effect of ensuring the pipeline call is only made in
                   # situations that will succeed. For context see #5887.
                   resolve = disp_type.dispatcher.get_call_template
                   template, pysig, folded_args, kws = resolve(new_args, kws)
                   ir = inline_worker.run_untyped_passes(
                       disp_type.dispatcher.py_func, enable_ssa=True
                   )
       
                   (
                       typemap,
                       return_type,
                       calltypes,
                       _
                   ) = typed_passes.type_inference_stage(
                       self.context, tgctx, ir, folded_args, None)
                   ir = PreLowerStripPhis()._strip_phi_nodes(ir)
                   ir._definitions = numba.core.ir_utils.build_definitions(ir.blocks)
       
                   sig = Signature(return_type, folded_args, None)
                   # this stores a load of info for the cost model function if supplied
                   # it by default is None
                   self._inline_overloads[sig.args] = {'folded_args': folded_args}
                   # this stores the compiled overloads, if there's no compiled
                   # overload available i.e. function is always inlined, the key still
                   # needs to exist for type resolution
       
                   # NOTE: If lowering is failing on a `_EmptyImplementationEntry`,
                   #       the inliner has failed to inline this entry correctly.
                   impl_init = _EmptyImplementationEntry('always inlined')
                   self._compiled_overloads[sig.args] = impl_init
                   if not self._inline.is_always_inline:
                       # this branch is here because a user has supplied a function to
                       # determine whether to inline or not. As a result both compiled
                       # function and inliner info needed, delaying the computation of
                       # this leads to an internal state mess at present. TODO: Fix!
                       sig = disp_type.get_call_type(self.context, new_args, kws)
                       self._compiled_overloads[sig.args] = disp_type.get_overload(sig)
                       # store the inliner information, it's used later in the cost
                       # model function call
                   iinfo = _inline_info(ir, typemap, calltypes, sig)
                   self._inline_overloads[sig.args] = {'folded_args': folded_args,
                                                       'iinfo': iinfo}
               else:
   46:             sig = disp_type.get_call_type(self.context, new_args, kws)
   46:             if sig is None: # can't resolve for this target
                       return None
   46:             self._compiled_overloads[sig.args] = disp_type.get_overload(sig)
   46:         return sig
       
    1:     def _get_impl(self, args, kws):
               """Get implementation given the argument types.
       
               Returning a Dispatcher object.  The Dispatcher object is cached
               internally in `self._impl_cache`.
               """
 1044:         flags = targetconfig.ConfigStack.top_or_none()
 1044:         cache_key = self.context, tuple(args), tuple(kws.items()), flags
 1044:         try:
 1044:             impl, args = self._impl_cache[cache_key]
  956:             return impl, args
   88:         except KeyError:
                   # pass and try outside the scope so as to not have KeyError with a
                   # nested addition error in the case the _build_impl fails
   88:             pass
   88:         impl, args = self._build_impl(cache_key, args, kws)
   88:         return impl, args
       
    1:     def _get_jit_decorator(self):
               """Gets a jit decorator suitable for the current target"""
       
   88:         from numba.core.target_extension import (target_registry,
                                                        get_local_target,
                                                        jit_registry)
       
   88:         jitter_str = self.metadata.get('target', 'generic')
   88:         jitter = jit_registry.get(jitter_str, None)
       
   88:         if jitter is None:
                   # No JIT known for target string, see if something is
                   # registered for the string and report if not.
   88:             target_class = target_registry.get(jitter_str, None)
   88:             if target_class is None:
                       msg = ("Unknown target '{}', has it been ",
                              "registered?")
                       raise ValueError(msg.format(jitter_str))
       
   88:             target_hw = get_local_target(self.context)
       
                   # check that the requested target is in the hierarchy for the
                   # current frame's target.
   88:             if not issubclass(target_hw, target_class):
                       msg = "No overloads exist for the requested target: {}."
       
   88:             jitter = jit_registry[target_hw]
       
   88:         if jitter is None:
                   raise ValueError("Cannot find a suitable jit decorator")
       
   88:         return jitter
       
    1:     def _build_impl(self, cache_key, args, kws):
               """Build and cache the implementation.
       
               Given the positional (`args`) and keyword arguments (`kws`), obtains
               the `overload` implementation and wrap it in a Dispatcher object.
               The expected argument types are returned for use by type-inference.
               The expected argument types are only different from the given argument
               types if there is an imprecise type in the given argument types.
       
               Parameters
               ----------
               cache_key : hashable
                   The key used for caching the implementation.
               args : Tuple[Type]
                   Types of positional argument.
               kws : Dict[Type]
                   Types of keyword argument.
       
               Returns
               -------
               disp, args :
                   On success, returns `(Dispatcher, Tuple[Type])`.
                   On failure, returns `(None, None)`.
       
               """
   88:         jitter = self._get_jit_decorator()
       
               # Get the overload implementation for the given types
   88:         ov_sig = inspect.signature(self._overload_func)
   88:         try:
   88:             ov_sig.bind(*args, **kws)
               except TypeError as e:
                   # bind failed, raise, if there's a
                   # ValueError then there's likely unrecoverable
                   # problems
                   raise TypingError(str(e)) from e
               else:
   88:             ovf_result = self._overload_func(*args, **kws)
       
   88:         if ovf_result is None:
                   # No implementation => fail typing
   73:             self._impl_cache[cache_key] = None, None
   73:             return None, None
   15:         elif isinstance(ovf_result, tuple):
                   # The implementation returned a signature that the type-inferencer
                   # should be using.
                   sig, pyfunc = ovf_result
                   args = sig.args
                   kws = {}
                   cache_key = None            # don't cache
               else:
                   # Regular case
   15:             pyfunc = ovf_result
       
               # Check type of pyfunc
   15:         if not isinstance(pyfunc, FunctionType):
                   msg = ("Implementation function returned by `@overload` "
                          "has an unexpected type.  Got {}")
                   raise AssertionError(msg.format(pyfunc))
       
               # check that the typing and impl sigs match up
   15:         if self._strict:
   11:             self._validate_sigs(self._overload_func, pyfunc)
               # Make dispatcher
   15:         jitdecor = jitter(**self._jit_options)
   15:         disp = jitdecor(pyfunc)
               # Make sure that the implementation can be fully compiled
   15:         disp_type = types.Dispatcher(disp)
   15:         disp_type.get_call_type(self.context, args, kws)
   15:         if cache_key is not None:
   15:             self._impl_cache[cache_key] = disp, args
   15:         return disp, args
       
    1:     def get_impl_key(self, sig):
               """
               Return the key for looking up the implementation for the given
               signature on the target context.
               """
   46:         return self._compiled_overloads[sig.args]
       
    2:     @classmethod
    2:     def get_source_info(cls):
               """Return a dictionary with information about the source code of the
               implementation.
       
               Returns
               -------
               info : dict
                   - "kind" : str
                       The implementation kind.
                   - "name" : str
                       The name of the function that provided the definition.
                   - "sig" : str
                       The formatted signature of the function.
                   - "filename" : str
                       The name of the source file.
                   - "lines": tuple (int, int)
                       First and list line number.
                   - "docstring": str
                       The docstring of the definition.
               """
               basepath = os.path.dirname(os.path.dirname(numba.__file__))
               impl = cls._overload_func
               code, firstlineno, path = cls.get_source_code_info(impl)
               sig = str(utils.pysignature(impl))
               info = {
                   'kind': "overload",
                   'name': getattr(impl, '__qualname__', impl.__name__),
                   'sig': sig,
                   'filename': utils.safe_relpath(path, start=basepath),
                   'lines': (firstlineno, firstlineno + len(code) - 1),
                   'docstring': impl.__doc__
               }
               return info
       
    1:     def get_template_info(self):
               basepath = os.path.dirname(os.path.dirname(numba.__file__))
               impl = self._overload_func
               code, firstlineno, path = self.get_source_code_info(impl)
               sig = str(utils.pysignature(impl))
               info = {
                   'kind': "overload",
                   'name': getattr(impl, '__qualname__', impl.__name__),
                   'sig': sig,
                   'filename': utils.safe_relpath(path, start=basepath),
                   'lines': (firstlineno, firstlineno + len(code) - 1),
                   'docstring': impl.__doc__
               }
               return info
       
       
    1: def make_overload_template(func, overload_func, jit_options, strict,
    1:                            inline, prefer_literal=False, **kwargs):
           """
           Make a template class for function *func* overloaded by *overload_func*.
           Compiler options are passed as a dictionary to *jit_options*.
           """
 1082:     func_name = getattr(func, '__name__', str(func))
 1082:     name = "OverloadTemplate_%s" % (func_name,)
 1082:     base = _OverloadFunctionTemplate
 2164:     dct = dict(key=func, _overload_func=staticmethod(overload_func),
 1082:                _impl_cache={}, _compiled_overloads={}, _jit_options=jit_options,
 1082:                _strict=strict, _inline=staticmethod(InlineOptions(inline)),
 1082:                _inline_overloads={}, prefer_literal=prefer_literal,
 1082:                metadata=kwargs)
 1082:     return type(base)(name, (base,), dct)
       
       
    2: class _TemplateTargetHelperMixin(object):
    1:     """Mixin for helper methods that assist with target/registry resolution"""
       
    1:     def _get_target_registry(self, reason):
               """Returns the registry for the current target.
       
               Parameters
               ----------
               reason: str
                   Reason for the resolution. Expects a noun.
               Returns
               -------
               reg : a registry suitable for the current target.
               """
  260:         from numba.core.target_extension import (_get_local_target_checked,
                                                        dispatcher_registry)
  260:         hwstr = self.metadata.get('target', 'generic')
  260:         target_hw = _get_local_target_checked(self.context, hwstr, reason)
               # Get registry for the current hardware
  260:         disp = dispatcher_registry[target_hw]
  260:         tgtctx = disp.targetdescr.target_context
               # This is all workarounds...
               # The issue is that whilst targets shouldn't care about which registry
               # in which to register lowering implementations, the CUDA target
               # "borrows" implementations from the CPU from specific registries. This
               # means that if some impl is defined via @intrinsic, e.g. numba.*unsafe
               # modules, _AND_ CUDA also makes use of the same impl, then it's
               # required that the registry in use is one that CUDA borrows from. This
               # leads to the following expression where by the CPU builtin_registry is
               # used if it is in the target context as a known registry (i.e. the
               # target installed it) and if it is not then it is assumed that the
               # registries for the target are unbound to any other target and so it's
               # fine to use any of them as a place to put lowering impls.
               #
               # NOTE: This will need subsequently fixing again when targets use solely
               # the extension APIs to describe their implementation. The issue will be
               # that the builtin_registry should contain _just_ the stack allocated
               # implementations and low level target invariant things and should not
               # be modified further. It should be acceptable to remove the `then`
               # branch and just keep the `else`.
       
               # In case the target has swapped, e.g. cuda borrowing cpu, refresh to
               # populate.
  260:         tgtctx.refresh()
  260:         if builtin_registry in tgtctx._registries:
                   reg = builtin_registry
               else:
                   # Pick a registry in which to install intrinsics
  260:             registries = iter(tgtctx._registries)
  260:             reg = next(registries)
  260:         return reg
       
       
    2: class _IntrinsicTemplate(_TemplateTargetHelperMixin, AbstractTemplate):
    1:     """
           A base class of templates for intrinsic definition
           """
       
    1:     def generic(self, args, kws):
               """
               Type the intrinsic by the arguments.
               """
   14:         lower_builtin = self._get_target_registry('intrinsic').lower
   14:         cache_key = self.context, args, tuple(kws.items())
   14:         try:
   14:             return self._impl_cache[cache_key]
    5:         except KeyError:
    5:             pass
    5:         result = self._definition_func(self.context, *args, **kws)
    5:         if result is None:
                   return
    5:         [sig, imp] = result
    5:         pysig = utils.pysignature(self._definition_func)
               # omit context argument from user function
    5:         parameters = list(pysig.parameters.values())[1:]
    5:         sig = sig.replace(pysig=pysig.replace(parameters=parameters))
    5:         self._impl_cache[cache_key] = sig
    5:         self._overload_cache[sig.args] = imp
               # register the lowering
    5:         lower_builtin(imp, *sig.args)(imp)
    5:         return sig
       
    1:     def get_impl_key(self, sig):
               """
               Return the key for looking up the implementation for the given
               signature on the target context.
               """
   14:         return self._overload_cache[sig.args]
       
    1:     def get_template_info(self):
               basepath = os.path.dirname(os.path.dirname(numba.__file__))
               impl = self._definition_func
               code, firstlineno, path = self.get_source_code_info(impl)
               sig = str(utils.pysignature(impl))
               info = {
                   'kind': "intrinsic",
                   'name': getattr(impl, '__qualname__', impl.__name__),
                   'sig': sig,
                   'filename': utils.safe_relpath(path, start=basepath),
                   'lines': (firstlineno, firstlineno + len(code) - 1),
                   'docstring': impl.__doc__
               }
               return info
       
       
    2: def make_intrinsic_template(handle, defn, name, *, prefer_literal=False,
    1:                             kwargs=None):
           """
           Make a template class for a intrinsic handle *handle* defined by the
           function *defn*.  The *name* is used for naming the new template class.
           """
  121:     kwargs = MappingProxyType({} if kwargs is None else kwargs)
  121:     base = _IntrinsicTemplate
  121:     name = "_IntrinsicTemplate_%s" % (name)
  242:     dct = dict(key=handle, _definition_func=staticmethod(defn),
  121:                _impl_cache={}, _overload_cache={},
  121:                prefer_literal=prefer_literal, metadata=kwargs)
  121:     return type(base)(name, (base,), dct)
       
       
    2: class AttributeTemplate(object):
    1:     def __init__(self, context):
  284:         self.context = context
       
    1:     def resolve(self, value, attr):
 1295:         return self._resolve(value, attr)
       
    1:     def _resolve(self, value, attr):
   70:         fn = getattr(self, "resolve_%s" % attr, None)
   70:         if fn is None:
    8:             fn = self.generic_resolve
    8:             if fn is NotImplemented:
                       if isinstance(value, types.Module):
                           return self.context.resolve_module_constants(value, attr)
                       else:
                           return None
                   else:
    8:                 return fn(value, attr)
               else:
   62:             return fn(value)
       
    1:     generic_resolve = NotImplemented
       
       
    2: class _OverloadAttributeTemplate(_TemplateTargetHelperMixin, AttributeTemplate):
    1:     """
           A base class of templates for @overload_attribute functions.
           """
    1:     is_method = False
       
    1:     def __init__(self, context):
  246:         super(_OverloadAttributeTemplate, self).__init__(context)
  246:         self.context = context
  246:         self._init_once()
       
    1:     def _init_once(self):
    7:         cls = type(self)
    7:         attr = cls._attr
       
    7:         lower_getattr = self._get_target_registry('attribute').lower_getattr
       
   14:         @lower_getattr(cls.key, attr)
   14:         def getattr_impl(context, builder, typ, value):
                   typingctx = context.typing_context
                   fnty = cls._get_function_type(typingctx, typ)
                   sig = cls._get_signature(typingctx, fnty, (typ,), {})
                   call = context.get_function(fnty, sig)
                   return call(builder, (value,))
       
    1:     def _resolve(self, typ, attr):
   55:         if self._attr != attr:
   55:             return None
               fnty = self._get_function_type(self.context, typ)
               sig = self._get_signature(self.context, fnty, (typ,), {})
               # There should only be one template
               for template in fnty.templates:
                   self._inline_overloads.update(template._inline_overloads)
               return sig.return_type
       
    2:     @classmethod
    2:     def _get_signature(cls, typingctx, fnty, args, kws):
    6:         sig = fnty.get_call_type(typingctx, args, kws)
    6:         sig = sig.replace(pysig=utils.pysignature(cls._overload_func))
    6:         return sig
       
    2:     @classmethod
    2:     def _get_function_type(cls, typingctx, typ):
    6:         return typingctx.resolve_value_type(cls._overload_func)
       
       
    2: class _OverloadMethodTemplate(_OverloadAttributeTemplate):
    1:     """
           A base class of templates for @overload_method functions.
           """
    1:     is_method = True
       
    1:     def _init_once(self):
               """
               Overriding parent definition
               """
  239:         attr = self._attr
       
  239:         try:
  239:             registry = self._get_target_registry('method')
               except InternalTargetMismatchError:
                   # Target mismatch. Do not register attribute lookup here.
                   pass
               else:
  239:             lower_builtin = registry.lower
       
  478:             @lower_builtin((self.key, attr), self.key, types.VarArg(types.Any))
  478:             def method_impl(context, builder, sig, args):
    2:                 typ = sig.args[0]
    2:                 typing_context = context.typing_context
    2:                 fnty = self._get_function_type(typing_context, typ)
    2:                 sig = self._get_signature(typing_context, fnty, sig.args, {})
    2:                 call = context.get_function(fnty, sig)
                       # Link dependent library
    2:                 context.add_linking_libs(getattr(call, 'libs', ()))
    2:                 return call(builder, args)
       
    1:     def _resolve(self, typ, attr):
 1170:         if self._attr != attr:
 1164:             return None
       
    6:         if isinstance(typ, types.TypeRef):
    3:             assert typ == self.key
    3:         elif isinstance(typ, types.Callable):
                   assert typ == self.key
               else:
    3:             assert isinstance(typ, self.key)
       
   12:         class MethodTemplate(AbstractTemplate):
    6:             key = (self.key, attr)
    6:             _inline = self._inline
    6:             _overload_func = staticmethod(self._overload_func)
    6:             _inline_overloads = self._inline_overloads
    6:             prefer_literal = self.prefer_literal
       
    6:             def generic(_, args, kws):
    4:                 args = (typ,) + tuple(args)
    4:                 fnty = self._get_function_type(self.context, typ)
    4:                 sig = self._get_signature(self.context, fnty, args, kws)
    4:                 sig = sig.replace(pysig=utils.pysignature(self._overload_func))
    8:                 for template in fnty.templates:
    4:                     self._inline_overloads.update(template._inline_overloads)
    4:                 if sig is not None:
    4:                     return sig.as_method()
       
    6:             def get_template_info(self):
                       basepath = os.path.dirname(os.path.dirname(numba.__file__))
                       impl = self._overload_func
                       code, firstlineno, path = self.get_source_code_info(impl)
                       sig = str(utils.pysignature(impl))
                       info = {
                           'kind': "overload_method",
                           'name': getattr(impl, '__qualname__', impl.__name__),
                           'sig': sig,
                           'filename': utils.safe_relpath(path, start=basepath),
                           'lines': (firstlineno, firstlineno + len(code) - 1),
                           'docstring': impl.__doc__
                       }
       
                       return info
       
    6:         return types.BoundFunction(MethodTemplate, typ)
       
       
    1: def make_overload_attribute_template(typ, attr, overload_func, inline,
    1:                                      prefer_literal=False,
    1:                                      base=_OverloadAttributeTemplate,
                                            **kwargs):
           """
           Make a template class for attribute *attr* of *typ* overloaded by
           *overload_func*.
           """
  246:     assert isinstance(typ, types.Type) or issubclass(typ, types.Type)
  246:     name = "OverloadAttributeTemplate_%s_%s" % (typ, attr)
           # Note the implementation cache is subclass-specific
  492:     dct = dict(key=typ, _attr=attr, _impl_cache={},
  246:                _inline=staticmethod(InlineOptions(inline)),
  246:                _inline_overloads={},
  246:                _overload_func=staticmethod(overload_func),
  246:                prefer_literal=prefer_literal,
  246:                metadata=kwargs,
                      )
  246:     obj = type(base)(name, (base,), dct)
  246:     return obj
       
       
    1: def make_overload_method_template(typ, attr, overload_func, inline,
    1:                                   prefer_literal=False, **kwargs):
           """
           Make a template class for method *attr* of *typ* overloaded by
           *overload_func*.
           """
  956:     return make_overload_attribute_template(
  478:         typ, attr, overload_func, inline=inline,
  239:         base=_OverloadMethodTemplate, prefer_literal=prefer_literal,
  239:         **kwargs,
           )
       
       
    1: def bound_function(template_key):
           """
           Wrap an AttributeTemplate resolve_* method to allow it to
           resolve an instance method's signature rather than a instance attribute.
           The wrapped method must return the resolved method's signature
           according to the given self type, args, and keywords.
       
           It is used thusly:
       
               class ComplexAttributes(AttributeTemplate):
                   @bound_function("complex.conjugate")
                   def resolve_conjugate(self, ty, args, kwds):
                       return ty
       
           *template_key* (e.g. "complex.conjugate" above) will be used by the
           target to look up the method's implementation, as a regular function.
           """
   23:     def wrapper(method_resolver):
   46:         @functools.wraps(method_resolver)
   46:         def attribute_resolver(self, ty):
                   class MethodTemplate(AbstractTemplate):
                       key = template_key
       
                       def generic(_, args, kws):
                           sig = method_resolver(self, ty, args, kws)
                           if sig is not None and sig.recvr is None:
                               sig = sig.replace(recvr=ty)
                           return sig
       
                   return types.BoundFunction(MethodTemplate, ty)
   23:         return attribute_resolver
   23:     return wrapper
       
       
       # -----------------------------
       
    2: class Registry(object):
    1:     """
           A registry of typing declarations.  The registry stores such declarations
           for functions, attributes and globals.
           """
       
    1:     def __init__(self):
    9:         self.functions = []
    9:         self.attributes = []
    9:         self.globals = []
       
    1:     def register(self, item):
 1223:         assert issubclass(item, FunctionTemplate)
 1223:         self.functions.append(item)
 1223:         return item
       
    1:     def register_attr(self, item):
  284:         assert issubclass(item, AttributeTemplate)
  284:         self.attributes.append(item)
  284:         return item
       
    1:     def register_global(self, val=None, typ=None, **kwargs):
               """
               Register the typing of a global value.
               Functional usage with a Numba type::
                   register_global(value, typ)
       
               Decorator usage with a template class::
                   @register_global(value, typing_key=None)
                   class Template:
                       ...
               """
 1528:         if typ is not None:
                   # register_global(val, typ)
 1308:             assert val is not None
 1308:             assert not kwargs
 1308:             self.globals.append((val, typ))
               else:
  220:             def decorate(cls, typing_key):
  440:                 class Template(cls):
  220:                     key = typing_key
  220:                 if callable(val):
  220:                     typ = types.Function(Template)
                       else:
                           raise TypeError("cannot infer type for global value %r")
  220:                 self.globals.append((val, typ))
  220:                 return cls
       
                   # register_global(val, typing_key=None)(<template class>)
  220:             assert val is not None
  220:             typing_key = kwargs.pop('typing_key', val)
  220:             assert not kwargs
  220:             if typing_key is val:
                       # Check the value is globally reachable, as it is going
                       # to be used as the key.
  220:                 mod = sys.modules[val.__module__]
  220:                 if getattr(mod, val.__name__) is not val:
                           raise ValueError("%r is not globally reachable as '%s.%s'"
                                            % (mod, val.__module__, val.__name__))
       
  220:             def decorator(cls):
  220:                 return decorate(cls, typing_key)
  220:             return decorator
       
       
    2: class BaseRegistryLoader(object):
    1:     """
           An incremental loader for a registry.  Each new call to
           new_registrations() will iterate over the not yet seen registrations.
       
           The reason for this object is multiple:
           - there can be several contexts
           - each context wants to install all registrations
           - registrations can be added after the first installation, so contexts
             must be able to get the "new" installations
       
           Therefore each context maintains its own loaders for each existing
           registry, without duplicating the registries themselves.
           """
       
    1:     def __init__(self, registry):
  185:         self._registrations = dict(
   67:             (name, utils.stream_list(getattr(registry, name)))
   84:             for name in self.registry_items)
       
    1:     def new_registrations(self, name):
28721:         for item in next(self._registrations[name]):
 4221:             yield item
       
       
    2: class RegistryLoader(BaseRegistryLoader):
    1:     """
           An incremental loader for a typing registry.
           """
    1:     registry_items = ('functions', 'attributes', 'globals')
       
       
    1: builtin_registry = Registry()
    1: infer = builtin_registry.register
    1: infer_getattr = builtin_registry.register_attr
    1: infer_global = builtin_registry.register_global
