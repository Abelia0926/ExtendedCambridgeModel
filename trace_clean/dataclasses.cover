    1: import re
    1: import sys
    1: import copy
    1: import types
    1: import inspect
    1: import keyword
    1: import builtins
    1: import functools
    1: import itertools
    1: import abc
    1: import _thread
    1: from types import FunctionType, GenericAlias
       
       
    1: __all__ = ['dataclass',
                  'field',
                  'Field',
                  'FrozenInstanceError',
                  'InitVar',
                  'KW_ONLY',
                  'MISSING',
       
                  # Helper functions.
                  'fields',
                  'asdict',
                  'astuple',
                  'make_dataclass',
                  'replace',
                  'is_dataclass',
                  ]
       
       # Conditions for adding methods.  The boxes indicate what action the
       # dataclass decorator takes.  For all of these tables, when I talk
       # about init=, repr=, eq=, order=, unsafe_hash=, or frozen=, I'm
       # referring to the arguments to the @dataclass decorator.  When
       # checking if a dunder method already exists, I mean check for an
       # entry in the class's __dict__.  I never check to see if an attribute
       # is defined in a base class.
       
       # Key:
       # +=========+=========================================+
       # + Value   | Meaning                                 |
       # +=========+=========================================+
       # | <blank> | No action: no method is added.          |
       # +---------+-----------------------------------------+
       # | add     | Generated method is added.              |
       # +---------+-----------------------------------------+
       # | raise   | TypeError is raised.                    |
       # +---------+-----------------------------------------+
       # | None    | Attribute is set to None.               |
       # +=========+=========================================+
       
       # __init__
       #
       #   +--- init= parameter
       #   |
       #   v     |       |       |
       #         |  no   |  yes  |  <--- class has __init__ in __dict__?
       # +=======+=======+=======+
       # | False |       |       |
       # +-------+-------+-------+
       # | True  | add   |       |  <- the default
       # +=======+=======+=======+
       
       # __repr__
       #
       #    +--- repr= parameter
       #    |
       #    v    |       |       |
       #         |  no   |  yes  |  <--- class has __repr__ in __dict__?
       # +=======+=======+=======+
       # | False |       |       |
       # +-------+-------+-------+
       # | True  | add   |       |  <- the default
       # +=======+=======+=======+
       
       
       # __setattr__
       # __delattr__
       #
       #    +--- frozen= parameter
       #    |
       #    v    |       |       |
       #         |  no   |  yes  |  <--- class has __setattr__ or __delattr__ in __dict__?
       # +=======+=======+=======+
       # | False |       |       |  <- the default
       # +-------+-------+-------+
       # | True  | add   | raise |
       # +=======+=======+=======+
       # Raise because not adding these methods would break the "frozen-ness"
       # of the class.
       
       # __eq__
       #
       #    +--- eq= parameter
       #    |
       #    v    |       |       |
       #         |  no   |  yes  |  <--- class has __eq__ in __dict__?
       # +=======+=======+=======+
       # | False |       |       |
       # +-------+-------+-------+
       # | True  | add   |       |  <- the default
       # +=======+=======+=======+
       
       # __lt__
       # __le__
       # __gt__
       # __ge__
       #
       #    +--- order= parameter
       #    |
       #    v    |       |       |
       #         |  no   |  yes  |  <--- class has any comparison method in __dict__?
       # +=======+=======+=======+
       # | False |       |       |  <- the default
       # +-------+-------+-------+
       # | True  | add   | raise |
       # +=======+=======+=======+
       # Raise because to allow this case would interfere with using
       # functools.total_ordering.
       
       # __hash__
       
       #    +------------------- unsafe_hash= parameter
       #    |       +----------- eq= parameter
       #    |       |       +--- frozen= parameter
       #    |       |       |
       #    v       v       v    |        |        |
       #                         |   no   |  yes   |  <--- class has explicitly defined __hash__
       # +=======+=======+=======+========+========+
       # | False | False | False |        |        | No __eq__, use the base class __hash__
       # +-------+-------+-------+--------+--------+
       # | False | False | True  |        |        | No __eq__, use the base class __hash__
       # +-------+-------+-------+--------+--------+
       # | False | True  | False | None   |        | <-- the default, not hashable
       # +-------+-------+-------+--------+--------+
       # | False | True  | True  | add    |        | Frozen, so hashable, allows override
       # +-------+-------+-------+--------+--------+
       # | True  | False | False | add    | raise  | Has no __eq__, but hashable
       # +-------+-------+-------+--------+--------+
       # | True  | False | True  | add    | raise  | Has no __eq__, but hashable
       # +-------+-------+-------+--------+--------+
       # | True  | True  | False | add    | raise  | Not frozen, but hashable
       # +-------+-------+-------+--------+--------+
       # | True  | True  | True  | add    | raise  | Frozen, so hashable
       # +=======+=======+=======+========+========+
       # For boxes that are blank, __hash__ is untouched and therefore
       # inherited from the base class.  If the base is object, then
       # id-based hashing is used.
       #
       # Note that a class may already have __hash__=None if it specified an
       # __eq__ method in the class body (not one that was created by
       # @dataclass).
       #
       # See _hash_action (below) for a coded version of this table.
       
       # __match_args__
       #
       #    +--- match_args= parameter
       #    |
       #    v    |       |       |
       #         |  no   |  yes  |  <--- class has __match_args__ in __dict__?
       # +=======+=======+=======+
       # | False |       |       |
       # +-------+-------+-------+
       # | True  | add   |       |  <- the default
       # +=======+=======+=======+
       # __match_args__ is always added unless the class already defines it. It is a
       # tuple of __init__ parameter names; non-init fields must be matched by keyword.
       
       
       # Raised when an attempt is made to modify a frozen class.
    2: class FrozenInstanceError(AttributeError): pass
       
       # A sentinel object for default values to signal that a default
       # factory will be used.  This is given a nice repr() which will appear
       # in the function signature of dataclasses' constructors.
    2: class _HAS_DEFAULT_FACTORY_CLASS:
    1:     def __repr__(self):
   18:         return '<factory>'
    1: _HAS_DEFAULT_FACTORY = _HAS_DEFAULT_FACTORY_CLASS()
       
       # A sentinel object to detect if a parameter is supplied or not.  Use
       # a class to give it a better repr.
    2: class _MISSING_TYPE:
    1:     pass
    1: MISSING = _MISSING_TYPE()
       
       # A sentinel object to indicate that following fields are keyword-only by
       # default.  Use a class to give it a better repr.
    2: class _KW_ONLY_TYPE:
    1:     pass
    1: KW_ONLY = _KW_ONLY_TYPE()
       
       # Since most per-field metadata will be unused, create an empty
       # read-only proxy that can be shared among all fields.
    1: _EMPTY_METADATA = types.MappingProxyType({})
       
       # Markers for the various kinds of fields and pseudo-fields.
    2: class _FIELD_BASE:
    1:     def __init__(self, name):
    3:         self.name = name
    1:     def __repr__(self):
               return self.name
    1: _FIELD = _FIELD_BASE('_FIELD')
    1: _FIELD_CLASSVAR = _FIELD_BASE('_FIELD_CLASSVAR')
    1: _FIELD_INITVAR = _FIELD_BASE('_FIELD_INITVAR')
       
       # The name of an attribute on the class where we store the Field
       # objects.  Also used to check if a class is a Data Class.
    1: _FIELDS = '__dataclass_fields__'
       
       # The name of an attribute on the class that stores the parameters to
       # @dataclass.
    1: _PARAMS = '__dataclass_params__'
       
       # The name of the function, that if it exists, is called at the end of
       # __init__.
    1: _POST_INIT_NAME = '__post_init__'
       
       # String regex that string annotations for ClassVar or InitVar must match.
       # Allows "identifier.identifier[" or "identifier[".
       # https://bugs.python.org/issue33453 for details.
    1: _MODULE_IDENTIFIER_RE = re.compile(r'^(?:\s*(\w+)\s*\.)?\s*(\w+)')
       
       # This function's logic is copied from "recursive_repr" function in
       # reprlib module to avoid dependency.
    1: def _recursive_repr(user_function):
           # Decorator to make a repr function return "..." for a recursive
           # call.
   94:     repr_running = set()
       
  188:     @functools.wraps(user_function)
  188:     def wrapper(self):
               key = id(self), _thread.get_ident()
               if key in repr_running:
                   return '...'
               repr_running.add(key)
               try:
                   result = user_function(self)
               finally:
                   repr_running.discard(key)
               return result
   94:     return wrapper
       
    2: class InitVar:
    1:     __slots__ = ('type', )
       
    1:     def __init__(self, type):
               self.type = type
       
    1:     def __repr__(self):
               if isinstance(self.type, type):
                   type_name = self.type.__name__
               else:
                   # typing objects, e.g. List[int]
                   type_name = repr(self.type)
               return f'dataclasses.InitVar[{type_name}]'
       
    1:     def __class_getitem__(cls, type):
               return InitVar(type)
       
       # Instances of Field are only ever created from within this module,
       # and only from the field() function, although Field instances are
       # exposed externally as (conceptually) read-only objects.
       #
       # name and type are filled in after the fact, not in __init__.
       # They're not known at the time this class is instantiated, but it's
       # convenient if they're available later.
       #
       # When cls._FIELDS is filled in with a list of Field objects, the name
       # and type fields will have been populated.
    2: class Field:
    1:     __slots__ = ('name',
                        'type',
                        'default',
                        'default_factory',
                        'repr',
                        'hash',
                        'init',
                        'compare',
                        'metadata',
                        'kw_only',
                        '_field_type',  # Private: not to be used by user code.
                        )
       
    1:     def __init__(self, default, default_factory, init, repr, hash, compare,
                        metadata, kw_only):
  365:         self.name = None
  365:         self.type = None
  365:         self.default = default
  365:         self.default_factory = default_factory
  365:         self.init = init
  365:         self.repr = repr
  365:         self.hash = hash
  365:         self.compare = compare
  365:         self.metadata = (_EMPTY_METADATA
  365:                          if metadata is None else
                                types.MappingProxyType(metadata))
  365:         self.kw_only = kw_only
  365:         self._field_type = None
       
    2:     @_recursive_repr
    2:     def __repr__(self):
               return ('Field('
                       f'name={self.name!r},'
                       f'type={self.type!r},'
                       f'default={self.default!r},'
                       f'default_factory={self.default_factory!r},'
                       f'init={self.init!r},'
                       f'repr={self.repr!r},'
                       f'hash={self.hash!r},'
                       f'compare={self.compare!r},'
                       f'metadata={self.metadata!r},'
                       f'kw_only={self.kw_only!r},'
                       f'_field_type={self._field_type}'
                       ')')
       
           # This is used to support the PEP 487 __set_name__ protocol in the
           # case where we're using a field that contains a descriptor as a
           # default value.  For details on __set_name__, see
           # https://peps.python.org/pep-0487/#implementation-details.
           #
           # Note that in _process_class, this Field object is overwritten
           # with the default value, so the end result is a descriptor that
           # had __set_name__ called on it at the right time.
    1:     def __set_name__(self, owner, name):
   69:         func = getattr(type(self.default), '__set_name__', None)
   69:         if func:
                   # There is a __set_name__ method on the descriptor, call
                   # it.
                   func(self.default, owner, name)
       
    1:     __class_getitem__ = classmethod(GenericAlias)
       
       
    2: class _DataclassParams:
    1:     __slots__ = ('init',
                        'repr',
                        'eq',
                        'order',
                        'unsafe_hash',
                        'frozen',
                        )
       
    1:     def __init__(self, init, repr, eq, order, unsafe_hash, frozen):
   93:         self.init = init
   93:         self.repr = repr
   93:         self.eq = eq
   93:         self.order = order
   93:         self.unsafe_hash = unsafe_hash
   93:         self.frozen = frozen
       
    1:     def __repr__(self):
               return ('_DataclassParams('
                       f'init={self.init!r},'
                       f'repr={self.repr!r},'
                       f'eq={self.eq!r},'
                       f'order={self.order!r},'
                       f'unsafe_hash={self.unsafe_hash!r},'
                       f'frozen={self.frozen!r}'
                       ')')
       
       
       # This function is used instead of exposing Field creation directly,
       # so that a type checker can be told (via overloads) that this is a
       # function whose type depends on its parameters.
    2: def field(*, default=MISSING, default_factory=MISSING, init=True, repr=True,
    1:           hash=None, compare=True, metadata=None, kw_only=MISSING):
           """Return an object to identify dataclass fields.
       
           default is the default value of the field.  default_factory is a
           0-argument function called to initialize a field's value.  If init
           is true, the field will be a parameter to the class's __init__()
           function.  If repr is true, the field will be included in the
           object's repr().  If hash is true, the field will be included in the
           object's hash().  If compare is true, the field will be used in
           comparison functions.  metadata, if specified, must be a mapping
           which is stored but not otherwise examined by dataclass.  If kw_only
           is true, the field will become a keyword-only parameter to
           __init__().
       
           It is an error to specify both default and default_factory.
           """
       
  365:     if default is not MISSING and default_factory is not MISSING:
               raise ValueError('cannot specify both default and default_factory')
  730:     return Field(default, default_factory, init, repr, hash, compare,
  365:                  metadata, kw_only)
       
       
    1: def _fields_in_init_order(fields):
           # Returns the fields as __init__ will output them.  It returns 2 tuples:
           # the first for normal args, and the second for keyword args.
       
  650:     return (tuple(f for f in fields if f.init and not f.kw_only),
  557:             tuple(f for f in fields if f.init and f.kw_only)
                   )
       
       
    1: def _tuple_str(obj_name, fields):
           # Return a string representing each field of obj_name as a tuple
           # member.  So, if fields is ['x', 'y'] and obj_name is "self",
           # return "(self.x,self.y)".
       
           # Special case for the 0-tuple.
  211:     if not fields:
   12:         return '()'
           # Note the trailing comma, needed if this turns out to be a 1-tuple.
 1237:     return f'({",".join([f"{obj_name}.{f.name}" for f in fields])},)'
       
       
    2: def _create_fn(name, args, body, *, globals=None, locals=None,
    1:                return_type=MISSING):
           # Note that we may mutate locals. Callers beware!
           # The only callers are internal to this module, so no
           # worries about external callers.
  352:     if locals is None:
  213:         locals = {}
  352:     return_annotation = ''
  352:     if return_type is not MISSING:
   93:         locals['_return_type'] = return_type
   93:         return_annotation = '->_return_type'
  352:     args = ','.join(args)
 1630:     body = '\n'.join(f'  {b}' for b in body)
       
           # Compute the text of the entire function.
  352:     txt = f' def {name}({args}){return_annotation}:\n{body}'
       
  352:     local_vars = ', '.join(locals.keys())
  352:     txt = f"def __create_fn__({local_vars}):\n{txt}\n return {name}"
  352:     ns = {}
  352:     exec(txt, globals, ns)
  352:     return ns['__create_fn__'](**locals)
       
       
    1: def _field_assign(frozen, name, value, self_name):
           # If we're a frozen class, then assign to our fields in __init__
           # via object.__setattr__.  Otherwise, just use a simple
           # assignment.
           #
           # self_name is what "self" is called in this function: don't
           # hard-code "self", since that might be a field name.
  369:     if frozen:
   91:         return f'__dataclass_builtins_object__.__setattr__({self_name},{name!r},{value})'
  278:     return f'{self_name}.{name}={value}'
       
       
    1: def _field_init(f, frozen, globals, self_name, slots):
           # Return the text of the line in the body of __init__ that will
           # initialize this field.
       
  371:     default_name = f'_dflt_{f.name}'
  371:     if f.default_factory is not MISSING:
   47:         if f.init:
                   # This field has a default factory.  If a parameter is
                   # given, use it.  If not, call the factory.
   47:             globals[default_name] = f.default_factory
  141:             value = (f'{default_name}() '
   47:                      f'if {f.name} is _HAS_DEFAULT_FACTORY '
   47:                      f'else {f.name}')
               else:
                   # This is a field that's not in the __init__ params, but
                   # has a default factory function.  It needs to be
                   # initialized here by calling the factory function,
                   # because there's no other way to initialize it.
       
                   # For a field initialized with a default=defaultvalue, the
                   # class dict just has the default value
                   # (cls.fieldname=defaultvalue).  But that won't work for a
                   # default factory, the factory must be called in __init__
                   # and we must assign that to self.fieldname.  We can't
                   # fall back to the class dict's value, both because it's
                   # not set, and because it might be different per-class
                   # (which, after all, is why we have a factory function!).
       
                   globals[default_name] = f.default_factory
                   value = f'{default_name}()'
           else:
               # No default factory.
  324:         if f.init:
  322:             if f.default is MISSING:
                       # There's no default, just do an assignment.
  191:                 value = f.name
  131:             elif f.default is not MISSING:
  131:                 globals[default_name] = f.default
  131:                 value = f.name
               else:
                   # If the class has slots, then initialize this field.
    2:             if slots and f.default is not MISSING:
                       globals[default_name] = f.default
                       value = default_name
                   else:
                       # This field does not need initialization: reading from it will
                       # just use the class attribute that contains the default.
                       # Signify that to the caller by returning None.
    2:                 return None
       
           # Only test this now, so that we can create variables for the
           # default.  However, return None to signify that we're not going
           # to actually do the assignment statement for InitVars.
  369:     if f._field_type is _FIELD_INITVAR:
               return None
       
           # Now, actually generate the field assignment.
  369:     return _field_assign(frozen, f.name, value, self_name)
       
       
    1: def _init_param(f):
           # Return the __init__ parameter string for this field.  For
           # example, the equivalent of 'x:int=3' (except instead of 'int',
           # reference a variable set to int, and instead of '3', reference a
           # variable set to 3).
  369:     if f.default is MISSING and f.default_factory is MISSING:
               # There's no default, and no default_factory, just output the
               # variable name and type.
  191:         default = ''
  178:     elif f.default is not MISSING:
               # There's a default, this will be the name that's used to look
               # it up.
  131:         default = f'=_dflt_{f.name}'
   47:     elif f.default_factory is not MISSING:
               # There's a factory function.  Set a marker.
   47:         default = '=_HAS_DEFAULT_FACTORY'
  369:     return f'{f.name}:_type_{f.name}{default}'
       
       
    1: def _init_fn(fields, std_fields, kw_only_fields, frozen, has_post_init,
                    self_name, globals, slots):
           # fields contains both real fields and InitVar pseudo-fields.
       
           # Make sure we don't have fields without defaults following fields
           # with defaults.  This actually would be caught when exec-ing the
           # function source code, but catching it here gives a better error
           # message, and future-proofs us in case we build up the function
           # using ast.
       
   93:     seen_default = False
  462:     for f in std_fields:
               # Only consider the non-kw-only fields in the __init__ call.
  369:         if f.init:
  369:             if not (f.default is MISSING and f.default_factory is MISSING):
  178:                 seen_default = True
  191:             elif seen_default:
                       raise TypeError(f'non-default argument {f.name!r} '
                                       'follows default argument')
       
  557:     locals = {f'_type_{f.name}': f.type for f in fields}
  186:     locals.update({
   93:         'MISSING': MISSING,
   93:         '_HAS_DEFAULT_FACTORY': _HAS_DEFAULT_FACTORY,
   93:         '__dataclass_builtins_object__': object,
           })
       
   93:     body_lines = []
  464:     for f in fields:
  371:         line = _field_init(f, frozen, locals, self_name, slots)
               # line is None means that this field doesn't require
               # initialization (it's a pseudo-field).  Just skip it.
  371:         if line:
  369:             body_lines.append(line)
       
           # Does this class have a post-init function?
   93:     if has_post_init:
   49:         params_str = ','.join(f.name for f in fields
   37:                               if f._field_type is _FIELD_INITVAR)
    6:         body_lines.append(f'{self_name}.{_POST_INIT_NAME}({params_str})')
       
           # If no body lines, use 'pass'.
   93:     if not body_lines:
    6:         body_lines = ['pass']
       
  555:     _init_params = [_init_param(f) for f in std_fields]
   93:     if kw_only_fields:
               # Add the keyword-only args.  Because the * can only be added if
               # there's at least one keyword-only arg, there needs to be a test here
               # (instead of just concatenting the lists together).
               _init_params += ['*']
               _init_params += [_init_param(f) for f in kw_only_fields]
  186:     return _create_fn('__init__',
   93:                       [self_name] + _init_params,
   93:                       body_lines,
   93:                       locals=locals,
   93:                       globals=globals,
   93:                       return_type=None)
       
       
    1: def _repr_fn(fields, globals):
  186:     fn = _create_fn('__repr__',
   93:                     ('self',),
  279:                     ['return self.__class__.__qualname__ + f"(' +
  981:                      ', '.join([f"{f.name}={{self.{f.name}!r}}"
  444:                                 for f in fields]) +
   93:                      ')"'],
   93:                      globals=globals)
   93:     return _recursive_repr(fn)
       
       
    1: def _frozen_get_del_attr(cls, fields, globals):
   46:     locals = {'cls': cls,
   23:               'FrozenInstanceError': FrozenInstanceError}
   23:     if fields:
  139:         fields_str = '(' + ','.join(repr(f.name) for f in fields) + ',)'
           else:
               # Special case for the zero-length tuple.
               fields_str = '()'
   69:     return (_create_fn('__setattr__',
   23:                       ('self', 'name', 'value'),
   46:                       (f'if type(self) is cls or name in {fields_str}:',
   23:                         ' raise FrozenInstanceError(f"cannot assign to field {name!r}")',
   23:                        f'super(cls, self).__setattr__(name, value)'),
   23:                        locals=locals,
   23:                        globals=globals),
   46:             _create_fn('__delattr__',
   23:                       ('self', 'name'),
   46:                       (f'if type(self) is cls or name in {fields_str}:',
   23:                         ' raise FrozenInstanceError(f"cannot delete field {name!r}")',
   23:                        f'super(cls, self).__delattr__(name)'),
   23:                        locals=locals,
   23:                        globals=globals),
                   )
       
       
    1: def _cmp_fn(name, op, self_tuple, other_tuple, globals):
           # Create a comparison function.  If the fields in the object are
           # named 'x' and 'y', then self_tuple is the string
           # '(self.x,self.y)' and other_tuple is the string
           # '(other.x,other.y)'.
       
  194:     return _create_fn(name,
   97:                       ('self', 'other'),
  194:                       [ 'if other.__class__ is self.__class__:',
   97:                        f' return {self_tuple}{op}{other_tuple}',
   97:                         'return NotImplemented'],
   97:                       globals=globals)
       
       
    1: def _hash_fn(fields, globals):
   23:     self_tuple = _tuple_str('self', fields)
   46:     return _create_fn('__hash__',
   23:                       ('self',),
   23:                       [f'return hash({self_tuple})'],
   23:                       globals=globals)
       
       
    1: def _is_classvar(a_type, typing):
           # This test uses a typing internal class, but it's the best way to
           # test if this is a ClassVar.
 1090:     return (a_type is typing.ClassVar
  545:             or (type(a_type) is typing._GenericAlias
    6:                 and a_type.__origin__ is typing.ClassVar))
       
       
    1: def _is_initvar(a_type, dataclasses):
           # The module we're checking against is the module we're
           # currently in (dataclasses.py).
 1090:     return (a_type is dataclasses.InitVar
  545:             or type(a_type) is dataclasses.InitVar)
       
    1: def _is_kw_only(a_type, dataclasses):
  545:     return a_type is dataclasses.KW_ONLY
       
       
    1: def _is_type(annotation, cls, a_module, a_type, is_type_predicate):
           # Given a type annotation string, does it refer to a_type in
           # a_module?  For example, when checking that annotation denotes a
           # ClassVar, then a_module is typing, and a_type is
           # typing.ClassVar.
       
           # It's possible to look up a_module given a_type, but it involves
           # looking in sys.modules (again!), and seems like a waste since
           # the caller already knows a_module.
       
           # - annotation is a string type annotation
           # - cls is the class that this annotation was found in
           # - a_module is the module we want to match
           # - a_type is the type in that module we want to match
           # - is_type_predicate is a function called with (obj, a_module)
           #   that determines if obj is of the desired type.
       
           # Since this test does not do a local namespace lookup (and
           # instead only a module (global) lookup), there are some things it
           # gets wrong.
       
           # With string annotations, cv0 will be detected as a ClassVar:
           #   CV = ClassVar
           #   @dataclass
           #   class C0:
           #     cv0: CV
       
           # But in this example cv1 will not be detected as a ClassVar:
           #   @dataclass
           #   class C1:
           #     CV = ClassVar
           #     cv1: CV
       
           # In C1, the code in this function (_is_type) will look up "CV" in
           # the module and not find it, so it will not consider cv1 as a
           # ClassVar.  This is a fairly obscure corner case, and the best
           # way to fix it would be to eval() the string "CV" with the
           # correct global and local namespaces.  However that would involve
           # a eval() penalty for every single field of every dataclass
           # that's defined.  It was judged not worth it.
       
  645:     match = _MODULE_IDENTIFIER_RE.match(annotation)
  645:     if match:
  645:         ns = None
  645:         module_name = match.group(1)
  645:         if not module_name:
                   # No module name, assume the class's module did
                   # "from dataclasses import InitVar".
  540:             ns = sys.modules.get(cls.__module__).__dict__
               else:
                   # Look up module_name in the class's module.
  105:             module = sys.modules.get(cls.__module__)
  105:             if module and module.__dict__.get(module_name) is a_module:
                       ns = sys.modules.get(a_type.__module__).__dict__
  645:         if ns and is_type_predicate(ns.get(match.group(2)), a_module):
                   return True
  645:     return False
       
       
    1: def _get_field(cls, a_name, a_type, default_kw_only):
           # Return a Field object for this field name and type.  ClassVars and
           # InitVars are also returned, but marked as such (see f._field_type).
           # default_kw_only is the value of kw_only to use if there isn't a field()
           # that defines it.
       
           # If the default value isn't derived from Field, then it's only a
           # normal default value.  Convert it to a Field().
  365:     default = getattr(cls, a_name, MISSING)
  365:     if isinstance(default, Field):
   69:         f = default
           else:
  296:         if isinstance(default, types.MemberDescriptorType):
                   # This is a field in __slots__, so it has no default value.
                   default = MISSING
  296:         f = field(default=default)
       
           # Only at this point do we know the name and the type.  Set them.
  365:     f.name = a_name
  365:     f.type = a_type
       
           # Assume it's a normal field until proven otherwise.  We're next
           # going to decide if it's a ClassVar or InitVar, everything else
           # is just a normal field.
  365:     f._field_type = _FIELD
       
           # In addition to checking for actual types here, also check for
           # string annotations.  get_type_hints() won't always work for us
           # (see https://github.com/python/typing/issues/508 for example),
           # plus it's expensive and would require an eval for every string
           # annotation.  So, make a best effort to see if this is a ClassVar
           # or InitVar using regex's and checking that the thing referenced
           # is actually of the correct type.
       
           # For the complete discussion, see https://bugs.python.org/issue33453
       
           # If typing has not been imported, then it's impossible for any
           # annotation to be a ClassVar.  So, only look for ClassVar if
           # typing has been imported by any module (not necessarily cls's
           # module).
  365:     typing = sys.modules.get('typing')
  365:     if typing:
  945:         if (_is_classvar(a_type, typing)
  365:             or (isinstance(f.type, str)
  430:                 and _is_type(f.type, cls, typing, typing.ClassVar,
  215:                              _is_classvar))):
                   f._field_type = _FIELD_CLASSVAR
       
           # If the type is InitVar, or if it's a matching string annotation,
           # then it's an InitVar.
  365:     if f._field_type is _FIELD:
               # The module we're checking against is the module we're
               # currently in (dataclasses.py).
  365:         dataclasses = sys.modules[__name__]
  945:         if (_is_initvar(a_type, dataclasses)
  365:             or (isinstance(f.type, str)
  430:                 and _is_type(f.type, cls, dataclasses, dataclasses.InitVar,
  215:                              _is_initvar))):
                   f._field_type = _FIELD_INITVAR
       
           # Validations for individual fields.  This is delayed until now,
           # instead of in the Field() constructor, since only here do we
           # know the field name, which allows for better error reporting.
       
           # Special restrictions for ClassVar and InitVar.
  365:     if f._field_type in (_FIELD_CLASSVAR, _FIELD_INITVAR):
               if f.default_factory is not MISSING:
                   raise TypeError(f'field {f.name} cannot have a '
                                   'default factory')
               # Should I check for other field settings? default_factory
               # seems the most serious to check for.  Maybe add others.  For
               # example, how about init=False (or really,
               # init=<not-the-default-init-value>)?  It makes no sense for
               # ClassVar and InitVar to specify init=<anything>.
       
           # kw_only validation and assignment.
  365:     if f._field_type in (_FIELD, _FIELD_INITVAR):
               # For real and InitVar fields, if kw_only wasn't specified use the
               # default value.
  365:         if f.kw_only is MISSING:
  365:             f.kw_only = default_kw_only
           else:
               # Make sure kw_only isn't set for ClassVars
               assert f._field_type is _FIELD_CLASSVAR
               if f.kw_only is not MISSING:
                   raise TypeError(f'field {f.name} is a ClassVar but specifies '
                                   'kw_only')
       
           # For real fields, disallow mutable defaults.  Use unhashable as a proxy
           # indicator for mutability.  Read the __hash__ attribute from the class,
           # not the instance.
  365:     if f._field_type is _FIELD and f.default.__class__.__hash__ is None:
               raise ValueError(f'mutable default {type(f.default)} for field '
                                f'{f.name} is not allowed: use default_factory')
       
  365:     return f
       
    1: def _set_qualname(cls, value):
           # Ensure that the functions returned from _create_fn uses the proper
           # __qualname__ (the class they belong to).
  437:     if isinstance(value, FunctionType):
  344:         value.__qualname__ = f"{cls.__qualname__}.{value.__name__}"
  437:     return value
       
    1: def _set_new_attribute(cls, name, value):
           # Never overwrites an existing attribute.  Returns True if the
           # attribute already exists.
  422:     if name in cls.__dict__:
    8:         return True
  414:     _set_qualname(cls, value)
  414:     setattr(cls, name, value)
  414:     return False
       
       
       # Decide if/how we're going to create a hash function.  Key is
       # (unsafe_hash, eq, frozen, does-hash-exist).  Value is the action to
       # take.  The common case is to do nothing, so instead of providing a
       # function that is a no-op, use None to signify that.
       
    1: def _hash_set_none(cls, fields, globals):
   70:     return None
       
    1: def _hash_add(cls, fields, globals):
  139:     flds = [f for f in fields if (f.compare if f.hash is None else f.hash)]
   23:     return _set_qualname(cls, _hash_fn(flds, globals))
       
    1: def _hash_exception(cls, fields, globals):
           # Raise an exception.
           raise TypeError(f'Cannot overwrite attribute __hash__ '
                           f'in class {cls.__name__}')
       
       #
       #                +-------------------------------------- unsafe_hash?
       #                |      +------------------------------- eq?
       #                |      |      +------------------------ frozen?
       #                |      |      |      +----------------  has-explicit-hash?
       #                |      |      |      |
       #                |      |      |      |        +-------  action
       #                |      |      |      |        |
       #                v      v      v      v        v
   16: _hash_action = {(False, False, False, False): None,
    1:                 (False, False, False, True ): None,
    1:                 (False, False, True,  False): None,
    1:                 (False, False, True,  True ): None,
    1:                 (False, True,  False, False): _hash_set_none,
    1:                 (False, True,  False, True ): None,
    1:                 (False, True,  True,  False): _hash_add,
    1:                 (False, True,  True,  True ): None,
    1:                 (True,  False, False, False): _hash_add,
    1:                 (True,  False, False, True ): _hash_exception,
    1:                 (True,  False, True,  False): _hash_add,
    1:                 (True,  False, True,  True ): _hash_exception,
    1:                 (True,  True,  False, False): _hash_add,
    1:                 (True,  True,  False, True ): _hash_exception,
    1:                 (True,  True,  True,  False): _hash_add,
    1:                 (True,  True,  True,  True ): _hash_exception,
                       }
       # See https://bugs.python.org/issue32929#msg312829 for an if-statement
       # version of this table.
       
       
    1: def _process_class(cls, init, repr, eq, order, unsafe_hash, frozen,
                          match_args, kw_only, slots, weakref_slot):
           # Now that dicts retain insertion order, there's no reason to use
           # an ordered dict.  I am leveraging that ordering here, because
           # derived class fields overwrite base class fields, but the order
           # is defined by the base class, which is found first.
   93:     fields = {}
       
   93:     if cls.__module__ in sys.modules:
   93:         globals = sys.modules[cls.__module__].__dict__
           else:
               # Theoretically this can happen if someone writes
               # a custom string to cls.__module__.  In which case
               # such dataclass won't be fully introspectable
               # (w.r.t. typing.get_type_hints) but will still function
               # correctly.
               globals = {}
       
  186:     setattr(cls, _PARAMS, _DataclassParams(init, repr, eq, order,
   93:                                            unsafe_hash, frozen))
       
           # Find our base classes in reverse MRO order, and exclude
           # ourselves.  In reversed order so that more derived classes
           # override earlier field definitions in base classes.  As long as
           # we're iterating over them, see if any are frozen.
   93:     any_frozen_base = False
   93:     has_dataclass_bases = False
  218:     for b in cls.__mro__[-1:0:-1]:
               # Only process classes that have been processed by our
               # decorator.  That is, they have a _FIELDS attribute.
  125:         base_fields = getattr(b, _FIELDS, None)
  125:         if base_fields is not None:
    3:             has_dataclass_bases = True
    9:             for f in base_fields.values():
    6:                 fields[f.name] = f
    3:             if getattr(b, _PARAMS).frozen:
                       any_frozen_base = True
       
           # Annotations that are defined in this class (not in base
           # classes).  If __annotations__ isn't present, then this class
           # adds no new annotations.  We use this to compute fields that are
           # added by this class.
           #
           # Fields are found from cls_annotations, which is guaranteed to be
           # ordered.  Default values are from class attributes, if a field
           # has a default.  If the default value is a Field(), then it
           # contains additional info beyond (and possibly including) the
           # actual default value.  Pseudo-fields ClassVars and InitVars are
           # included, despite the fact that they're not real fields.  That's
           # dealt with later.
   93:     cls_annotations = cls.__dict__.get('__annotations__', {})
       
           # Now find fields in our class.  While doing so, validate some
           # things, and set the default values (as class attributes) where
           # we can.
   93:     cls_fields = []
           # Get a reference to this module for the _is_kw_only() test.
   93:     KW_ONLY_seen = False
   93:     dataclasses = sys.modules[__name__]
  458:     for name, type in cls_annotations.items():
               # See if this is a marker to change the value of kw_only.
  945:         if (_is_kw_only(type, dataclasses)
  365:             or (isinstance(type, str)
  430:                 and _is_type(type, cls, dataclasses, dataclasses.KW_ONLY,
  215:                              _is_kw_only))):
                   # Switch the default to kw_only=True, and ignore this
                   # annotation: it's not a real field.
                   if KW_ONLY_seen:
                       raise TypeError(f'{name!r} is KW_ONLY, but KW_ONLY '
                                       'has already been specified')
                   KW_ONLY_seen = True
                   kw_only = True
               else:
                   # Otherwise it's a field of some type.
  365:             cls_fields.append(_get_field(cls, name, type, kw_only))
       
  458:     for f in cls_fields:
  365:         fields[f.name] = f
       
               # If the class attribute (which is the default value for this
               # field) exists and is of type 'Field', replace it with the
               # real default.  This is so that normal class introspection
               # sees a real default value, not a Field.
  365:         if isinstance(getattr(cls, f.name, None), Field):
   69:             if f.default is MISSING:
                       # If there's no default, delete the class attribute.
                       # This happens if we specify field(repr=False), for
                       # example (that is, we specified a field object, but
                       # no default value).  Also if we're using a default
                       # factory.  The class attribute should not be set at
                       # all in the post-processed class.
   67:                 delattr(cls, f.name)
                   else:
    2:                 setattr(cls, f.name, f.default)
       
           # Do we have any Field members that don't also have annotations?
  942:     for name, value in cls.__dict__.items():
  849:         if isinstance(value, Field) and not name in cls_annotations:
                   raise TypeError(f'{name!r} is a field but has no type annotation')
       
           # Check rules that apply if we are derived from any dataclasses.
   93:     if has_dataclass_bases:
               # Raise an exception if any of our bases are frozen, but we're not.
    3:         if any_frozen_base and not frozen:
                   raise TypeError('cannot inherit non-frozen dataclass from a '
                                   'frozen one')
       
               # Raise an exception if we're frozen, but none of our bases are.
    3:         if not any_frozen_base and frozen:
                   raise TypeError('cannot inherit frozen dataclass from a '
                                   'non-frozen one')
       
           # Remember all of the fields on our class (including bases).  This
           # also marks this class as being a dataclass.
   93:     setattr(cls, _FIELDS, fields)
       
           # Was this class defined with an explicit __hash__?  Note that if
           # __eq__ is defined in this class, then python will automatically
           # set __hash__ to None.  This is a heuristic, as it's possible
           # that such a __hash__ == None was not auto-generated, but it
           # close enough.
   93:     class_hash = cls.__dict__.get('__hash__', MISSING)
   93:     has_explicit_hash = not (class_hash is MISSING or
                                    (class_hash is None and '__eq__' in cls.__dict__))
       
           # If we're generating ordering methods, we must be generating the
           # eq methods.
   93:     if order and not eq:
               raise ValueError('eq must be true if order is true')
       
           # Include InitVars and regular fields (so, not ClassVars).  This is
           # initialized here, outside of the "if init:" test, because std_init_fields
           # is used with match_args, below.
  928:     all_init_fields = [f for f in fields.values()
  835:                        if f._field_type in (_FIELD, _FIELD_INITVAR)]
   93:     (std_init_fields,
  186:      kw_only_init_fields) = _fields_in_init_order(all_init_fields)
       
   93:     if init:
               # Does this class have a post-init function?
   93:         has_post_init = hasattr(cls, _POST_INIT_NAME)
       
  186:         _set_new_attribute(cls, '__init__',
  186:                            _init_fn(all_init_fields,
   93:                                     std_init_fields,
   93:                                     kw_only_init_fields,
   93:                                     frozen,
   93:                                     has_post_init,
                                           # The name to use for the "self"
                                           # param in __init__.  Use "self"
                                           # if possible.
   93:                                     '__dataclass_self__' if 'self' in fields
   93:                                             else 'self',
   93:                                     globals,
   93:                                     slots,
                                 ))
       
           # Get the fields as a list, and include only real fields.  This is
           # used in all of the following methods.
  557:     field_list = [f for f in fields.values() if f._field_type is _FIELD]
       
   93:     if repr:
  557:         flds = [f for f in field_list if f.repr]
   93:         _set_new_attribute(cls, '__repr__', _repr_fn(flds, globals))
       
   93:     if eq:
               # Create __eq__ method.  There's no need for a __ne__ method,
               # since python will call __eq__ and negate it.
  557:         flds = [f for f in field_list if f.compare]
   93:         self_tuple = _tuple_str('self', flds)
   93:         other_tuple = _tuple_str('other', flds)
  186:         _set_new_attribute(cls, '__eq__',
  186:                            _cmp_fn('__eq__', '==',
   93:                                    self_tuple, other_tuple,
   93:                                    globals=globals))
       
   93:     if order:
               # Create and set the ordering methods.
    4:         flds = [f for f in field_list if f.compare]
    1:         self_tuple = _tuple_str('self', flds)
    1:         other_tuple = _tuple_str('other', flds)
    5:         for name, op in [('__lt__', '<'),
                                ('__le__', '<='),
                                ('__gt__', '>'),
                                ('__ge__', '>='),
                                ]:
    8:             if _set_new_attribute(cls, name,
    8:                                   _cmp_fn(name, op, self_tuple, other_tuple,
    4:                                           globals=globals)):
                       raise TypeError(f'Cannot overwrite attribute {name} '
                                       f'in class {cls.__name__}. Consider using '
                                       'functools.total_ordering')
       
   93:     if frozen:
   69:         for fn in _frozen_get_del_attr(cls, field_list, globals):
   46:             if _set_new_attribute(cls, fn.__name__, fn):
                       raise TypeError(f'Cannot overwrite attribute {fn.__name__} '
                                       f'in class {cls.__name__}')
       
           # Decide if/how we're going to create a hash function.
  186:     hash_action = _hash_action[bool(unsafe_hash),
   93:                                bool(eq),
   93:                                bool(frozen),
   93:                                has_explicit_hash]
   93:     if hash_action:
               # No need to call _set_new_attribute here, since by the time
               # we're here the overwriting is unconditional.
   93:         cls.__hash__ = hash_action(cls, field_list, globals)
       
   93:     if not getattr(cls, '__doc__'):
               # Create a class doc-string.
   41:         try:
                   # In some cases fetching a signature is not possible.
                   # But, we surely should not fail in this case.
   41:             text_sig = str(inspect.signature(cls)).replace(' -> None', '')
               except (TypeError, ValueError):
                   text_sig = ''
   41:         cls.__doc__ = (cls.__name__ + text_sig)
       
   93:     if match_args:
               # I could probably compute this once
  186:         _set_new_attribute(cls, '__match_args__',
  555:                            tuple(f.name for f in std_init_fields))
       
           # It's an error to specify weakref_slot if slots is False.
   93:     if weakref_slot and not slots:
               raise TypeError('weakref_slot is True but slots is False')
   93:     if slots:
    9:         cls = _add_slots(cls, frozen, weakref_slot)
       
   93:     abc.update_abstractmethods(cls)
       
   93:     return cls
       
       
       # _dataclass_getstate and _dataclass_setstate are needed for pickling frozen
       # classes with slots.  These could be slightly more performant if we generated
       # the code instead of iterating over fields.  But that can be a project for
       # another day, if performance becomes an issue.
    1: def _dataclass_getstate(self):
           return [getattr(self, f.name) for f in fields(self)]
       
       
    1: def _dataclass_setstate(self, state):
           for field, value in zip(fields(self), state):
               # use setattr because dataclass may be frozen
               object.__setattr__(self, field.name, value)
       
       
    1: def _get_slots(cls):
           match cls.__dict__.get('__slots__'):
               case None:
                   return
               case str(slot):
                   yield slot
               # Slots may be any iterable, but we cannot handle an iterator
               # because it will already be (partially) consumed.
               case iterable if not hasattr(iterable, '__next__'):
                   yield from iterable
               case _:
                   raise TypeError(f"Slots of '{cls.__name__}' cannot be determined")
       
       
    1: def _add_slots(cls, is_frozen, weakref_slot):
           # Need to create a new class, since we can't set __slots__
           #  after a class has been created.
       
           # Make sure __slots__ isn't already set.
    9:     if '__slots__' in cls.__dict__:
               raise TypeError(f'{cls.__name__} already specifies __slots__')
       
           # Create a new dict for our new class.
    9:     cls_dict = dict(cls.__dict__)
  100:     field_names = tuple(f.name for f in fields(cls))
           # Make sure slots don't overlap with those in base classes.
   18:     inherited_slots = set(
    9:         itertools.chain.from_iterable(map(_get_slots, cls.__mro__[1:-1]))
           )
           # The slots for our class.  Remove slots from our base classes.  Add
           # '__weakref__' if weakref_slot was given, unless it is already present.
   18:     cls_dict["__slots__"] = tuple(
   18:         itertools.filterfalse(
    9:             inherited_slots.__contains__,
   18:             itertools.chain(
                       # gh-93521: '__weakref__' also needs to be filtered out if
                       # already present in inherited_slots
    9:                 field_names, ('__weakref__',) if weakref_slot else ()
                   )
               ),
           )
       
   91:     for field_name in field_names:
               # Remove our attributes, if present. They'll still be
               #  available in _MARKER.
   82:         cls_dict.pop(field_name, None)
       
           # Remove __dict__ itself.
    9:     cls_dict.pop('__dict__', None)
       
           # Clear existing `__weakref__` descriptor, it belongs to a previous type:
    9:     cls_dict.pop('__weakref__', None)  # gh-102069
       
           # And finally create the class.
    9:     qualname = getattr(cls, '__qualname__', None)
    9:     cls = type(cls)(cls.__name__, cls.__bases__, cls_dict)
    9:     if qualname is not None:
    9:         cls.__qualname__ = qualname
       
    9:     if is_frozen:
               # Need this for pickling frozen classes with slots.
               if '__getstate__' not in cls_dict:
                   cls.__getstate__ = _dataclass_getstate
               if '__setstate__' not in cls_dict:
                   cls.__setstate__ = _dataclass_setstate
       
    9:     return cls
       
       
    2: def dataclass(cls=None, /, *, init=True, repr=True, eq=True, order=False,
    1:               unsafe_hash=False, frozen=False, match_args=True,
    1:               kw_only=False, slots=False, weakref_slot=False):
           """Add dunder methods based on the fields defined in the class.
       
           Examines PEP 526 __annotations__ to determine fields.
       
           If init is true, an __init__() method is added to the class. If repr
           is true, a __repr__() method is added. If order is true, rich
           comparison dunder methods are added. If unsafe_hash is true, a
           __hash__() method is added. If frozen is true, fields may not be
           assigned to after instance creation. If match_args is true, the
           __match_args__ tuple is added. If kw_only is true, then by default
           all fields are keyword-only. If slots is true, a new class with a
           __slots__ attribute is returned.
           """
       
   93:     def wrap(cls):
  186:         return _process_class(cls, init, repr, eq, order, unsafe_hash,
   93:                               frozen, match_args, kw_only, slots,
   93:                               weakref_slot)
       
           # See if we're being called as @dataclass or @dataclass().
   93:     if cls is None:
               # We're called with parens.
   31:         return wrap
       
           # We're called as @dataclass without parens.
   62:     return wrap(cls)
       
       
    1: def fields(class_or_instance):
           """Return a tuple describing the fields of this dataclass.
       
           Accepts a dataclass or an instance of one. Tuple elements are of
           type Field.
           """
       
           # Might it be worth caching this, per class?
   52:     try:
   52:         fields = getattr(class_or_instance, _FIELDS)
           except AttributeError:
               raise TypeError('must be called with a dataclass type or instance') from None
       
           # Exclude pseudo-fields.  Note that fields is sorted by insertion
           # order, so the order of the tuple is as the fields were defined.
  496:     return tuple(f for f in fields.values() if f._field_type is _FIELD)
       
       
    1: def _is_dataclass_instance(obj):
           """Returns True if obj is an instance of a dataclass."""
 9350:     return hasattr(type(obj), _FIELDS)
       
       
    1: def is_dataclass(obj):
           """Returns True if obj is a dataclass or an instance of a
           dataclass."""
  753:     cls = obj if isinstance(obj, type) else type(obj)
  753:     return hasattr(cls, _FIELDS)
       
       
    1: def asdict(obj, *, dict_factory=dict):
           """Return the fields of a dataclass instance as a new dictionary mapping
           field names to field values.
       
           Example usage::
       
             @dataclass
             class C:
                 x: int
                 y: int
       
             c = C(1, 2)
             assert asdict(c) == {'x': 1, 'y': 2}
       
           If given, 'dict_factory' will be used instead of built-in dict.
           The function applies recursively to field values that are
           dataclass instances. This will also look into built-in containers:
           tuples, lists, and dicts.
           """
    4:     if not _is_dataclass_instance(obj):
               raise TypeError("asdict() should be called on dataclass instances")
    4:     return _asdict_inner(obj, dict_factory)
       
       
    1: def _asdict_inner(obj, dict_factory):
 9346:     if _is_dataclass_instance(obj):
   43:         result = []
  353:         for f in fields(obj):
  310:             value = _asdict_inner(getattr(obj, f.name), dict_factory)
  310:             result.append((f.name, value))
   43:         return dict_factory(result)
 9303:     elif isinstance(obj, tuple) and hasattr(obj, '_fields'):
               # obj is a namedtuple.  Recurse into it, but the returned
               # object is another namedtuple of the same type.  This is
               # similar to how other list- or tuple-derived classes are
               # treated (see below), but we just need to create them
               # differently because a namedtuple's __init__ needs to be
               # called differently (see bpo-34363).
       
               # I'm not using namedtuple's _asdict()
               # method, because:
               # - it does not recurse in to the namedtuple fields and
               #   convert them to dicts (using dict_factory).
               # - I don't actually want to return a dict here.  The main
               #   use case here is json.dumps, and it handles converting
               #   namedtuples to lists.  Admittedly we're losing some
               #   information here when we produce a json list instead of a
               #   dict.  Note that if we returned dicts here instead of
               #   namedtuples, we could no longer call asdict() on a data
               #   structure where a namedtuple was used as a dict key.
       
               return type(obj)(*[_asdict_inner(v, dict_factory) for v in obj])
 9303:     elif isinstance(obj, (list, tuple)):
               # Assume we can create an object of this type by passing in a
               # generator (which is not true for namedtuples, handled
               # above).
 9398:         return type(obj)(_asdict_inner(v, dict_factory) for v in obj)
 9102:     elif isinstance(obj, dict):
   75:         return type(obj)((_asdict_inner(k, dict_factory),
   18:                           _asdict_inner(v, dict_factory))
   25:                          for k, v in obj.items())
           else:
 9095:         return copy.deepcopy(obj)
       
       
    1: def astuple(obj, *, tuple_factory=tuple):
           """Return the fields of a dataclass instance as a new tuple of field values.
       
           Example usage::
       
             @dataclass
             class C:
                 x: int
                 y: int
       
             c = C(1, 2)
             assert astuple(c) == (1, 2)
       
           If given, 'tuple_factory' will be used instead of built-in tuple.
           The function applies recursively to field values that are
           dataclass instances. This will also look into built-in containers:
           tuples, lists, and dicts.
           """
       
           if not _is_dataclass_instance(obj):
               raise TypeError("astuple() should be called on dataclass instances")
           return _astuple_inner(obj, tuple_factory)
       
       
    1: def _astuple_inner(obj, tuple_factory):
           if _is_dataclass_instance(obj):
               result = []
               for f in fields(obj):
                   value = _astuple_inner(getattr(obj, f.name), tuple_factory)
                   result.append(value)
               return tuple_factory(result)
           elif isinstance(obj, tuple) and hasattr(obj, '_fields'):
               # obj is a namedtuple.  Recurse into it, but the returned
               # object is another namedtuple of the same type.  This is
               # similar to how other list- or tuple-derived classes are
               # treated (see below), but we just need to create them
               # differently because a namedtuple's __init__ needs to be
               # called differently (see bpo-34363).
               return type(obj)(*[_astuple_inner(v, tuple_factory) for v in obj])
           elif isinstance(obj, (list, tuple)):
               # Assume we can create an object of this type by passing in a
               # generator (which is not true for namedtuples, handled
               # above).
               return type(obj)(_astuple_inner(v, tuple_factory) for v in obj)
           elif isinstance(obj, dict):
               return type(obj)((_astuple_inner(k, tuple_factory), _astuple_inner(v, tuple_factory))
                                 for k, v in obj.items())
           else:
               return copy.deepcopy(obj)
       
       
    2: def make_dataclass(cls_name, fields, *, bases=(), namespace=None, init=True,
    1:                    repr=True, eq=True, order=False, unsafe_hash=False,
    1:                    frozen=False, match_args=True, kw_only=False, slots=False,
    1:                    weakref_slot=False):
           """Return a new dynamically created dataclass.
       
           The dataclass name will be 'cls_name'.  'fields' is an iterable
           of either (name), (name, type) or (name, type, Field) objects. If type is
           omitted, use the string 'typing.Any'.  Field objects are created by
           the equivalent of calling 'field(name, type [, Field-info])'.::
       
             C = make_dataclass('C', ['x', ('y', int), ('z', int, field(init=False))], bases=(Base,))
       
           is equivalent to::
       
             @dataclass
             class C(Base):
                 x: 'typing.Any'
                 y: int
                 z: int = field(init=False)
       
           For the bases and namespace parameters, see the builtin type() function.
       
           The parameters init, repr, eq, order, unsafe_hash, and frozen are passed to
           dataclass().
           """
       
    2:     if namespace is None:
    2:         namespace = {}
       
           # While we're looking through the field names, validate that they
           # are identifiers, are not keywords, and not duplicates.
    2:     seen = set()
    2:     annotations = {}
    2:     defaults = {}
   11:     for item in fields:
    9:         if isinstance(item, str):
    9:             name = item
    9:             tp = 'typing.Any'
               elif len(item) == 2:
                   name, tp, = item
               elif len(item) == 3:
                   name, tp, spec = item
                   defaults[name] = spec
               else:
                   raise TypeError(f'Invalid field: {item!r}')
       
    9:         if not isinstance(name, str) or not name.isidentifier():
                   raise TypeError(f'Field names must be valid identifiers: {name!r}')
    9:         if keyword.iskeyword(name):
                   raise TypeError(f'Field names must not be keywords: {name!r}')
    9:         if name in seen:
                   raise TypeError(f'Field name duplicated: {name!r}')
       
    9:         seen.add(name)
    9:         annotations[name] = tp
       
           # Update 'ns' with the user-supplied namespace plus our calculated values.
    2:     def exec_body_callback(ns):
    2:         ns.update(namespace)
    2:         ns.update(defaults)
    2:         ns['__annotations__'] = annotations
       
           # We use `types.new_class()` instead of simply `type()` to allow dynamic creation
           # of generic dataclasses.
    2:     cls = types.new_class(cls_name, bases, {}, exec_body_callback)
       
           # Apply the normal decorator.
    4:     return dataclass(cls, init=init, repr=repr, eq=eq, order=order,
    2:                      unsafe_hash=unsafe_hash, frozen=frozen,
    2:                      match_args=match_args, kw_only=kw_only, slots=slots,
    2:                      weakref_slot=weakref_slot)
       
       
    1: def replace(obj, /, **changes):
           """Return a new object replacing specified fields with new values.
       
           This is especially useful for frozen classes.  Example usage::
       
             @dataclass(frozen=True)
             class C:
                 x: int
                 y: int
       
             c = C(1, 2)
             c1 = replace(c, x=3)
             assert c1.x == 3 and c1.y == 2
           """
       
           # We're going to mutate 'changes', but that's okay because it's a
           # new dict, even if called with 'replace(obj, **my_changes)'.
       
           if not _is_dataclass_instance(obj):
               raise TypeError("replace() should be called on dataclass instances")
       
           # It's an error to have init=False fields in 'changes'.
           # If a field is not in 'changes', read its value from the provided obj.
       
           for f in getattr(obj, _FIELDS).values():
               # Only consider normal fields or InitVars.
               if f._field_type is _FIELD_CLASSVAR:
                   continue
       
               if not f.init:
                   # Error if this field is specified in changes.
                   if f.name in changes:
                       raise ValueError(f'field {f.name} is declared with '
                                        'init=False, it cannot be specified with '
                                        'replace()')
                   continue
       
               if f.name not in changes:
                   if f._field_type is _FIELD_INITVAR and f.default is MISSING:
                       raise ValueError(f"InitVar {f.name!r} "
                                        'must be specified with replace()')
                   changes[f.name] = getattr(obj, f.name)
       
           # Create the new object, which calls __init__() and
           # __post_init__() (if defined), using all of the init fields we've
           # added and/or left in 'changes'.  If there are values supplied in
           # changes that aren't fields, this will correctly raise a
           # TypeError.
           return obj.__class__(**changes)
