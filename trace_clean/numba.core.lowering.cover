    1: from collections import namedtuple, defaultdict
    1: import operator
    1: import warnings
    1: from functools import partial
       
    1: import llvmlite.ir
    1: from llvmlite.ir import Constant, IRBuilder
       
    1: from numba.core import (typing, utils, types, ir, debuginfo, funcdesc,
                               generators, config, ir_utils, cgutils, removerefctpass,
                               targetconfig)
    1: from numba.core.errors import (LoweringError, new_error_context, TypingError,
                                      LiteralTypingError, UnsupportedError,
                                      NumbaDebugInfoWarning)
    1: from numba.core.funcdesc import default_mangler
    1: from numba.core.environment import Environment
    1: from numba.core.analysis import compute_use_defs, must_use_alloca
    1: from numba.misc.firstlinefinder import get_func_body_first_lineno
       
       
    1: _VarArgItem = namedtuple("_VarArgItem", ("vararg", "index"))
       
       
    2: class BaseLower(object):
    1:     """
           Lower IR to LLVM
           """
       
    1:     def __init__(self, context, library, fndesc, func_ir, metadata=None):
   24:         self.library = library
   24:         self.fndesc = fndesc
   24:         self.blocks = utils.SortedMap(func_ir.blocks.items())
   24:         self.func_ir = func_ir
   24:         self.generator_info = func_ir.generator_info
   24:         self.metadata = metadata
   24:         self.flags = targetconfig.ConfigStack.top_or_none()
       
               # Initialize LLVM
   24:         self.module = self.library.create_ir_module(self.fndesc.unique_name)
       
               # Python execution environment (will be available to the compiled
               # function).
   24:         self.env = Environment.from_fndesc(self.fndesc)
       
               # Internal states
   24:         self.blkmap = {}
   24:         self.pending_phis = {}
   24:         self.varmap = {}
   24:         self.firstblk = min(self.blocks.keys())
   24:         self.loc = -1
       
               # Specializes the target context as seen inside the Lowerer
               # This adds:
               #  - environment: the python execution environment
   48:         self.context = context.subtarget(environment=self.env,
   24:                                          fndesc=self.fndesc)
       
               # Debuginfo
   48:         dibuildercls = (self.context.DIBuilder
   24:                         if self.context.enable_debuginfo
   24:                         else debuginfo.DummyDIBuilder)
       
               # debuginfo def location
   24:         self.defn_loc = self._compute_def_location()
       
   24:         directives_only = self.flags.dbg_directives_only
   48:         self.debuginfo = dibuildercls(module=self.module,
   24:                                       filepath=func_ir.loc.filename,
   24:                                       cgctx=context,
   24:                                       directives_only=directives_only)
       
               # Subclass initialization
   24:         self.init()
       
    2:     @property
    2:     def call_conv(self):
   83:         return self.context.call_conv
       
    1:     def init(self):
   24:         pass
       
    1:     def init_pyapi(self):
               """
               Init the Python API and Environment Manager for the function being
               lowered.
               """
               if self.pyapi is not None:
                   return
               self.pyapi = self.context.get_python_api(self.builder)
       
               # Store environment argument for later use
               self.env_manager = self.context.get_env_manager(self.builder)
               self.env_body = self.env_manager.env_body
               self.envarg = self.env_manager.env_ptr
       
    1:     def _compute_def_location(self):
               # Debuginfo requires source to be accurate. Find it and warn if not
               # found. If it's not found, use the func_ir line + 1, this assumes that
               # the function definition is decorated with a 1 line jit decorator.
   24:         defn_loc = self.func_ir.loc.with_lineno(self.func_ir.loc.line + 1)
   24:         if self.context.enable_debuginfo:
                   fn = self.func_ir.func_id.func
                   optional_lno = get_func_body_first_lineno(fn)
                   if optional_lno is not None:
                       # -1 as lines start at 1 and this is an offset.
                       offset = optional_lno - 1
                       defn_loc = self.func_ir.loc.with_lineno(offset)
                   else:
                       msg = ("Could not find source for function: "
                              f"{self.func_ir.func_id.func}. Debug line information "
                              "may be inaccurate.")
                       warnings.warn(NumbaDebugInfoWarning(msg))
   24:         return defn_loc
       
    1:     def pre_lower(self):
               """
               Called before lowering all blocks.
               """
               # A given Lower object can be used for several LL functions
               # (for generators) and it's important to use a new API and
               # EnvironmentManager.
   24:         self.pyapi = None
   48:         self.debuginfo.mark_subprogram(function=self.builder.function,
   24:                                        qualname=self.fndesc.qualname,
   24:                                        argnames=self.fndesc.args,
   24:                                        argtypes=self.fndesc.argtypes,
   24:                                        line=self.defn_loc.line)
       
               # When full debug info is enabled, disable inlining where possible, to
               # improve the quality of the debug experience. 'alwaysinline' functions
               # cannot have inlining disabled.
   24:         attributes = self.builder.function.attributes
   24:         full_debug = self.flags.debuginfo and not self.flags.dbg_directives_only
   24:         if full_debug and 'alwaysinline' not in attributes:
                   attributes.add('noinline')
       
    1:     def post_lower(self):
               """
               Called after all blocks are lowered
               """
   24:         self.debuginfo.finalize()
       
   96:     def pre_block(self, block):
               """
               Called before lowering a block.
               """
       
    1:     def post_block(self, block):
               """
               Called after lowering a block.
               """
       
    1:     def return_dynamic_exception(self, exc_class, exc_args, nb_types, loc=None):
               self.call_conv.return_dynamic_user_exc(
                   self.builder, exc_class, exc_args, nb_types,
                   loc=loc, func_name=self.func_ir.func_id.func_name,
               )
       
    1:     def return_exception(self, exc_class, exc_args=None, loc=None):
               """Propagate exception to the caller.
               """
    2:         self.call_conv.return_user_exc(
    1:             self.builder, exc_class, exc_args,
    1:             loc=loc, func_name=self.func_ir.func_id.func_name,
               )
       
    1:     def set_exception(self, exc_class, exc_args=None, loc=None):
               """Set exception state in the current function.
               """
               self.call_conv.set_static_user_exc(
                   self.builder, exc_class, exc_args,
                   loc=loc, func_name=self.func_ir.func_id.func_name,
               )
       
    1:     def emit_environment_object(self):
               """Emit a pointer to hold the Environment object.
               """
               # Define global for the environment and initialize it to NULL
   24:         envname = self.context.get_env_name(self.fndesc)
   24:         self.context.declare_env_global(self.module, envname)
       
    1:     def lower(self):
               # Emit the Env into the module
   24:         self.emit_environment_object()
   24:         if self.generator_info is None:
   24:             self.genlower = None
   24:             self.lower_normal_function(self.fndesc)
               else:
                   self.genlower = self.GeneratorLower(self)
                   self.gentype = self.genlower.gentype
       
                   self.genlower.lower_init_func(self)
                   self.genlower.lower_next_func(self)
                   if self.gentype.has_finalizer:
                       self.genlower.lower_finalize_func(self)
       
   24:         if config.DUMP_LLVM:
                   utils.dump_llvm(self.fndesc, self.module)
       
               # Special optimization to remove NRT on functions that do not need it.
   24:         if self.context.enable_nrt and self.generator_info is None:
   48:             removerefctpass.remove_unnecessary_nrt_usage(self.function,
   24:                                                          context=self.context,
   24:                                                          fndesc=self.fndesc)
       
               # Run target specific post lowering transformation
   24:         self.context.post_lowering(self.module, self.library)
       
               # Materialize LLVM Module
   24:         self.library.add_ir_module(self.module)
       
    1:     def extract_function_arguments(self):
   48:         self.fnargs = self.call_conv.decode_arguments(self.builder,
   24:                                                       self.fndesc.argtypes,
   24:                                                       self.function)
   24:         return self.fnargs
       
    1:     def lower_normal_function(self, fndesc):
               """
               Lower non-generator *fndesc*.
               """
   24:         self.setup_function(fndesc)
       
               # Init argument values
   24:         self.extract_function_arguments()
   24:         entry_block_tail = self.lower_function_body()
       
               # Close tail of entry block, do not emit debug metadata else the
               # unconditional jump gets associated with the metadata from the function
               # body end.
   48:         with debuginfo.suspend_emission(self.builder):
   24:             self.builder.position_at_end(entry_block_tail)
   24:             self.builder.branch(self.blkmap[self.firstblk])
       
    1:     def lower_function_body(self):
               """
               Lower the current function's body, and return the entry block.
               """
               # Init Python blocks
  119:         for offset in self.blocks:
   95:             bname = "B%s" % offset
   95:             self.blkmap[offset] = self.function.append_basic_block(bname)
       
   24:         self.pre_lower()
               # pre_lower() may have changed the current basic block
   24:         entry_block_tail = self.builder.basic_block
       
   48:         self.debug_print("# function begin: {0}".format(
   24:             self.fndesc.unique_name))
       
               # Lower all blocks
  119:         for offset, block in sorted(self.blocks.items()):
   95:             bb = self.blkmap[offset]
   95:             self.builder.position_at_end(bb)
   95:             self.debug_print(f"# lower block: {offset}")
   95:             self.lower_block(block)
   24:         self.post_lower()
   24:         return entry_block_tail
       
    1:     def lower_block(self, block):
               """
               Lower the given block.
               """
   95:         self.pre_block(block)
 1354:         for inst in block.body:
 1259:             self.loc = inst.loc
 1259:             defaulterrcls = partial(LoweringError, loc=self.loc)
 3777:             with new_error_context('lowering "{inst}" at {loc}', inst=inst,
 1259:                                    loc=self.loc, errcls_=defaulterrcls):
 1259:                 self.lower_inst(inst)
   95:         self.post_block(block)
       
    1:     def create_cpython_wrapper(self, release_gil=False):
               """
               Create CPython wrapper(s) around this function (or generator).
               """
    2:         if self.genlower:
                   self.context.create_cpython_wrapper(self.library,
                                                       self.genlower.gendesc,
                                                       self.env, self.call_helper,
                                                       release_gil=release_gil)
    4:         self.context.create_cpython_wrapper(self.library, self.fndesc,
    2:                                             self.env, self.call_helper,
    2:                                             release_gil=release_gil)
       
    1:     def create_cfunc_wrapper(self):
               """
               Create C wrapper around this function.
               """
   11:         if self.genlower:
                   raise UnsupportedError('generator as a first-class function type')
   22:         self.context.create_cfunc_wrapper(self.library, self.fndesc,
   11:                                           self.env, self.call_helper)
       
    1:     def setup_function(self, fndesc):
               # Setup function
   24:         self.function = self.context.declare_function(self.module, fndesc)
   24:         if self.flags.dbg_optnone:
                   attrset = self.function.attributes
                   if "alwaysinline" not in attrset:
                       attrset.add("optnone")
                       attrset.add("noinline")
   24:         self.entry_block = self.function.append_basic_block('entry')
   24:         self.builder = IRBuilder(self.entry_block)
   24:         self.call_helper = self.call_conv.init_call_helper(self.builder)
       
    1:     def typeof(self, varname):
 2442:         return self.fndesc.typemap[varname]
       
    1:     def debug_print(self, msg):
 1666:         if config.DEBUG_JIT:
                   self.context.debug_print(
                       self.builder, f"DEBUGJIT [{self.fndesc.qualname}]: {msg}")
       
    1:     def print_variable(self, msg, varname):
               """Helper to emit ``print(msg, varname)`` for debugging.
       
               Parameters
               ----------
               msg : str
                   Literal string to be printed.
               varname : str
                   A variable name whose value will be printed.
               """
               argtys = (
                   types.literal(msg),
                   self.fndesc.typemap[varname]
               )
               args = (
                   self.context.get_dummy_value(),
                   self.loadvar(varname),
               )
               sig = typing.signature(types.none, *argtys)
       
               impl = self.context.get_function(print, sig)
               impl(self.builder, args)
       
       
    2: class Lower(BaseLower):
    1:     GeneratorLower = generators.GeneratorLower
       
    1:     def init(self):
   24:         super().init()
               # find all singly assigned variables
   24:         self._find_singly_assigned_variable()
       
    2:     @property
    2:     def _disable_sroa_like_opt(self):
               """Flags that the SROA like optimisation that Numba performs (which
               prevent alloca and subsequent load/store for locals) should be disabled.
               Currently, this is conditional solely on the presence of a request for
               the emission of debug information."""
 2863:         if self.flags is None:
                   return False
       
 2863:         return self.flags.debuginfo and not self.flags.dbg_directives_only
       
    1:     def _find_singly_assigned_variable(self):
   24:         func_ir = self.func_ir
   24:         blocks = func_ir.blocks
       
   24:         sav = set()
       
   24:         if not self.func_ir.func_id.is_generator:
   24:             use_defs = compute_use_defs(blocks)
   24:             alloca_vars = must_use_alloca(blocks)
       
                   # Compute where variables are defined
   24:             var_assign_map = defaultdict(set)
  119:             for blk, vl in use_defs.defmap.items():
  656:                 for var in vl:
  561:                     var_assign_map[var].add(blk)
       
                   # Compute where variables are used
   24:             var_use_map = defaultdict(set)
  119:             for blk, vl in use_defs.usemap.items():
  218:                 for var in vl:
  123:                     var_use_map[var].add(blk)
       
                   # Keep only variables that are defined locally and used locally
  568:             for var in var_assign_map:
  544:                 if var not in alloca_vars and len(var_assign_map[var]) == 1:
                           # Usemap does not keep locally defined variables.
  527:                     if len(var_use_map[var]) == 0:
                               # Ensure that the variable is not defined multiple times
                               # in the block
  477:                         [defblk] = var_assign_map[var]
  477:                         assign_stmts = self.blocks[defblk].find_insts(ir.Assign)
 6748:                         assigns = [stmt for stmt in assign_stmts
 6271:                                    if stmt.target.name == var]
  477:                         if len(assigns) == 1:
  477:                             sav.add(var)
       
   24:         self._singly_assigned_vars = sav
   24:         self._blk_local_varmap = {}
       
    1:     def pre_block(self, block):
   95:         from numba.core.unsafe import eh
       
   95:         super(Lower, self).pre_block(block)
   95:         self._cur_ir_block = block
       
   95:         if block == self.firstblk:
                   # create slots for all the vars, irrespective of whether they are
                   # initialized, SSA will pick this up and warn users about using
                   # uninitialized variables. Slots are added as alloca in the first
                   # block
                   bb = self.blkmap[self.firstblk]
                   self.builder.position_at_end(bb)
                   all_names = set()
                   for block in self.blocks.values():
                       for x in block.find_insts(ir.Del):
                           if x.value not in all_names:
                               all_names.add(x.value)
                   for name in all_names:
                       fetype = self.typeof(name)
                       self._alloca_var(name, fetype)
       
               # Detect if we are in a TRY block by looking for a call to
               # `eh.exception_check`.
  191:         for call in block.find_exprs(op='call'):
  192:             defn = ir_utils.guard(
   96:                 ir_utils.get_definition, self.func_ir, call.func,
                   )
   96:             if defn is not None and isinstance(defn, ir.Global):
   57:                 if defn.value is eh.exception_check:
                           if isinstance(block.terminator, ir.Branch):
                               targetblk = self.blkmap[block.terminator.truebr]
                               # NOTE: This hacks in an attribute for call_conv to
                               #       pick up. This hack is no longer needed when
                               #       all old-style implementations are gone.
                               self.builder._in_try_block = {'target': targetblk}
                               break
       
    1:     def post_block(self, block):
               # Clean-up
   95:         try:
   95:             del self.builder._in_try_block
   95:         except AttributeError:
   95:             pass
       
    1:     def lower_inst(self, inst):
               # Set debug location for all subsequent LL instructions
 1259:         self.debuginfo.mark_location(self.builder, self.loc.line)
 1259:         self.debug_print(str(inst))
 1259:         if isinstance(inst, ir.Assign):
  561:             ty = self.typeof(inst.target.name)
  561:             val = self.lower_assign(ty, inst)
  561:             argidx = None
                   # If this is a store from an arg, like x = arg.x then tell debuginfo
                   # that this is the arg
  561:             if isinstance(inst.value, ir.Arg):
                       # NOTE: debug location is the `def <func>` line
   55:                 self.debuginfo.mark_location(self.builder, self.defn_loc.line)
   55:                 argidx = inst.value.index + 1 # args start at 1
  561:             self.storevar(val, inst.target.name, argidx=argidx)
       
  698:         elif isinstance(inst, ir.Branch):
   32:             cond = self.loadvar(inst.cond.name)
   32:             tr = self.blkmap[inst.truebr]
   32:             fl = self.blkmap[inst.falsebr]
       
   32:             condty = self.typeof(inst.cond.name)
   32:             pred = self.context.cast(self.builder, cond, condty, types.boolean)
   32:             assert pred.type == llvmlite.ir.IntType(1),\
                       ("cond is not i1: %s" % pred.type)
   32:             self.builder.cbranch(pred, tr, fl)
       
  666:         elif isinstance(inst, ir.Jump):
   28:             target = self.blkmap[inst.target]
   28:             self.builder.branch(target)
       
  638:         elif isinstance(inst, ir.Return):
   34:             if self.generator_info:
                       # StopIteration
                       self.genlower.return_from_generator(self)
                       return
   34:             val = self.loadvar(inst.value.name)
   34:             oty = self.typeof(inst.value.name)
   34:             ty = self.fndesc.restype
   34:             if isinstance(ty, types.Optional):
                       # If returning an optional type
                       self.call_conv.return_optional_value(self.builder, ty, oty, val)
                       return
   34:             assert ty == oty, (
                       "type '{}' does not match return type '{}'".format(oty, ty))
   34:             retval = self.context.get_return_value(self.builder, ty, val)
   34:             self.call_conv.return_value(self.builder, retval)
       
  604:         elif isinstance(inst, ir.PopBlock):
                   pass # this is just a marker
       
  604:         elif isinstance(inst, ir.StaticSetItem):
                   signature = self.fndesc.calltypes[inst]
                   assert signature is not None
                   try:
                       impl = self.context.get_function('static_setitem', signature)
                   except NotImplementedError:
                       return self.lower_setitem(inst.target, inst.index_var,
                                                 inst.value, signature)
                   else:
                       target = self.loadvar(inst.target.name)
                       value = self.loadvar(inst.value.name)
                       valuety = self.typeof(inst.value.name)
                       value = self.context.cast(self.builder, value, valuety,
                                                 signature.args[2])
                       return impl(self.builder, (target, inst.index, value))
       
  604:         elif isinstance(inst, ir.Print):
                   self.lower_print(inst)
       
  604:         elif isinstance(inst, ir.SetItem):
    6:             signature = self.fndesc.calltypes[inst]
    6:             assert signature is not None
   12:             return self.lower_setitem(inst.target, inst.index, inst.value,
    6:                                       signature)
       
  598:         elif isinstance(inst, ir.StoreMap):
                   signature = self.fndesc.calltypes[inst]
                   assert signature is not None
                   return self.lower_setitem(inst.dct, inst.key, inst.value, signature)
       
  598:         elif isinstance(inst, ir.DelItem):
                   target = self.loadvar(inst.target.name)
                   index = self.loadvar(inst.index.name)
       
                   targetty = self.typeof(inst.target.name)
                   indexty = self.typeof(inst.index.name)
       
                   signature = self.fndesc.calltypes[inst]
                   assert signature is not None
       
                   op = operator.delitem
                   fnop = self.context.typing_context.resolve_value_type(op)
                   callsig = fnop.get_call_type(
                       self.context.typing_context, signature.args, {},
                   )
                   impl = self.context.get_function(fnop, callsig)
       
                   assert targetty == signature.args[0]
                   index = self.context.cast(self.builder, index, indexty,
                                             signature.args[1])
       
                   return impl(self.builder, (target, index))
       
  598:         elif isinstance(inst, ir.Del):
  597:             self.delvar(inst.value)
       
    1:         elif isinstance(inst, ir.SetAttr):
                   target = self.loadvar(inst.target.name)
                   value = self.loadvar(inst.value.name)
                   signature = self.fndesc.calltypes[inst]
       
                   targetty = self.typeof(inst.target.name)
                   valuety = self.typeof(inst.value.name)
                   assert signature is not None
                   assert signature.args[0] == targetty
                   impl = self.context.get_setattr(inst.attr, signature)
       
                   # Convert argument to match
                   value = self.context.cast(self.builder, value, valuety,
                                             signature.args[1])
       
                   return impl(self.builder, (target, value))
       
    1:         elif isinstance(inst, ir.DynamicRaise):
                   self.lower_dynamic_raise(inst)
       
    1:         elif isinstance(inst, ir.DynamicTryRaise):
                   self.lower_try_dynamic_raise(inst)
       
    1:         elif isinstance(inst, ir.StaticRaise):
    1:             self.lower_static_raise(inst)
       
               elif isinstance(inst, ir.StaticTryRaise):
                   self.lower_static_try_raise(inst)
       
               else:
                   raise NotImplementedError(type(inst))
       
    1:     def lower_setitem(self, target_var, index_var, value_var, signature):
    6:         target = self.loadvar(target_var.name)
    6:         value = self.loadvar(value_var.name)
    6:         index = self.loadvar(index_var.name)
       
    6:         targetty = self.typeof(target_var.name)
    6:         valuety = self.typeof(value_var.name)
    6:         indexty = self.typeof(index_var.name)
       
    6:         op = operator.setitem
    6:         fnop = self.context.typing_context.resolve_value_type(op)
   12:         callsig = fnop.get_call_type(
    6:             self.context.typing_context, signature.args, {},
               )
    6:         impl = self.context.get_function(fnop, callsig)
       
               # Convert argument to match
    6:         if isinstance(targetty, types.Optional):
                   target = self.context.cast(self.builder, target, targetty,
                                              targetty.type)
               else:
    6:             ul = types.unliteral
    6:             assert ul(targetty) == ul(signature.args[0])
       
   12:         index = self.context.cast(self.builder, index, indexty,
    6:                                   signature.args[1])
   12:         value = self.context.cast(self.builder, value, valuety,
    6:                                   signature.args[2])
       
    6:         return impl(self.builder, (target, index, value))
       
    1:     def lower_try_dynamic_raise(self, inst):
               # Numba is a bit limited in what it can do with exceptions in a try
               # block. Thus, it is safe to use the same code as the static try raise.
               self.lower_static_try_raise(inst)
       
    1:     def lower_dynamic_raise(self, inst):
               exc_args = inst.exc_args
               args = []
               nb_types = []
               for exc_arg in exc_args:
                   if isinstance(exc_arg, ir.Var):
                       # dynamic values
                       typ = self.typeof(exc_arg.name)
                       val = self.loadvar(exc_arg.name)
                       self.incref(typ, val)
                   else:
                       typ = None
                       val = exc_arg
                   nb_types.append(typ)
                   args.append(val)
       
               self.return_dynamic_exception(inst.exc_class, tuple(args),
                                             tuple(nb_types), loc=self.loc)
       
    1:     def lower_static_raise(self, inst):
    1:         if inst.exc_class is None:
                   # Reraise
                   self.return_exception(None, loc=self.loc)
               else:
    1:             self.return_exception(inst.exc_class, inst.exc_args, loc=self.loc)
       
    1:     def lower_static_try_raise(self, inst):
               if inst.exc_class is None:
                   # Reraise
                   self.set_exception(None, loc=self.loc)
               else:
                   self.set_exception(inst.exc_class, inst.exc_args, loc=self.loc)
       
    1:     def lower_assign(self, ty, inst):
  561:         value = inst.value
               # In nopython mode, closure vars are frozen like globals
  561:         if isinstance(value, (ir.Const, ir.Global, ir.FreeVar)):
  306:             res = self.context.get_constant_generic(self.builder, ty,
  153:                                                     value.value)
  153:             self.incref(ty, res)
  153:             return res
       
  408:         elif isinstance(value, ir.Expr):
  296:             return self.lower_expr(ty, value)
       
  112:         elif isinstance(value, ir.Var):
   57:             val = self.loadvar(value.name)
   57:             oty = self.typeof(value.name)
   57:             res = self.context.cast(self.builder, val, oty, ty)
   57:             self.incref(ty, res)
   57:             return res
       
   55:         elif isinstance(value, ir.Arg):
                   # Suspend debug info else all the arg repacking ends up being
                   # associated with some line or other and it's actually just a detail
                   # of Numba's CC.
  110:             with debuginfo.suspend_emission(self.builder):
                       # Cast from the argument type to the local variable type
                       # (note the "arg.FOO" convention as used in typeinfer)
   55:                 argty = self.typeof("arg." + value.name)
   55:                 if isinstance(argty, types.Omitted):
    7:                     pyval = argty.value
    7:                     tyctx = self.context.typing_context
    7:                     valty = tyctx.resolve_value_type_prefer_literal(pyval)
                           # use the type of the constant value
   14:                     const = self.context.get_constant_generic(
    7:                         self.builder, valty, pyval,
                           )
                           # cast it to the variable type
    7:                     res = self.context.cast(self.builder, const, valty, ty)
                       else:
   48:                     val = self.fnargs[value.index]
   48:                     res = self.context.cast(self.builder, val, argty, ty)
   55:                 self.incref(ty, res)
   55:                 return res
       
               elif isinstance(value, ir.Yield):
                   res = self.lower_yield(ty, value)
                   self.incref(ty, res)
                   return res
       
               raise NotImplementedError(type(value), value)
       
    1:     def lower_yield(self, retty, inst):
               yp = self.generator_info.yield_points[inst.index]
               assert yp.inst is inst
               y = generators.LowerYield(self, yp, yp.live_vars)
               y.lower_yield_suspend()
               # Yield to caller
               val = self.loadvar(inst.value.name)
               typ = self.typeof(inst.value.name)
               actual_rettyp = self.gentype.yield_type
       
               # cast the local val to the type yielded
               yret = self.context.cast(self.builder, val, typ, actual_rettyp)
       
               # get the return repr of yielded value
               retval = self.context.get_return_value(
                   self.builder, actual_rettyp, yret,
               )
       
               # return
               self.call_conv.return_value(self.builder, retval)
       
               # Resumption point
               y.lower_yield_resume()
               # None is returned by the yield expression
               return self.context.get_constant_generic(self.builder, retty, None)
       
    1:     def lower_binop(self, resty, expr, op):
               # if op in utils.OPERATORS_TO_BUILTINS:
               # map operator.the_op => the corresponding types.Function()
               # TODO: is this looks dodgy ...
   52:         op = self.context.typing_context.resolve_value_type(op)
       
   52:         lhs = expr.lhs
   52:         rhs = expr.rhs
   52:         static_lhs = expr.static_lhs
   52:         static_rhs = expr.static_rhs
   52:         lty = self.typeof(lhs.name)
   52:         rty = self.typeof(rhs.name)
   52:         lhs = self.loadvar(lhs.name)
   52:         rhs = self.loadvar(rhs.name)
       
               # Convert argument to match
   52:         signature = self.fndesc.calltypes[expr]
   52:         lhs = self.context.cast(self.builder, lhs, lty, signature.args[0])
   52:         rhs = self.context.cast(self.builder, rhs, rty, signature.args[1])
       
   52:         def cast_result(res):
  104:             return self.context.cast(self.builder, res,
   52:                                      signature.return_type, resty)
       
               # First try with static operands, if known
   52:         def try_static_impl(tys, args):
  364:             if any(a is ir.UNDEFINED for a in args):
  156:                 return None
                   try:
                       if isinstance(op, types.Function):
                           static_sig = op.get_call_type(self.context.typing_context,
                                                         tys, {})
                       else:
                           static_sig = typing.signature(signature.return_type, *tys)
                   except TypingError:
                       return None
                   try:
                       static_impl = self.context.get_function(op, static_sig)
                       return static_impl(self.builder, args)
                   except NotImplementedError:
                       return None
       
  104:         res = try_static_impl(
   52:             (_lit_or_omitted(static_lhs), _lit_or_omitted(static_rhs)),
   52:             (static_lhs, static_rhs),
               )
   52:         if res is not None:
                   return cast_result(res)
       
  104:         res = try_static_impl(
   52:             (_lit_or_omitted(static_lhs), rty),
   52:             (static_lhs, rhs),
               )
   52:         if res is not None:
                   return cast_result(res)
       
  104:         res = try_static_impl(
   52:             (lty, _lit_or_omitted(static_rhs)),
   52:             (lhs, static_rhs),
               )
   52:         if res is not None:
                   return cast_result(res)
       
               # Normal implementation for generic arguments
       
   52:         sig = op.get_call_type(self.context.typing_context, signature.args, {})
   52:         impl = self.context.get_function(op, sig)
   52:         res = impl(self.builder, (lhs, rhs))
   52:         return cast_result(res)
       
    1:     def lower_getitem(self, resty, expr, value, index, signature):
   14:         baseval = self.loadvar(value.name)
   14:         indexval = self.loadvar(index.name)
               # Get implementation of getitem
   14:         op = operator.getitem
   14:         fnop = self.context.typing_context.resolve_value_type(op)
   28:         callsig = fnop.get_call_type(
   14:             self.context.typing_context, signature.args, {},
               )
   14:         impl = self.context.get_function(fnop, callsig)
       
   14:         argvals = (baseval, indexval)
   28:         argtyps = (self.typeof(value.name),
   14:                    self.typeof(index.name))
   98:         castvals = [self.context.cast(self.builder, av, at, ft)
   56:                     for av, at, ft in zip(argvals, argtyps,
   14:                                           signature.args)]
   14:         res = impl(self.builder, castvals)
   28:         return self.context.cast(self.builder, res,
   14:                                  signature.return_type,
   14:                                  resty)
       
    1:     def _cast_var(self, var, ty):
               """
               Cast a Numba IR variable to the given Numba type, returning a
               low-level value.
               """
  137:         if isinstance(var, _VarArgItem):
   15:             varty = self.typeof(var.vararg.name)[var.index]
   30:             val = self.builder.extract_value(self.loadvar(var.vararg.name),
   15:                                              var.index)
               else:
  122:             varty = self.typeof(var.name)
  122:             val = self.loadvar(var.name)
  137:         return self.context.cast(self.builder, val, varty, ty)
       
    1:     def fold_call_args(self, fnty, signature, pos_args, vararg, kw_args):
   96:         if vararg:
                   # Inject *args from function call
                   # The lowering will be done in _cast_var() above.
    1:             tp_vararg = self.typeof(vararg.name)
    1:             assert isinstance(tp_vararg, types.BaseTuple)
   33:             pos_args = pos_args + [_VarArgItem(vararg, i)
   16:                                    for i in range(len(tp_vararg))]
       
               # Fold keyword arguments and resolve default argument values
   96:         pysig = signature.pysig
   96:         if pysig is None:
   64:             if kw_args:
                       raise NotImplementedError("unsupported keyword arguments "
                                                 "when calling %s" % (fnty,))
  350:             argvals = [self._cast_var(var, sigty)
  143:                        for var, sigty in zip(pos_args, signature.args)]
               else:
   32:             def normal_handler(index, param, var):
   58:                 return self._cast_var(var, signature.args[index])
       
   32:             def default_handler(index, param, default):
   28:                 return self.context.get_constant_generic(
   14:                     self.builder, signature.args[index], default)
       
   32:             def stararg_handler(index, param, vars):
                       stararg_ty = signature.args[index]
                       assert isinstance(stararg_ty, types.BaseTuple), stararg_ty
                       values = [self._cast_var(var, sigty)
                                 for var, sigty in zip(vars, stararg_ty)]
                       return cgutils.make_anonymous_struct(self.builder, values)
       
   64:             argvals = typing.fold_arguments(pysig,
   32:                                             pos_args, dict(kw_args),
   32:                                             normal_handler,
   32:                                             default_handler,
   32:                                             stararg_handler)
   96:         return argvals
       
    1:     def lower_print(self, inst):
               """
               Lower a ir.Print()
               """
               # We handle this, as far as possible, as a normal call to built-in
               # print().  This will make it easy to undo the special ir.Print
               # rewrite when it becomes unnecessary (e.g. when we have native
               # strings).
               sig = self.fndesc.calltypes[inst]
               assert sig.return_type == types.none
               fnty = self.context.typing_context.resolve_value_type(print)
       
               # Fix the call signature to inject any constant-inferred
               # string argument
               pos_tys = list(sig.args)
               pos_args = list(inst.args)
               for i in range(len(pos_args)):
                   if i in inst.consts:
                       pyval = inst.consts[i]
                       if isinstance(pyval, str):
                           pos_tys[i] = types.literal(pyval)
       
               fixed_sig = typing.signature(sig.return_type, *pos_tys)
               fixed_sig = fixed_sig.replace(pysig=sig.pysig)
       
               argvals = self.fold_call_args(fnty, sig, pos_args, inst.vararg, {})
               impl = self.context.get_function(print, fixed_sig)
               impl(self.builder, argvals)
       
    1:     def lower_call(self, resty, expr):
   96:         signature = self.fndesc.calltypes[expr]
   96:         self.debug_print("# lower_call: expr = {0}".format(expr))
   96:         if isinstance(signature.return_type, types.Phantom):
                   return self.context.get_dummy_value()
       
   96:         fnty = self.typeof(expr.func.name)
       
   96:         if isinstance(fnty, types.ObjModeDispatcher):
                   res = self._lower_call_ObjModeDispatcher(fnty, expr, signature)
       
   96:         elif isinstance(fnty, types.ExternalFunction):
                   res = self._lower_call_ExternalFunction(fnty, expr, signature)
       
   96:         elif isinstance(fnty, types.ExternalFunctionPointer):
                   res = self._lower_call_ExternalFunctionPointer(
                       fnty, expr, signature)
       
   96:         elif isinstance(fnty, types.RecursiveCall):
                   res = self._lower_call_RecursiveCall(fnty, expr, signature)
       
   96:         elif isinstance(fnty, types.FunctionType):
                   res = self._lower_call_FunctionType(fnty, expr, signature)
       
               else:
   96:             res = self._lower_call_normal(fnty, expr, signature)
       
               # If lowering the call returned None, interpret that as returning dummy
               # value if the return type of the function is void, otherwise there is
               # a problem
   96:         if res is None:
    1:             if signature.return_type == types.void:
    1:                 res = self.context.get_dummy_value()
                   else:
                       raise LoweringError(
                           msg="non-void function returns None from implementation",
                           loc=self.loc
                       )
       
  192:         return self.context.cast(self.builder, res, signature.return_type,
   96:                                  resty)
       
    1:     def _lower_call_ObjModeDispatcher(self, fnty, expr, signature):
               from numba.core.pythonapi import ObjModeUtils
       
               self.init_pyapi()
               # Acquire the GIL
               gil_state = self.pyapi.gil_ensure()
               # Fix types
               argnames = [a.name for a in expr.args]
               argtypes = [self.typeof(a) for a in argnames]
               argvalues = [self.loadvar(a) for a in argnames]
               for v, ty in zip(argvalues, argtypes):
                   # Because .from_native_value steal the reference
                   self.incref(ty, v)
       
               argobjs = [self.pyapi.from_native_value(atyp, aval,
                                                       self.env_manager)
                          for atyp, aval in zip(argtypes, argvalues)]
       
               # Load objmode dispatcher
               callee = ObjModeUtils(self.pyapi).load_dispatcher(fnty, argtypes)
               # Make Call
               ret_obj = self.pyapi.call_function_objargs(callee, argobjs)
               has_exception = cgutils.is_null(self.builder, ret_obj)
               with self. builder.if_else(has_exception) as (then, orelse):
                   # Handles exception
                   # This branch must exit the function
                   with then:
                       # Clean arg
                       for obj in argobjs:
                           self.pyapi.decref(obj)
       
                       # Release the GIL
                       self.pyapi.gil_release(gil_state)
       
                       # Return and signal exception
                       self.call_conv.return_exc(self.builder)
       
                   # Handles normal return
                   with orelse:
                       # Fix output value
                       native = self.pyapi.to_native_value(
                           fnty.dispatcher.output_types,
                           ret_obj,
                       )
                       output = native.value
       
                       # Release objs
                       self.pyapi.decref(ret_obj)
                       for obj in argobjs:
                           self.pyapi.decref(obj)
       
                       # cleanup output
                       if callable(native.cleanup):
                           native.cleanup()
       
                       # Release the GIL
                       self.pyapi.gil_release(gil_state)
       
                       # Error during unboxing
                       with self.builder.if_then(native.is_error):
                           self.call_conv.return_exc(self.builder)
       
                       return output
       
    1:     def _lower_call_ExternalFunction(self, fnty, expr, signature):
               # Handle a named external function
               self.debug_print("# external function")
               argvals = self.fold_call_args(
                   fnty, signature, expr.args, expr.vararg, expr.kws,
               )
               fndesc = funcdesc.ExternalFunctionDescriptor(
                   fnty.symbol, fnty.sig.return_type, fnty.sig.args)
               func = self.context.declare_external_function(
                   self.builder.module, fndesc)
               return self.context.call_external_function(
                   self.builder, func, fndesc.argtypes, argvals,
               )
       
    1:     def _lower_call_ExternalFunctionPointer(self, fnty, expr, signature):
               # Handle a C function pointer
               self.debug_print("# calling external function pointer")
               argvals = self.fold_call_args(
                   fnty, signature, expr.args, expr.vararg, expr.kws,
               )
               pointer = self.loadvar(expr.func.name)
               # If the external function pointer uses libpython
               if fnty.requires_gil:
                   self.init_pyapi()
                   # Acquire the GIL
                   gil_state = self.pyapi.gil_ensure()
                   # Make PyObjects
                   newargvals = []
                   pyvals = []
                   for exptyp, gottyp, aval in zip(fnty.sig.args, signature.args,
                                                   argvals):
                       # Adjust argument values to pyobjects
                       if exptyp == types.ffi_forced_object:
                           self.incref(gottyp, aval)
                           obj = self.pyapi.from_native_value(
                               gottyp, aval, self.env_manager,
                           )
                           newargvals.append(obj)
                           pyvals.append(obj)
                       else:
                           newargvals.append(aval)
       
                   # Call external function
                   res = self.context.call_function_pointer(
                       self.builder, pointer, newargvals, fnty.cconv,
                   )
                   # Release PyObjects
                   for obj in pyvals:
                       self.pyapi.decref(obj)
       
                   # Release the GIL
                   self.pyapi.gil_release(gil_state)
               # If the external function pointer does NOT use libpython
               else:
                   res = self.context.call_function_pointer(
                       self.builder, pointer, argvals, fnty.cconv,
                   )
               return res
       
    1:     def _lower_call_RecursiveCall(self, fnty, expr, signature):
               # Recursive call
               argvals = self.fold_call_args(
                   fnty, signature, expr.args, expr.vararg, expr.kws,
               )
               rec_ov = fnty.get_overloads(signature.args)
               mangler = self.context.mangler or default_mangler
               abi_tags = self.fndesc.abi_tags
               mangled_name = mangler(rec_ov.qualname, signature.args,
                                      abi_tags=abi_tags, uid=rec_ov.uid)
               # special case self recursion
               if self.builder.function.name.startswith(mangled_name):
                   res = self.context.call_internal(
                       self.builder, self.fndesc, signature, argvals,
                   )
               else:
                   res = self.context.call_unresolved(
                       self.builder, mangled_name, signature, argvals,
                   )
               return res
       
    1:     def _lower_call_FunctionType(self, fnty, expr, signature):
               self.debug_print("# calling first-class function type")
               sig = types.unliteral(signature)
               if not fnty.check_signature(signature):
                   # value dependent polymorphism?
                   raise UnsupportedError(
                       f'mismatch of function types:'
                       f' expected {fnty} but got {types.FunctionType(sig)}')
               ftype = fnty.ftype
               argvals = self.fold_call_args(
                   fnty, sig, expr.args, expr.vararg, expr.kws,
               )
               func_ptr = self.__get_function_pointer(ftype, expr.func.name, sig=sig)
               res = self.builder.call(func_ptr, argvals, cconv=fnty.cconv)
               return res
       
    1:     def __get_function_pointer(self, ftype, fname, sig=None):
               from numba.experimental.function_type import lower_get_wrapper_address
       
               llty = self.context.get_value_type(ftype)
               fstruct = self.loadvar(fname)
               addr = self.builder.extract_value(fstruct, 0,
                                                 name='addr_of_%s' % (fname))
       
               fptr = cgutils.alloca_once(self.builder, llty,
                                          name="fptr_of_%s" % (fname))
               with self.builder.if_else(
                       cgutils.is_null(self.builder, addr),
                       likely=False) as (then, orelse):
                   with then:
                       self.init_pyapi()
                       # Acquire the GIL
                       gil_state = self.pyapi.gil_ensure()
                       pyaddr = self.builder.extract_value(
                           fstruct, 1,
                           name='pyaddr_of_%s' % (fname))
                       # try to recover the function address, see
                       # test_zero_address BadToGood example in
                       # test_function_type.py
                       addr1 = lower_get_wrapper_address(
                           self.context, self.builder, pyaddr, sig,
                           failure_mode='ignore')
                       with self.builder.if_then(
                               cgutils.is_null(self.builder, addr1), likely=False):
                           self.return_exception(
                               RuntimeError,
                               exc_args=(f"{ftype} function address is null",),
                               loc=self.loc)
                       addr2 = self.pyapi.long_as_voidptr(addr1)
                       self.builder.store(self.builder.bitcast(addr2, llty), fptr)
                       self.pyapi.decref(addr1)
                       self.pyapi.gil_release(gil_state)
                   with orelse:
                       self.builder.store(self.builder.bitcast(addr, llty), fptr)
               return self.builder.load(fptr)
       
    1:     def _lower_call_normal(self, fnty, expr, signature):
               # Normal function resolution
   96:         self.debug_print("# calling normal function: {0}".format(fnty))
   96:         self.debug_print("# signature: {0}".format(signature))
   96:         if isinstance(fnty, types.ObjModeDispatcher):
                   argvals = expr.func.args
               else:
  192:             argvals = self.fold_call_args(
   96:                 fnty, signature, expr.args, expr.vararg, expr.kws,
                   )
   96:         tname = expr.target
   96:         if tname is not None:
                   from numba.core.target_extension import resolve_dispatcher_from_str
                   disp = resolve_dispatcher_from_str(tname)
                   hw_ctx = disp.targetdescr.target_context
                   impl = hw_ctx.get_function(fnty, signature)
               else:
   96:             impl = self.context.get_function(fnty, signature)
   96:         if signature.recvr:
                   # The "self" object is passed as the function object
                   # for bounded function
    2:             the_self = self.loadvar(expr.func.name)
                   # Prepend the self reference
    2:             argvals = [the_self] + list(argvals)
       
   96:         res = impl(self.builder, argvals, self.loc)
   96:         return res
       
    1:     def lower_expr(self, resty, expr):
  296:         if expr.op == 'binop':
   47:             return self.lower_binop(resty, expr, expr.fn)
  249:         elif expr.op == 'inplace_binop':
    5:             lty = self.typeof(expr.lhs.name)
    5:             if lty.mutable:
                       return self.lower_binop(resty, expr, expr.fn)
                   else:
                       # inplace operators on non-mutable types reuse the same
                       # definition as the corresponding copying operators.)
    5:                 return self.lower_binop(resty, expr, expr.immutable_fn)
  244:         elif expr.op == 'unary':
    4:             val = self.loadvar(expr.value.name)
    4:             typ = self.typeof(expr.value.name)
    4:             func_ty = self.context.typing_context.resolve_value_type(expr.fn)
                   # Get function
    4:             signature = self.fndesc.calltypes[expr]
    4:             impl = self.context.get_function(func_ty, signature)
                   # Convert argument to match
    4:             val = self.context.cast(self.builder, val, typ, signature.args[0])
    4:             res = impl(self.builder, [val])
    8:             res = self.context.cast(self.builder, res,
    4:                                     signature.return_type, resty)
    4:             return res
       
  240:         elif expr.op == 'call':
   96:             res = self.lower_call(resty, expr)
   96:             return res
       
  144:         elif expr.op == 'pair_first':
    5:             val = self.loadvar(expr.value.name)
    5:             ty = self.typeof(expr.value.name)
    5:             res = self.context.pair_first(self.builder, val, ty)
    5:             self.incref(resty, res)
    5:             return res
       
  139:         elif expr.op == 'pair_second':
    5:             val = self.loadvar(expr.value.name)
    5:             ty = self.typeof(expr.value.name)
    5:             res = self.context.pair_second(self.builder, val, ty)
    5:             self.incref(resty, res)
    5:             return res
       
  134:         elif expr.op in ('getiter', 'iternext'):
   10:             val = self.loadvar(expr.value.name)
   10:             ty = self.typeof(expr.value.name)
   10:             signature = self.fndesc.calltypes[expr]
   10:             impl = self.context.get_function(expr.op, signature)
   10:             [fty] = signature.args
   10:             castval = self.context.cast(self.builder, val, ty, fty)
   10:             res = impl(self.builder, (castval,))
   20:             res = self.context.cast(self.builder, res, signature.return_type,
   10:                                     resty)
   10:             return res
       
  124:         elif expr.op == 'exhaust_iter':
                   val = self.loadvar(expr.value.name)
                   ty = self.typeof(expr.value.name)
                   # Unpack optional
                   if isinstance(ty, types.Optional):
                       val = self.context.cast(self.builder, val, ty, ty.type)
                       ty = ty.type
       
                   # If we have a tuple, we needn't do anything
                   # (and we can't iterate over the heterogeneous ones).
                   if isinstance(ty, types.BaseTuple):
                       assert ty == resty
                       self.incref(ty, val)
                       return val
       
                   itemty = ty.iterator_type.yield_type
                   tup = self.context.get_constant_undef(resty)
                   pairty = types.Pair(itemty, types.boolean)
                   getiter_sig = typing.signature(ty.iterator_type, ty)
                   getiter_impl = self.context.get_function('getiter',
                                                            getiter_sig)
                   iternext_sig = typing.signature(pairty, ty.iterator_type)
                   iternext_impl = self.context.get_function('iternext',
                                                             iternext_sig)
                   iterobj = getiter_impl(self.builder, (val,))
                   # We call iternext() as many times as desired (`expr.count`).
                   for i in range(expr.count):
                       pair = iternext_impl(self.builder, (iterobj,))
                       is_valid = self.context.pair_second(self.builder,
                                                           pair, pairty)
                       with cgutils.if_unlikely(self.builder,
                                                self.builder.not_(is_valid)):
                           self.return_exception(ValueError, loc=self.loc)
                       item = self.context.pair_first(self.builder,
                                                      pair, pairty)
                       tup = self.builder.insert_value(tup, item, i)
       
                   # Call iternext() once more to check that the iterator
                   # is exhausted.
                   pair = iternext_impl(self.builder, (iterobj,))
                   is_valid = self.context.pair_second(self.builder,
                                                       pair, pairty)
                   with cgutils.if_unlikely(self.builder, is_valid):
                       self.return_exception(ValueError, loc=self.loc)
       
                   self.decref(ty.iterator_type, iterobj)
                   return tup
       
  124:         elif expr.op == "getattr":
   50:             val = self.loadvar(expr.value.name)
   50:             ty = self.typeof(expr.value.name)
       
   50:             if isinstance(resty, types.BoundFunction):
                       # if we are getting out a method, assume we have typed this
                       # properly and just build a bound function object
    2:                 casted = self.context.cast(self.builder, val, ty, resty.this)
    4:                 res = self.context.get_bound_function(self.builder, casted,
    2:                                                       resty.this)
    2:                 self.incref(resty, res)
    2:                 return res
                   else:
   48:                 impl = self.context.get_getattr(ty, expr.attr)
   96:                 attrty = self.context.typing_context.resolve_getattr(ty,
   48:                                                                      expr.attr)
       
   48:                 if impl is None:
                           # ignore the attribute
   31:                     return self.context.get_dummy_value()
                       else:
   17:                     res = impl(self.context, self.builder, ty, val, expr.attr)
       
                       # Cast the attribute type to the expected output type
   17:                 res = self.context.cast(self.builder, res, attrty, resty)
   17:                 return res
       
   74:         elif expr.op == "static_getitem":
   16:             signature = typing.signature(
    8:                 resty,
    8:                 self.typeof(expr.value.name),
    8:                 _lit_or_omitted(expr.index),
                   )
    8:             try:
                       # Both get_function() and the returned implementation can
                       # raise NotImplementedError if the types aren't supported
    8:                 impl = self.context.get_function("static_getitem", signature)
   12:                 return impl(self.builder,
    6:                             (self.loadvar(expr.value.name), expr.index))
    2:             except NotImplementedError:
    2:                 if expr.index_var is None:
                           raise
                       # Fall back on the generic getitem() implementation
                       # for this type.
    2:                 signature = self.fndesc.calltypes[expr]
    4:                 return self.lower_getitem(resty, expr, expr.value,
    2:                                           expr.index_var, signature)
   66:         elif expr.op == "typed_getitem":
                   signature = typing.signature(
                       resty,
                       self.typeof(expr.value.name),
                       self.typeof(expr.index.name),
                   )
                   impl = self.context.get_function("typed_getitem", signature)
                   return impl(self.builder, (self.loadvar(expr.value.name),
                               self.loadvar(expr.index.name)))
   66:         elif expr.op == "getitem":
   12:             signature = self.fndesc.calltypes[expr]
   24:             return self.lower_getitem(resty, expr, expr.value, expr.index,
   12:                                       signature)
       
   54:         elif expr.op == "build_tuple":
   64:             itemvals = [self.loadvar(i.name) for i in expr.items]
   64:             itemtys = [self.typeof(i.name) for i in expr.items]
  112:             castvals = [self.context.cast(self.builder, val, fromty, toty)
   48:                         for val, toty, fromty in zip(itemvals, resty, itemtys)]
   16:             tup = self.context.make_tuple(self.builder, resty, castvals)
   16:             self.incref(resty, tup)
   16:             return tup
       
   38:         elif expr.op == "build_list":
                   itemvals = [self.loadvar(i.name) for i in expr.items]
                   itemtys = [self.typeof(i.name) for i in expr.items]
                   if isinstance(resty, types.LiteralList):
                       castvals = [self.context.cast(self.builder, val, fromty, toty)
                                   for val, toty, fromty in zip(itemvals, resty.types,
                                                                itemtys)]
                       tup = self.context.make_tuple(self.builder,
                                                     types.Tuple(resty.types),
                                                     castvals)
                       self.incref(resty, tup)
                       return tup
                   else:
                       castvals = [self.context.cast(self.builder, val, fromty,
                                                     resty.dtype)
                                   for val, fromty in zip(itemvals, itemtys)]
                       return self.context.build_list(self.builder, resty, castvals)
       
   38:         elif expr.op == "build_set":
                   # Insert in reverse order, as Python does
                   items = expr.items[::-1]
                   itemvals = [self.loadvar(i.name) for i in items]
                   itemtys = [self.typeof(i.name) for i in items]
                   castvals = [self.context.cast(self.builder, val, fromty,
                                                 resty.dtype)
                               for val, fromty in zip(itemvals, itemtys)]
                   return self.context.build_set(self.builder, resty, castvals)
       
   38:         elif expr.op == "build_map":
                   items = expr.items
                   keys, values = [], []
                   key_types, value_types = [], []
                   for k, v in items:
                       key = self.loadvar(k.name)
                       keytype = self.typeof(k.name)
                       val = self.loadvar(v.name)
                       valtype = self.typeof(v.name)
                       keys.append(key)
                       values.append(val)
                       key_types.append(keytype)
                       value_types.append(valtype)
                   return self.context.build_map(self.builder, resty,
                                                 list(zip(key_types, value_types)),
                                                 list(zip(keys, values)))
       
   38:         elif expr.op == "cast":
   34:             val = self.loadvar(expr.value.name)
   34:             ty = self.typeof(expr.value.name)
   34:             castval = self.context.cast(self.builder, val, ty, resty)
   34:             self.incref(resty, castval)
   34:             return castval
       
    4:         elif expr.op == "phi":
                   raise LoweringError("PHI not stripped")
       
    4:         elif expr.op == 'null':
                   return self.context.get_constant_null(resty)
       
    4:         elif expr.op == 'undef':
                   # Numba does not raise an UnboundLocalError for undefined variables.
                   # The variable is set to zero.
                   return self.context.get_constant_null(resty)
       
    4:         elif expr.op in self.context.special_ops:
    4:             res = self.context.special_ops[expr.op](self, expr)
    4:             return res
       
               raise NotImplementedError(expr)
       
    1:     def _alloca_var(self, name, fetype):
               """
               Ensure the given variable has an allocated stack slot (if needed).
               """
 1158:         if name in self.varmap:
                   # quit early
  143:             return
       
               # If the name is used in multiple blocks or lowering with debuginfo...
 1961:         if ((name not in self._singly_assigned_vars) or
  946:                 self._disable_sroa_like_opt):
                   # If not already defined, allocate it
   69:             ptr = self.alloca(name, fetype)
                   # Remember the pointer
   69:             self.varmap[name] = ptr
       
    1:     def getvar(self, name):
               """
               Get a pointer to the given variable's slot.
               """
  450:         if not self._disable_sroa_like_opt:
  450:             assert name not in self._blk_local_varmap
  450:             assert name not in self._singly_assigned_vars
  450:         if name not in self.varmap:
                   # Allocate undefined variable as needed.
                   # NOTE: Py3.12 use of LOAD_FAST_AND_CLEAR will allow variable be
                   # referenced before it is defined.
                   self._alloca_var(name, self.typeof(name))
  450:         return self.varmap[name]
       
    1:     def loadvar(self, name):
               """
               Load the given variable's value.
               """
  633:         if name in self._blk_local_varmap and not self._disable_sroa_like_opt:
  395:             return self._blk_local_varmap[name]
  238:         ptr = self.getvar(name)
       
               # Don't associate debuginfo with the load for a function arg else it
               # creates instructions ahead of the first source line of the
               # function which then causes problems with breaking on the function
               # symbol (it hits the symbol, not the first line).
  238:         if name in self.func_ir.arg_names:
  122:             with debuginfo.suspend_emission(self.builder):
   61:                 return self.builder.load(ptr)
               else:
  177:             return self.builder.load(ptr)
       
    1:     def storevar(self, value, name, argidx=None):
               """
               Store the value into the given variable.
               """
  561:         fetype = self.typeof(name)
               # Define if not already
  561:         self._alloca_var(name, fetype)
       
               # Store variable
 1036:         if (name in self._singly_assigned_vars and
  475:                 not self._disable_sroa_like_opt):
  475:             self._blk_local_varmap[name] = value
               else:
   86:             if argidx is None:
                       # Clean up existing value stored in the variable, not needed
                       # if it's an arg
   67:                 old = self.loadvar(name)
   67:                 self.decref(fetype, old)
       
                   # stack stored variable
   86:             ptr = self.getvar(name)
   86:             if value.type != ptr.type.pointee:
                       msg = ("Storing {value.type} to ptr of {ptr.type.pointee} "
                              "('{name}'). FE type {fetype}").format(value=value,
                                                                     ptr=ptr,
                                                                     fetype=fetype,
                                                                     name=name)
                       raise AssertionError(msg)
       
                   # If this store is associated with an argument to the function (i.e.
                   # store following reassemble from CC splatting structs as many args
                   # to the function) then mark this variable as such.
   86:             if argidx is not None:
   38:                 with debuginfo.suspend_emission(self.builder):
   19:                     self.builder.store(value, ptr)
   19:                 loc = self.defn_loc # the line with `def <func>`
   19:                 lltype = self.context.get_value_type(fetype)
   19:                 sizeof = self.context.get_abi_sizeof(lltype)
   19:                 datamodel = self.context.data_model_manager[fetype]
   38:                 self.debuginfo.mark_variable(self.builder, ptr, name=name,
   19:                                              lltype=lltype, size=sizeof,
   19:                                              line=loc.line, datamodel=datamodel,
   19:                                              argidx=argidx)
                   else:
   67:                 self.builder.store(value, ptr)
       
    1:     def delvar(self, name):
               """
               Delete the given variable.
               """
  597:         fetype = self.typeof(name)
       
               # Out-of-order
  723:         if (name not in self._blk_local_varmap and
  126:                 not self._disable_sroa_like_opt):
  126:             if name in self._singly_assigned_vars:
    2:                 self._singly_assigned_vars.discard(name)
       
               # Define if not already (may happen if the variable is deleted
               # at the beginning of a loop, but only set later in the loop)
  597:         self._alloca_var(name, fetype)
       
  597:         if name in self._blk_local_varmap and not self._disable_sroa_like_opt:
  471:             llval = self._blk_local_varmap[name]
  471:             self.decref(fetype, llval)
               else:
  126:             ptr = self.getvar(name)
  126:             self.decref(fetype, self.builder.load(ptr))
                   # Zero-fill variable to avoid double frees on subsequent dels
  126:             self.builder.store(Constant(ptr.type.pointee, None), ptr)
       
    1:     def alloca(self, name, type):
   69:         lltype = self.context.get_value_type(type)
   69:         datamodel = self.context.data_model_manager[type]
   69:         return self.alloca_lltype(name, lltype, datamodel=datamodel)
       
    1:     def alloca_lltype(self, name, lltype, datamodel=None):
               # Is user variable?
   69:         is_uservar = not name.startswith('$')
               # Allocate space for variable
  138:         aptr = cgutils.alloca_once(self.builder, lltype,
   69:                                    name=name, zfill=False)
       
               # Emit debug info for user variable
   69:         if is_uservar:
                   # Don't associate debuginfo with the alloca for a function arg, this
                   # is handled by the first store to the alloca so that repacking the
                   # splatted args from the CC is dealt with.
   56:             if name not in self.func_ir.arg_names:
   37:                 sizeof = self.context.get_abi_sizeof(lltype)
   74:                 self.debuginfo.mark_variable(self.builder, aptr, name=name,
   37:                                              lltype=lltype, size=sizeof,
   37:                                              line=self.loc.line,
   37:                                              datamodel=datamodel,)
   69:         return aptr
       
    1:     def incref(self, typ, val):
  327:         if not self.context.enable_nrt:
                   return
       
  327:         self.context.nrt.incref(self.builder, typ, val)
       
    1:     def decref(self, typ, val):
  664:         if not self.context.enable_nrt:
                   return
       
               # do not associate decref with "use", it creates "jumpy" line info as
               # the decrefs are usually where the ir.Del nodes are, which is at the
               # end of the block.
 1328:         with debuginfo.suspend_emission(self.builder):
  664:             self.context.nrt.decref(self.builder, typ, val)
       
       
    1: def _lit_or_omitted(value):
           """Returns a Literal instance if the type of value is supported;
           otherwise, return `Omitted(value)`.
           """
  216:     try:
  216:         return types.literal(value)
  208:     except LiteralTypingError:
  208:         return types.Omitted(value)
