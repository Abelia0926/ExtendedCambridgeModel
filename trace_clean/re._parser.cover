       #
       # Secret Labs' Regular Expression Engine
       #
       # convert re-style regular expression to sre pattern
       #
       # Copyright (c) 1998-2001 by Secret Labs AB.  All rights reserved.
       #
       # See the __init__.py file for information on usage and redistribution.
       #
       
       """Internal support module for sre"""
       
       # XXX: show string offset and offending character for all errors
       
       from ._constants import *
       
       SPECIAL_CHARS = ".\\[{()*+?^$|"
       REPEAT_CHARS = "*+?{"
       
       DIGITS = frozenset("0123456789")
       
       OCTDIGITS = frozenset("01234567")
       HEXDIGITS = frozenset("0123456789abcdefABCDEF")
       ASCIILETTERS = frozenset("abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ")
       
       WHITESPACE = frozenset(" \t\n\r\v\f")
       
       _REPEATCODES = frozenset({MIN_REPEAT, MAX_REPEAT, POSSESSIVE_REPEAT})
       _UNITCODES = frozenset({ANY, RANGE, IN, LITERAL, NOT_LITERAL, CATEGORY})
       
       ESCAPES = {
           r"\a": (LITERAL, ord("\a")),
           r"\b": (LITERAL, ord("\b")),
           r"\f": (LITERAL, ord("\f")),
           r"\n": (LITERAL, ord("\n")),
           r"\r": (LITERAL, ord("\r")),
           r"\t": (LITERAL, ord("\t")),
           r"\v": (LITERAL, ord("\v")),
           r"\\": (LITERAL, ord("\\"))
       }
       
       CATEGORIES = {
           r"\A": (AT, AT_BEGINNING_STRING), # start of string
           r"\b": (AT, AT_BOUNDARY),
           r"\B": (AT, AT_NON_BOUNDARY),
           r"\d": (IN, [(CATEGORY, CATEGORY_DIGIT)]),
           r"\D": (IN, [(CATEGORY, CATEGORY_NOT_DIGIT)]),
           r"\s": (IN, [(CATEGORY, CATEGORY_SPACE)]),
           r"\S": (IN, [(CATEGORY, CATEGORY_NOT_SPACE)]),
           r"\w": (IN, [(CATEGORY, CATEGORY_WORD)]),
           r"\W": (IN, [(CATEGORY, CATEGORY_NOT_WORD)]),
           r"\Z": (AT, AT_END_STRING), # end of string
       }
       
       FLAGS = {
           # standard flags
           "i": SRE_FLAG_IGNORECASE,
           "L": SRE_FLAG_LOCALE,
           "m": SRE_FLAG_MULTILINE,
           "s": SRE_FLAG_DOTALL,
           "x": SRE_FLAG_VERBOSE,
           # extensions
           "a": SRE_FLAG_ASCII,
           "t": SRE_FLAG_TEMPLATE,
           "u": SRE_FLAG_UNICODE,
       }
       
       TYPE_FLAGS = SRE_FLAG_ASCII | SRE_FLAG_LOCALE | SRE_FLAG_UNICODE
       GLOBAL_FLAGS = SRE_FLAG_DEBUG | SRE_FLAG_TEMPLATE
       
       class State:
           # keeps track of state for parsing
           def __init__(self):
  358:         self.flags = 0
  358:         self.groupdict = {}
  358:         self.groupwidths = [None]  # group 0
  358:         self.lookbehindgroups = None
  358:         self.grouprefpos = {}
           @property
           def groups(self):
 1545:         return len(self.groupwidths)
           def opengroup(self, name=None):
  411:         gid = self.groups
  411:         self.groupwidths.append(None)
  411:         if self.groups > MAXGROUPS:
                   raise error("too many groups")
  411:         if name is not None:
  105:             ogid = self.groupdict.get(name, None)
  105:             if ogid is not None:
                       raise error("redefinition of group name %r as group %d; "
                                   "was group %d" % (name, gid,  ogid))
  105:             self.groupdict[name] = gid
  411:         return gid
           def closegroup(self, gid, p):
  411:         self.groupwidths[gid] = p.getwidth()
           def checkgroup(self, gid):
    1:         return gid < self.groups and self.groupwidths[gid] is not None
       
           def checklookbehindgroup(self, gid, source):
    1:         if self.lookbehindgroups is not None:
                   if not self.checkgroup(gid):
                       raise source.error('cannot refer to an open group')
                   if gid >= self.lookbehindgroups:
                       raise source.error('cannot refer to group defined in the same '
                                          'lookbehind subpattern')
       
       class SubPattern:
           # a subpattern, in intermediate form
           def __init__(self, state, data=None):
 2220:         self.state = state
 2220:         if data is None:
 1203:             data = []
 2220:         self.data = data
 2220:         self.width = None
       
           def dump(self, level=0):
               nl = True
               seqtypes = (tuple, list)
               for op, av in self.data:
                   print(level*"  " + str(op), end='')
                   if op is IN:
                       # member sublanguage
                       print()
                       for op, a in av:
                           print((level+1)*"  " + str(op), a)
                   elif op is BRANCH:
                       print()
                       for i, a in enumerate(av[1]):
                           if i:
                               print(level*"  " + "OR")
                           a.dump(level+1)
                   elif op is GROUPREF_EXISTS:
                       condgroup, item_yes, item_no = av
                       print('', condgroup)
                       item_yes.dump(level+1)
                       if item_no:
                           print(level*"  " + "ELSE")
                           item_no.dump(level+1)
                   elif isinstance(av, seqtypes):
                       nl = False
                       for a in av:
                           if isinstance(a, SubPattern):
                               if not nl:
                                   print()
                               a.dump(level+1)
                               nl = True
                           else:
                               if not nl:
                                   print(' ', end='')
                               print(a, end='')
                               nl = False
                       if not nl:
                           print()
                   else:
                       print('', av)
           def __repr__(self):
               return repr(self.data)
           def __len__(self):
 4755:         return len(self.data)
           def __delitem__(self, index):
   18:         del self.data[index]
           def __getitem__(self, index):
14922:         if isinstance(index, slice):
 1017:             return SubPattern(self.state, self.data[index])
13905:         return self.data[index]
           def __setitem__(self, index, code):
 1065:         self.data[index] = code
           def insert(self, index, code):
               self.data.insert(index, code)
           def append(self, code):
 4887:         self.data.append(code)
           def getwidth(self):
               # determine the width (min, max) for this subpattern
 2501:         if self.width is not None:
  411:             return self.width
 2090:         lo = hi = 0
 7836:         for op, av in self.data:
 5746:             if op is BRANCH:
   95:                 i = MAXREPEAT - 1
   95:                 j = 0
  391:                 for av in av[1]:
  296:                     l, h = av.getwidth()
  296:                     i = min(i, l)
  296:                     j = max(j, h)
   95:                 lo = lo + i
   95:                 hi = hi + j
 5651:             elif op is ATOMIC_GROUP:
                       i, j = av.getwidth()
                       lo = lo + i
                       hi = hi + j
 5651:             elif op is SUBPATTERN:
  415:                 i, j = av[-1].getwidth()
  415:                 lo = lo + i
  415:                 hi = hi + j
 5236:             elif op in _REPEATCODES:
 1015:                 i, j = av[2].getwidth()
 1015:                 lo = lo + i * av[0]
 1015:                 hi = hi + j * av[1]
 4221:             elif op in _UNITCODES:
 3918:                 lo = lo + 1
 3918:                 hi = hi + 1
  303:             elif op is GROUPREF:
    1:                 i, j = self.state.groupwidths[av]
    1:                 lo = lo + i
    1:                 hi = hi + j
  302:             elif op is GROUPREF_EXISTS:
                       i, j = av[1].getwidth()
                       if av[2] is not None:
                           l, h = av[2].getwidth()
                           i = min(i, l)
                           j = max(j, h)
                       else:
                           i = 0
                       lo = lo + i
                       hi = hi + j
  302:             elif op is SUCCESS:
                       break
 2090:         self.width = min(lo, MAXREPEAT - 1), min(hi, MAXREPEAT)
 2090:         return self.width
       
       class Tokenizer:
           def __init__(self, string):
  361:         self.istext = isinstance(string, str)
  361:         self.string = string
  361:         if not self.istext:
    7:             string = str(string, 'latin1')
  361:         self.decoded_string = string
  361:         self.index = 0
  361:         self.next = None
  361:         self.__next()
           def __next(self):
13710:         index = self.index
13710:         try:
13710:             char = self.decoded_string[index]
  364:         except IndexError:
  364:             self.next = None
  364:             return
13346:         if char == "\\":
  852:             index += 1
  852:             try:
  852:                 char += self.decoded_string[index]
                   except IndexError:
                       raise error("bad escape (end of pattern)",
                                   self.string, len(self.string) - 1) from None
13346:         self.index = index + 1
13346:         self.next = char
           def match(self, char):
 5957:         if char == self.next:
 1704:             self.__next()
 1704:             return True
 4253:         return False
           def get(self):
10869:         this = self.next
10869:         self.__next()
10869:         return this
           def getwhile(self, n, charset):
   40:         result = ''
  120:         for _ in range(n):
   80:             c = self.next
   80:             if c not in charset:
                       break
   80:             result += c
   80:             self.__next()
   40:         return result
           def getuntil(self, terminator, name):
  106:         result = ''
  693:         while True:
  693:             c = self.next
  693:             self.__next()
  693:             if c is None:
                       if not result:
                           raise self.error("missing " + name)
                       raise self.error("missing %s, unterminated name" % terminator,
                                        len(result))
  693:             if c == terminator:
  106:                 if not result:
                           raise self.error("missing " + name, 1)
  106:                 break
  587:             result += c
  106:         return result
           @property
           def pos(self):
               return self.index - len(self.next or '')
           def tell(self):
 2984:         return self.index - len(self.next or '')
           def seek(self, index):
    3:         self.index = index
    3:         self.__next()
       
           def error(self, msg, offset=0):
               if not self.istext:
                   msg = msg.encode('ascii', 'backslashreplace').decode('ascii')
               return error(msg, self.string, self.tell() - offset)
       
           def checkgroupname(self, name, offset, nested):
  106:         if not name.isidentifier():
                   msg = "bad character in group name %r" % name
                   raise self.error(msg, len(name) + offset)
  106:         if not (self.istext or name.isascii()):
                   import warnings
                   warnings.warn(
                       "bad character in group name %a at position %d" %
                       (name, self.tell() - len(name) - offset),
                       DeprecationWarning, stacklevel=nested + 7
                   )
       
       def _class_escape(source, escape):
           # handle escape code inside character class
  273:     code = ESCAPES.get(escape)
  273:     if code:
   66:         return code
  207:     code = CATEGORIES.get(escape)
  207:     if code and code[0] is IN:
   45:         return code
  162:     try:
  162:         c = escape[1:2]
  162:         if c == "x":
                   # hexadecimal escape (exactly two digits)
   33:             escape += source.getwhile(2, HEXDIGITS)
   33:             if len(escape) != 4:
                       raise source.error("incomplete escape %s" % escape, len(escape))
   33:             return LITERAL, int(escape[2:], 16)
  129:         elif c == "u" and source.istext:
                   # unicode escape (exactly four digits)
                   escape += source.getwhile(4, HEXDIGITS)
                   if len(escape) != 6:
                       raise source.error("incomplete escape %s" % escape, len(escape))
                   return LITERAL, int(escape[2:], 16)
  129:         elif c == "U" and source.istext:
                   # unicode escape (exactly eight digits)
                   escape += source.getwhile(8, HEXDIGITS)
                   if len(escape) != 10:
                       raise source.error("incomplete escape %s" % escape, len(escape))
                   c = int(escape[2:], 16)
                   chr(c) # raise ValueError for invalid code
                   return LITERAL, c
  129:         elif c == "N" and source.istext:
                   import unicodedata
                   # named unicode escape e.g. \N{EM DASH}
                   if not source.match('{'):
                       raise source.error("missing {")
                   charname = source.getuntil('}', 'character name')
                   try:
                       c = ord(unicodedata.lookup(charname))
                   except (KeyError, TypeError):
                       raise source.error("undefined character name %r" % charname,
                                          len(charname) + len(r'\N{}')) from None
                   return LITERAL, c
  129:         elif c in OCTDIGITS:
                   # octal escape (up to three digits)
    6:             escape += source.getwhile(2, OCTDIGITS)
    6:             c = int(escape[1:], 8)
    6:             if c > 0o377:
                       raise source.error('octal escape value %s outside of '
                                          'range 0-0o377' % escape, len(escape))
    6:             return LITERAL, c
  123:         elif c in DIGITS:
                   raise ValueError
  123:         if len(escape) == 2:
  123:             if c in ASCIILETTERS:
                       raise source.error('bad escape %s' % escape, len(escape))
  123:             return LITERAL, ord(escape[1])
           except ValueError:
               pass
           raise source.error("bad escape %s" % escape, len(escape))
       
       def _escape(source, escape, state):
           # handle escape code in expression
  573:     code = CATEGORIES.get(escape)
  573:     if code:
  228:         return code
  345:     code = ESCAPES.get(escape)
  345:     if code:
   45:         return code
  300:     try:
  300:         c = escape[1:2]
  300:         if c == "x":
                   # hexadecimal escape
    1:             escape += source.getwhile(2, HEXDIGITS)
    1:             if len(escape) != 4:
                       raise source.error("incomplete escape %s" % escape, len(escape))
    1:             return LITERAL, int(escape[2:], 16)
  299:         elif c == "u" and source.istext:
                   # unicode escape (exactly four digits)
                   escape += source.getwhile(4, HEXDIGITS)
                   if len(escape) != 6:
                       raise source.error("incomplete escape %s" % escape, len(escape))
                   return LITERAL, int(escape[2:], 16)
  299:         elif c == "U" and source.istext:
                   # unicode escape (exactly eight digits)
                   escape += source.getwhile(8, HEXDIGITS)
                   if len(escape) != 10:
                       raise source.error("incomplete escape %s" % escape, len(escape))
                   c = int(escape[2:], 16)
                   chr(c) # raise ValueError for invalid code
                   return LITERAL, c
  299:         elif c == "N" and source.istext:
                   import unicodedata
                   # named unicode escape e.g. \N{EM DASH}
                   if not source.match('{'):
                       raise source.error("missing {")
                   charname = source.getuntil('}', 'character name')
                   try:
                       c = ord(unicodedata.lookup(charname))
                   except (KeyError, TypeError):
                       raise source.error("undefined character name %r" % charname,
                                          len(charname) + len(r'\N{}')) from None
                   return LITERAL, c
  299:         elif c == "0":
                   # octal escape
                   escape += source.getwhile(2, OCTDIGITS)
                   return LITERAL, int(escape[1:], 8)
  299:         elif c in DIGITS:
                   # octal escape *or* decimal group reference (sigh)
                   if source.next in DIGITS:
                       escape += source.get()
                       if (escape[1] in OCTDIGITS and escape[2] in OCTDIGITS and
                           source.next in OCTDIGITS):
                           # got three octal digits; this is an octal escape
                           escape += source.get()
                           c = int(escape[1:], 8)
                           if c > 0o377:
                               raise source.error('octal escape value %s outside of '
                                                  'range 0-0o377' % escape,
                                                  len(escape))
                           return LITERAL, c
                   # not an octal escape, so this is a group reference
                   group = int(escape[1:])
                   if group < state.groups:
                       if not state.checkgroup(group):
                           raise source.error("cannot refer to an open group",
                                              len(escape))
                       state.checklookbehindgroup(group, source)
                       return GROUPREF, group
                   raise source.error("invalid group reference %d" % group, len(escape) - 1)
  299:         if len(escape) == 2:
  299:             if c in ASCIILETTERS:
                       raise source.error("bad escape %s" % escape, len(escape))
  299:             return LITERAL, ord(escape[1])
           except ValueError:
               pass
           raise source.error("bad escape %s" % escape, len(escape))
       
       def _uniq(items):
  386:     return list(dict.fromkeys(items))
       
       def _parse_sub(source, state, verbose, nested):
           # parse an alternation: a|b|c
       
  894:     items = []
  894:     itemsappend = items.append
  894:     sourcematch = source.match
  894:     start = source.tell()
 1102:     while True:
 2204:         itemsappend(_parse(source, state, verbose, nested + 1,
 1102:                            not nested and not items))
 1102:         if not sourcematch("|"):
  894:             break
  208:         if not nested:
   44:             verbose = state.flags & SRE_FLAG_VERBOSE
       
  894:     if len(items) == 1:
  793:         return items[0]
       
  101:     subpattern = SubPattern(state)
       
           # check if all items share a common prefix
  110:     while True:
  110:         prefix = None
  235:         for item in items:
  226:             if not item:
                       break
  226:             if prefix is None:
  110:                 prefix = item[0]
  116:             elif item[0] != prefix:
  101:                 break
               else:
                   # all subitems start with a common "prefix".
                   # move it out of the branch
   27:             for item in items:
   18:                 del item[0]
    9:             subpattern.append(prefix)
    9:             continue # check next one
  101:         break
       
           # check if the branch can be replaced by a character set
  101:     set = []
  130:     for item in items:
  125:         if len(item) != 1:
   57:             break
   68:         op, av = item[0]
   68:         if op is LITERAL:
   21:             set.append((op, av))
   47:         elif op is IN and av[0][0] is not NEGATE:
    8:             set.extend(av)
               else:
   39:             break
           else:
               # we can store this as a character set instead of a
               # branch (the compiler may optimize this even more)
    5:         subpattern.append((IN, _uniq(set)))
    5:         return subpattern
       
   96:     subpattern.append((BRANCH, (None, items)))
   96:     return subpattern
       
       def _parse(source, state, verbose, nested, first=False):
           # parse a simple pattern
 1102:     subpattern = SubPattern(state)
       
           # precompute constants into local variables
 1102:     subpatternappend = subpattern.append
 1102:     sourceget = source.get
 1102:     sourcematch = source.match
 1102:     _len = len
 1102:     _ord = ord
       
 8979:     while True:
       
 8979:         this = source.next
 8979:         if this is None:
  358:             break # end of pattern
 8621:         if this in "|)":
  744:             break # end of subpattern
 7877:         sourceget()
       
 7877:         if verbose:
                   # skip whitespace and comments
 2547:             if this in WHITESPACE:
 1902:                 continue
  645:             if this == "#":
  585:                 while True:
  585:                     this = sourceget()
  585:                     if this is None or this == "\n":
   29:                         break
   29:                 continue
       
 5946:         if this[0] == "\\":
  573:             code = _escape(source, this, state)
  573:             subpatternappend(code)
       
 5373:         elif this not in SPECIAL_CHARS:
 2829:             subpatternappend((LITERAL, _ord(this)))
       
 2544:         elif this == "[":
  381:             here = source.tell() - 1
                   # character set
  381:             set = []
  381:             setappend = set.append
       ##          if sourcematch(":"):
       ##              pass # handle character classes
  381:             if source.next == '[':
                       import warnings
                       warnings.warn(
                           'Possible nested set at position %d' % source.tell(),
                           FutureWarning, stacklevel=nested + 6
                       )
  381:             negate = sourcematch("^")
                   # check remaining characters
 1432:             while True:
 1432:                 this = sourceget()
 1432:                 if this is None:
                           raise source.error("unterminated character set",
                                              source.tell() - here)
 1432:                 if this == "]" and set:
  354:                     break
 1078:                 elif this[0] == "\\":
  268:                     code1 = _class_escape(source, this)
                       else:
  810:                     if set and this in '-&~|' and source.next == this:
                               import warnings
                               warnings.warn(
                                   'Possible set %s at position %d' % (
                                       'difference' if this == '-' else
                                       'intersection' if this == '&' else
                                       'symmetric difference' if this == '~' else
                                       'union',
                                       source.tell() - 1),
                                   FutureWarning, stacklevel=nested + 6
                               )
  810:                     code1 = LITERAL, _ord(this)
 1078:                 if sourcematch("-"):
                           # potential range
  380:                     that = sourceget()
  380:                     if that is None:
                               raise source.error("unterminated character set",
                                                  source.tell() - here)
  380:                     if that == "]":
   27:                         if code1[0] is IN:
                                   code1 = code1[1][0]
   27:                         setappend(code1)
   27:                         setappend((LITERAL, _ord("-")))
   27:                         break
  353:                     if that[0] == "\\":
    5:                         code2 = _class_escape(source, that)
                           else:
  348:                         if that == '-':
                                   import warnings
                                   warnings.warn(
                                       'Possible set difference at position %d' % (
                                           source.tell() - 2),
                                       FutureWarning, stacklevel=nested + 6
                                   )
  348:                         code2 = LITERAL, _ord(that)
  353:                     if code1[0] != LITERAL or code2[0] != LITERAL:
                               msg = "bad character range %s-%s" % (this, that)
                               raise source.error(msg, len(this) + 1 + len(that))
  353:                     lo = code1[1]
  353:                     hi = code2[1]
  353:                     if hi < lo:
                               msg = "bad character range %s-%s" % (this, that)
                               raise source.error(msg, len(this) + 1 + len(that))
  353:                     setappend((RANGE, (lo, hi)))
                       else:
  698:                     if code1[0] is IN:
   45:                         code1 = code1[1][0]
  698:                     setappend(code1)
       
  381:             set = _uniq(set)
                   # XXX: <fl> should move set optimization to compiler!
  381:             if _len(set) == 1 and set[0][0] is LITERAL:
                       # optimization
   25:                 if negate:
   18:                     subpatternappend((NOT_LITERAL, set[0][1]))
                       else:
    7:                     subpatternappend(set[0])
                   else:
  356:                 if negate:
   30:                     set.insert(0, (NEGATE, None))
                       # charmap optimization can't be added here because
                       # global flags still are not known
  356:                 subpatternappend((IN, set))
       
 2163:         elif this in REPEAT_CHARS:
                   # repeat previous item
 1020:             here = source.tell()
 1020:             if this == "?":
  307:                 min, max = 0, 1
  713:             elif this == "*":
  342:                 min, max = 0, MAXREPEAT
       
  371:             elif this == "+":
  349:                 min, max = 1, MAXREPEAT
   22:             elif this == "{":
   22:                 if source.next == "}":
                           subpatternappend((LITERAL, _ord(this)))
                           continue
       
   22:                 min, max = 0, MAXREPEAT
   22:                 lo = hi = ""
   41:                 while source.next in DIGITS:
   19:                     lo += sourceget()
   22:                 if sourcematch(","):
   19:                     while source.next in DIGITS:
    9:                         hi += sourceget()
                       else:
   12:                     hi = lo
   22:                 if not sourcematch("}"):
    3:                     subpatternappend((LITERAL, _ord(this)))
    3:                     source.seek(here)
    3:                     continue
       
   19:                 if lo:
   19:                     min = int(lo)
   19:                     if min >= MAXREPEAT:
                               raise OverflowError("the repetition number is too large")
   19:                 if hi:
   15:                     max = int(hi)
   15:                     if max >= MAXREPEAT:
                               raise OverflowError("the repetition number is too large")
   15:                     if max < min:
                               raise source.error("min repeat greater than max repeat",
                                                  source.tell() - here)
                   else:
                       raise AssertionError("unsupported quantifier %r" % (char,))
                   # figure out which item to repeat
 1017:             if subpattern:
 1017:                 item = subpattern[-1:]
                   else:
                       item = None
 1017:             if not item or item[0][0] is AT:
                       raise source.error("nothing to repeat",
                                          source.tell() - here + len(this))
 1017:             if item[0][0] in _REPEATCODES:
                       raise source.error("multiple repeat",
                                          source.tell() - here + len(this))
 1017:             if item[0][0] is SUBPATTERN:
  109:                 group, add_flags, del_flags, p = item[0][1]
  109:                 if group is None and not add_flags and not del_flags:
   53:                     item = p
 1017:             if sourcematch("?"):
                       # Non-Greedy Match
   14:                 subpattern[-1] = (MIN_REPEAT, (min, max, item))
 1003:             elif sourcematch("+"):
                       # Possessive Match (Always Greedy)
                       subpattern[-1] = (POSSESSIVE_REPEAT, (min, max, item))
                   else:
                       # Greedy Match
 1003:                 subpattern[-1] = (MAX_REPEAT, (min, max, item))
       
 1143:         elif this == ".":
  199:             subpatternappend((ANY, None))
       
  944:         elif this == "(":
  689:             start = source.tell() - 1
  689:             capture = True
  689:             atomic = False
  689:             name = None
  689:             add_flags = 0
  689:             del_flags = 0
  689:             if sourcematch("?"):
                       # options
  383:                 char = sourceget()
  383:                 if char is None:
                           raise source.error("unexpected end of pattern")
  383:                 if char == "P":
                           # python extensions
  106:                     if sourcematch("<"):
                               # named group: skip forward to end of name
  105:                         name = source.getuntil(">", "group name")
  105:                         source.checkgroupname(name, 1, nested)
    1:                     elif sourcematch("="):
                               # named backreference
    1:                         name = source.getuntil(")", "group name")
    1:                         source.checkgroupname(name, 1, nested)
    1:                         gid = state.groupdict.get(name)
    1:                         if gid is None:
                                   msg = "unknown group name %r" % name
                                   raise source.error(msg, len(name) + 1)
    1:                         if not state.checkgroup(gid):
                                   raise source.error("cannot refer to an open group",
                                                      len(name) + 1)
    1:                         state.checklookbehindgroup(gid, source)
    1:                         subpatternappend((GROUPREF, gid))
    1:                         continue
       
                           else:
                               char = sourceget()
                               if char is None:
                                   raise source.error("unexpected end of pattern")
                               raise source.error("unknown extension ?P" + char,
                                                  len(char) + 2)
  277:                 elif char == ":":
                           # non-capturing group
  101:                     capture = False
  176:                 elif char == "#":
                           # comment
                           while True:
                               if source.next is None:
                                   raise source.error("missing ), unterminated comment",
                                                      source.tell() - start)
                               if sourceget() == ")":
                                   break
                           continue
       
  176:                 elif char in "=!<":
                           # lookahead assertions
   20:                     dir = 1
   20:                     if char == "<":
    6:                         char = sourceget()
    6:                         if char is None:
                                   raise source.error("unexpected end of pattern")
    6:                         if char not in "=!":
                                   raise source.error("unknown extension ?<" + char,
                                                      len(char) + 2)
    6:                         dir = -1 # lookbehind
    6:                         lookbehindgroups = state.lookbehindgroups
    6:                         if lookbehindgroups is None:
    6:                             state.lookbehindgroups = state.groups
   20:                     p = _parse_sub(source, state, verbose, nested + 1)
   20:                     if dir < 0:
    6:                         if lookbehindgroups is None:
    6:                             state.lookbehindgroups = None
   20:                     if not sourcematch(")"):
                               raise source.error("missing ), unterminated subpattern",
                                                  source.tell() - start)
   20:                     if char == "=":
   12:                         subpatternappend((ASSERT, (dir, p)))
                           else:
    8:                         subpatternappend((ASSERT_NOT, (dir, p)))
   20:                     continue
       
  156:                 elif char == "(":
                           # conditional backreference group
                           condname = source.getuntil(")", "group name")
                           if condname.isidentifier():
                               source.checkgroupname(condname, 1, nested)
                               condgroup = state.groupdict.get(condname)
                               if condgroup is None:
                                   msg = "unknown group name %r" % condname
                                   raise source.error(msg, len(condname) + 1)
                           else:
                               try:
                                   condgroup = int(condname)
                                   if condgroup < 0:
                                       raise ValueError
                               except ValueError:
                                   msg = "bad character in group name %r" % condname
                                   raise source.error(msg, len(condname) + 1) from None
                               if not condgroup:
                                   raise source.error("bad group number",
                                                      len(condname) + 1)
                               if condgroup >= MAXGROUPS:
                                   msg = "invalid group reference %d" % condgroup
                                   raise source.error(msg, len(condname) + 1)
                               if condgroup not in state.grouprefpos:
                                   state.grouprefpos[condgroup] = (
                                       source.tell() - len(condname) - 1
                                   )
                               if not (condname.isdecimal() and condname.isascii()):
                                   import warnings
                                   warnings.warn(
                                       "bad character in group name %s at position %d" %
                                       (repr(condname) if source.istext else ascii(condname),
                                        source.tell() - len(condname) - 1),
                                       DeprecationWarning, stacklevel=nested + 6
                                   )
                           state.checklookbehindgroup(condgroup, source)
                           item_yes = _parse(source, state, verbose, nested + 1)
                           if source.match("|"):
                               item_no = _parse(source, state, verbose, nested + 1)
                               if source.next == "|":
                                   raise source.error("conditional backref with more than two branches")
                           else:
                               item_no = None
                           if not source.match(")"):
                               raise source.error("missing ), unterminated subpattern",
                                                  source.tell() - start)
                           subpatternappend((GROUPREF_EXISTS, (condgroup, item_yes, item_no)))
                           continue
       
  156:                 elif char == ">":
                           # non-capturing, atomic group
                           capture = False
                           atomic = True
  156:                 elif char in FLAGS or char == "-":
                           # flags
  156:                     flags = _parse_flags(source, state, char)
  156:                     if flags is None:  # global flags
  152:                         if not first or subpattern:
                                   raise source.error('global flags not at the start '
                                                      'of the expression',
                                                      source.tell() - start)
  152:                         verbose = state.flags & SRE_FLAG_VERBOSE
  152:                         continue
       
    4:                     add_flags, del_flags = flags
    4:                     capture = False
                       else:
                           raise source.error("unknown extension ?" + char,
                                              len(char) + 1)
       
                   # parse group contents
  516:             if capture:
  411:                 try:
  411:                     group = state.opengroup(name)
                       except error as err:
                           raise source.error(err.msg, len(name) + 1) from None
                   else:
  105:                 group = None
  611:             sub_verbose = ((verbose or (add_flags & SRE_FLAG_VERBOSE)) and
   95:                            not (del_flags & SRE_FLAG_VERBOSE))
  516:             p = _parse_sub(source, state, sub_verbose, nested + 1)
  516:             if not source.match(")"):
                       raise source.error("missing ), unterminated subpattern",
                                          source.tell() - start)
  516:             if group is not None:
  411:                 state.closegroup(group, p)
  516:             if atomic:
                       assert group is None
                       subpatternappend((ATOMIC_GROUP, p))
                   else:
  516:                 subpatternappend((SUBPATTERN, (group, add_flags, del_flags, p)))
       
  255:         elif this == "^":
  199:             subpatternappend((AT, AT_BEGINNING))
       
   56:         elif this == "$":
   56:             subpatternappend((AT, AT_END))
       
               else:
                   raise AssertionError("unsupported special character %r" % (char,))
       
           # unpack non-capturing groups
 5879:     for i in range(len(subpattern))[::-1]:
 4777:         op, av = subpattern[i]
 4777:         if op is SUBPATTERN:
  407:             group, add_flags, del_flags, p = av
  407:             if group is None and not add_flags and not del_flags:
   48:                 subpattern[i: i+1] = p
       
 1102:     return subpattern
       
       def _parse_flags(source, state, char):
  156:     sourceget = source.get
  156:     add_flags = 0
  156:     del_flags = 0
  156:     if char != "-":
  156:         while True:
  156:             flag = FLAGS[char]
  156:             if source.istext:
  156:                 if char == 'L':
                           msg = "bad inline flags: cannot use 'L' flag with a str pattern"
                           raise source.error(msg)
                   else:
                       if char == 'u':
                           msg = "bad inline flags: cannot use 'u' flag with a bytes pattern"
                           raise source.error(msg)
  156:             add_flags |= flag
  156:             if (flag & TYPE_FLAGS) and (add_flags & TYPE_FLAGS) != flag:
                       msg = "bad inline flags: flags 'a', 'u' and 'L' are incompatible"
                       raise source.error(msg)
  156:             char = sourceget()
  156:             if char is None:
                       raise source.error("missing -, : or )")
  156:             if char in ")-:":
  156:                 break
                   if char not in FLAGS:
                       msg = "unknown flag" if char.isalpha() else "missing -, : or )"
                       raise source.error(msg, len(char))
  156:     if char == ")":
  152:         state.flags |= add_flags
  152:         return None
    4:     if add_flags & GLOBAL_FLAGS:
               raise source.error("bad inline flags: cannot turn on global flag", 1)
    4:     if char == "-":
               char = sourceget()
               if char is None:
                   raise source.error("missing flag")
               if char not in FLAGS:
                   msg = "unknown flag" if char.isalpha() else "missing flag"
                   raise source.error(msg, len(char))
               while True:
                   flag = FLAGS[char]
                   if flag & TYPE_FLAGS:
                       msg = "bad inline flags: cannot turn off flags 'a', 'u' and 'L'"
                       raise source.error(msg)
                   del_flags |= flag
                   char = sourceget()
                   if char is None:
                       raise source.error("missing :")
                   if char == ":":
                       break
                   if char not in FLAGS:
                       msg = "unknown flag" if char.isalpha() else "missing :"
                       raise source.error(msg, len(char))
    4:     assert char == ":"
    4:     if del_flags & GLOBAL_FLAGS:
               raise source.error("bad inline flags: cannot turn off global flag", 1)
    4:     if add_flags & del_flags:
               raise source.error("bad inline flags: flag turned on and off", 1)
    4:     return add_flags, del_flags
       
       def fix_flags(src, flags):
           # Check and fix flags according to the type of pattern (str or bytes)
  358:     if isinstance(src, str):
  351:         if flags & SRE_FLAG_LOCALE:
                   raise ValueError("cannot use LOCALE flag with a str pattern")
  351:         if not flags & SRE_FLAG_ASCII:
  346:             flags |= SRE_FLAG_UNICODE
    5:         elif flags & SRE_FLAG_UNICODE:
                   raise ValueError("ASCII and UNICODE flags are incompatible")
           else:
    7:         if flags & SRE_FLAG_UNICODE:
                   raise ValueError("cannot use UNICODE flag with a bytes pattern")
    7:         if flags & SRE_FLAG_LOCALE and flags & SRE_FLAG_ASCII:
                   raise ValueError("ASCII and LOCALE flags are incompatible")
  358:     return flags
       
       def parse(str, flags=0, state=None):
           # parse 're' pattern into list of (opcode, argument) tuples
       
  358:     source = Tokenizer(str)
       
  358:     if state is None:
  358:         state = State()
  358:     state.flags = flags
  358:     state.str = str
       
  358:     p = _parse_sub(source, state, flags & SRE_FLAG_VERBOSE, 0)
  358:     p.state.flags = fix_flags(str, p.state.flags)
       
  358:     if source.next is not None:
               assert source.next == ")"
               raise source.error("unbalanced parenthesis")
       
  358:     for g in p.state.grouprefpos:
               if g >= p.state.groups:
                   msg = "invalid group reference %d" % g
                   raise error(msg, str, p.state.grouprefpos[g])
       
  358:     if flags & SRE_FLAG_DEBUG:
               p.dump()
       
  358:     return p
       
       def parse_template(source, state):
           # parse 're' replacement string into list of literals and
           # group references
    3:     s = Tokenizer(source)
    3:     sget = s.get
    3:     groups = []
    3:     literals = []
    3:     literal = []
    3:     lappend = literal.append
    3:     def addgroup(index, pos):
    2:         if index > state.groups:
                   raise s.error("invalid group reference %d" % index, pos)
    2:         if literal:
    2:             literals.append(''.join(literal))
    2:             del literal[:]
    2:         groups.append((len(literals), index))
    2:         literals.append(None)
    3:     groupindex = state.groupindex
   22:     while True:
   22:         this = sget()
   22:         if this is None:
    3:             break # end of replacement string
   19:         if this[0] == "\\":
                   # group
    4:             c = this[1]
    4:             if c == "g":
                       if not s.match("<"):
                           raise s.error("missing <")
                       name = s.getuntil(">", "group name")
                       if name.isidentifier():
                           s.checkgroupname(name, 1, -1)
                           try:
                               index = groupindex[name]
                           except KeyError:
                               raise IndexError("unknown group name %r" % name) from None
                       else:
                           try:
                               index = int(name)
                               if index < 0:
                                   raise ValueError
                           except ValueError:
                               raise s.error("bad character in group name %r" % name,
                                             len(name) + 1) from None
                           if index >= MAXGROUPS:
                               raise s.error("invalid group reference %d" % index,
                                             len(name) + 1)
                           if not (name.isdecimal() and name.isascii()):
                               import warnings
                               warnings.warn(
                                   "bad character in group name %s at position %d" %
                                   (repr(name) if s.istext else ascii(name),
                                    s.tell() - len(name) - 1),
                                   DeprecationWarning, stacklevel=5
                               )
                       addgroup(index, len(name) + 1)
    4:             elif c == "0":
                       if s.next in OCTDIGITS:
                           this += sget()
                           if s.next in OCTDIGITS:
                               this += sget()
                       lappend(chr(int(this[1:], 8) & 0xff))
    4:             elif c in DIGITS:
    2:                 isoctal = False
    2:                 if s.next in DIGITS:
                           this += sget()
                           if (c in OCTDIGITS and this[2] in OCTDIGITS and
                               s.next in OCTDIGITS):
                               this += sget()
                               isoctal = True
                               c = int(this[1:], 8)
                               if c > 0o377:
                                   raise s.error('octal escape value %s outside of '
                                                 'range 0-0o377' % this, len(this))
                               lappend(chr(c))
    2:                 if not isoctal:
    2:                     addgroup(int(this[1:]), len(this) - 1)
                   else:
    2:                 try:
    2:                     this = chr(ESCAPES[this][1])
                       except KeyError:
                           if c in ASCIILETTERS:
                               raise s.error('bad escape %s' % this, len(this)) from None
    2:                 lappend(this)
               else:
   15:             lappend(this)
    3:     if literal:
    2:         literals.append(''.join(literal))
    3:     if not isinstance(source, str):
               # The tokenizer implicitly decodes bytes objects as latin-1, we must
               # therefore re-encode the final representation.
               literals = [None if s is None else s.encode('latin-1') for s in literals]
    3:     return groups, literals
       
       def expand_template(template, match):
  116:     g = match.group
  116:     empty = match.string[:0]
  116:     groups, literals = template
  116:     literals = literals[:]
  116:     try:
  232:         for index, group in groups:
  116:             literals[index] = g(group) or empty
           except IndexError:
               raise error("invalid group reference %d" % index) from None
  116:     return empty.join(literals)
