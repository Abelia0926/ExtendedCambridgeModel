    1: """
       Generic helpers for LLVM code generation.
       """
       
       
    1: import collections
    1: from contextlib import contextmanager, ExitStack
    1: import functools
       
    1: from llvmlite import ir
       
    1: from numba.core import utils, types, config, debuginfo
    1: import numba.core.datamodel
       
       
    1: bool_t = ir.IntType(1)
    1: int8_t = ir.IntType(8)
    1: int32_t = ir.IntType(32)
    1: intp_t = ir.IntType(utils.MACHINE_BITS)
    1: voidptr_t = int8_t.as_pointer()
       
    1: true_bit = bool_t(1)
    1: false_bit = bool_t(0)
    1: true_byte = int8_t(1)
    1: false_byte = int8_t(0)
       
       
    1: def as_bool_bit(builder, value):
           return builder.icmp_unsigned('!=', value, value.type(0))
       
       
    1: def make_anonymous_struct(builder, values, struct_type=None):
           """
           Create an anonymous struct containing the given LLVM *values*.
           """
           if struct_type is None:
               struct_type = ir.LiteralStructType([v.type for v in values])
           struct_val = struct_type(ir.Undefined)
           for i, v in enumerate(values):
               struct_val = builder.insert_value(struct_val, v, i)
           return struct_val
       
       
    1: def make_bytearray(buf):
           """
           Make a byte array constant from *buf*.
           """
  103:     b = bytearray(buf)
  103:     n = len(b)
  103:     return ir.Constant(ir.ArrayType(ir.IntType(8), n), b)
       
       
    1: _struct_proxy_cache = {}
       
       
    1: def create_struct_proxy(fe_type, kind='value'):
           """
           Returns a specialized StructProxy subclass for the given fe_type.
           """
  103:     cache_key = (fe_type, kind)
  103:     res = _struct_proxy_cache.get(cache_key)
  103:     if res is None:
   36:         base = {'value': ValueStructProxy,
   12:                 'data': DataStructProxy,
   12:                 }[kind]
   12:         clsname = base.__name__ + '_' + str(fe_type)
   12:         bases = (base,)
   12:         clsmembers = dict(_fe_type=fe_type)
   12:         res = type(clsname, bases, clsmembers)
       
   12:         _struct_proxy_cache[cache_key] = res
  103:     return res
       
       
    1: def copy_struct(dst, src, repl={}):
           """
           Copy structure from *src* to *dst* with replacement from *repl*.
           """
           repl = repl.copy()
           # copy data from src or use those in repl
           for k in src._datamodel._fields:
               v = repl.pop(k, getattr(src, k))
               setattr(dst, k, v)
           # use remaining key-values in repl
           for k, v in repl.items():
               setattr(dst, k, v)
           return dst
       
       
    2: class _StructProxy(object):
    1:     """
           Creates a `Structure` like interface that is constructed with information
           from DataModel instance.  FE type must have a data model that is a
           subclass of StructModel.
           """
           # The following class members must be overridden by subclass
    1:     _fe_type = None
       
    1:     def __init__(self, context, builder, value=None, ref=None):
  117:         self._context = context
  117:         self._datamodel = self._context.data_model_manager[self._fe_type]
  117:         if not isinstance(self._datamodel, numba.core.datamodel.StructModel):
                   raise TypeError(
                       "Not a structure model: {0}".format(self._datamodel))
  117:         self._builder = builder
       
  117:         self._be_type = self._get_be_type(self._datamodel)
  117:         assert not is_pointer(self._be_type)
       
  117:         outer_ref, ref = self._make_refs(ref)
  117:         if ref.type.pointee != self._be_type:
                   raise AssertionError("bad ref type: expected %s, got %s"
                                        % (self._be_type.as_pointer(), ref.type))
       
  117:         if value is not None:
   76:             if value.type != outer_ref.type.pointee:
                       raise AssertionError("bad value type: expected %s, got %s"
                                            % (outer_ref.type.pointee, value.type))
   76:             self._builder.store(value, outer_ref)
       
  117:         self._value = ref
  117:         self._outer_ref = outer_ref
       
    1:     def _make_refs(self, ref):
               """
               Return an (outer ref, value ref) pair.  By default, these are
               the same pointers, but a derived class may override this.
               """
  117:         if ref is None:
  116:             ref = alloca_once(self._builder, self._be_type, zfill=True)
  117:         return ref, ref
       
    1:     def _get_be_type(self, datamodel):
               raise NotImplementedError
       
    1:     def _cast_member_to_value(self, index, val):
               raise NotImplementedError
       
    1:     def _cast_member_from_value(self, index, val):
               raise NotImplementedError
       
    1:     def _get_ptr_by_index(self, index):
  623:         return gep_inbounds(self._builder, self._value, 0, index)
       
    1:     def _get_ptr_by_name(self, attrname):
   64:         index = self._datamodel.get_field_position(attrname)
   64:         return self._get_ptr_by_index(index)
       
    1:     def __getattr__(self, field):
               """
               Load the LLVM value of the named *field*.
               """
  303:         if not field.startswith('_'):
  303:             return self[self._datamodel.get_field_position(field)]
               else:
                   raise AttributeError(field)
       
    1:     def __setattr__(self, field, value):
               """
               Store the LLVM *value* into the named *field*.
               """
  958:         if field.startswith('_'):
  702:             return super(_StructProxy, self).__setattr__(field, value)
  256:         self[self._datamodel.get_field_position(field)] = value
       
    1:     def __getitem__(self, index):
               """
               Load the LLVM value of the field at *index*.
               """
  303:         member_val = self._builder.load(self._get_ptr_by_index(index))
  303:         return self._cast_member_to_value(index, member_val)
       
    1:     def __setitem__(self, index, value):
               """
               Store the LLVM *value* into the field at *index*.
               """
  256:         ptr = self._get_ptr_by_index(index)
  256:         value = self._cast_member_from_value(index, value)
  256:         if value.type != ptr.type.pointee:
                   if (is_pointer(value.type) and is_pointer(ptr.type.pointee)
                           and value.type.pointee == ptr.type.pointee.pointee):
                       # Differ by address-space only
                       # Auto coerce it
                       value = self._context.addrspacecast(self._builder,
                                                           value,
                                                           ptr.type.pointee.addrspace)
                   else:
                       raise TypeError("Invalid store of {value.type} to "
                                       "{ptr.type.pointee} in "
                                       "{self._datamodel} "
                                       "(trying to write member #{index})"
                                       .format(value=value, ptr=ptr, self=self,
                                               index=index))
  256:         self._builder.store(value, ptr)
       
    1:     def __len__(self):
               """
               Return the number of fields.
               """
               return self._datamodel.field_count
       
    1:     def _getpointer(self):
               """
               Return the LLVM pointer to the underlying structure.
               """
    8:         return self._outer_ref
       
    1:     def _getvalue(self):
               """
               Load and return the value of the underlying LLVM structure.
               """
   30:         return self._builder.load(self._outer_ref)
       
    1:     def _setvalue(self, value):
               """
               Store the value in this structure.
               """
               assert not is_pointer(value.type)
               assert value.type == self._be_type, (value.type, self._be_type)
               self._builder.store(value, self._value)
       
       
    2: class ValueStructProxy(_StructProxy):
    1:     """
           Create a StructProxy suitable for accessing regular values
           (e.g. LLVM values or alloca slots).
           """
    1:     def _get_be_type(self, datamodel):
  117:         return datamodel.get_value_type()
       
    1:     def _cast_member_to_value(self, index, val):
  303:         return val
       
    1:     def _cast_member_from_value(self, index, val):
  256:         return val
       
       
    2: class DataStructProxy(_StructProxy):
    1:     """
           Create a StructProxy suitable for accessing data persisted in memory.
           """
    1:     def _get_be_type(self, datamodel):
               return datamodel.get_data_type()
       
    1:     def _cast_member_to_value(self, index, val):
               model = self._datamodel.get_model(index)
               return model.from_data(self._builder, val)
       
    1:     def _cast_member_from_value(self, index, val):
               model = self._datamodel.get_model(index)
               return model.as_data(self._builder, val)
       
       
    2: class Structure(object):
    1:     """
           A high-level object wrapping a alloca'ed LLVM structure, including
           named fields and attribute access.
           """
       
           # XXX Should this warrant several separate constructors?
    1:     def __init__(self, context, builder, value=None, ref=None, cast_ref=False):
    2:         self._type = context.get_struct_type(self)
    2:         self._context = context
    2:         self._builder = builder
    2:         if ref is None:
                   self._value = alloca_once(builder, self._type, zfill=True)
                   if value is not None:
                       assert not is_pointer(value.type)
                       assert value.type == self._type, (value.type, self._type)
                       builder.store(value, self._value)
               else:
    2:             assert value is None
    2:             assert is_pointer(ref.type)
    2:             if self._type != ref.type.pointee:
    2:                 if cast_ref:
    2:                     ref = builder.bitcast(ref, self._type.as_pointer())
                       else:
                           raise TypeError(
                               "mismatching pointer type: got %s, expected %s"
                               % (ref.type.pointee, self._type))
    2:             self._value = ref
       
    2:         self._namemap = {}
    2:         self._fdmap = []
    2:         self._typemap = []
    2:         base = int32_t(0)
    6:         for i, (k, tp) in enumerate(self._fields):
    4:             self._namemap[k] = i
    4:             self._fdmap.append((base, int32_t(i)))
    4:             self._typemap.append(tp)
       
    1:     def _get_ptr_by_index(self, index):
    2:         ptr = self._builder.gep(self._value, self._fdmap[index], inbounds=True)
    2:         return ptr
       
    1:     def _get_ptr_by_name(self, attrname):
               return self._get_ptr_by_index(self._namemap[attrname])
       
    1:     def __getattr__(self, field):
               """
               Load the LLVM value of the named *field*.
               """
    2:         if not field.startswith('_'):
    2:             return self[self._namemap[field]]
               else:
                   raise AttributeError(field)
       
    1:     def __setattr__(self, field, value):
               """
               Store the LLVM *value* into the named *field*.
               """
   14:         if field.startswith('_'):
   14:             return super(Structure, self).__setattr__(field, value)
               self[self._namemap[field]] = value
       
    1:     def __getitem__(self, index):
               """
               Load the LLVM value of the field at *index*.
               """
       
    2:         return self._builder.load(self._get_ptr_by_index(index))
       
    1:     def __setitem__(self, index, value):
               """
               Store the LLVM *value* into the field at *index*.
               """
               ptr = self._get_ptr_by_index(index)
               if ptr.type.pointee != value.type:
                   fmt = "Type mismatch: __setitem__(%d, ...) expected %r but got %r"
                   raise AssertionError(fmt % (index,
                                               str(ptr.type.pointee),
                                               str(value.type)))
               self._builder.store(value, ptr)
       
    1:     def __len__(self):
               """
               Return the number of fields.
               """
               return len(self._namemap)
       
    1:     def _getpointer(self):
               """
               Return the LLVM pointer to the underlying structure.
               """
               return self._value
       
    1:     def _getvalue(self):
               """
               Load and return the value of the underlying LLVM structure.
               """
               return self._builder.load(self._value)
       
    1:     def _setvalue(self, value):
               """Store the value in this structure"""
               assert not is_pointer(value.type)
               assert value.type == self._type, (value.type, self._type)
               self._builder.store(value, self._value)
       
           # __iter__ is derived by Python from __len__ and __getitem__
       
       
    1: def alloca_once(builder, ty, size=None, name='', zfill=False):
           """Allocate stack memory at the entry block of the current function
           pointed by ``builder`` with llvm type ``ty``.  The optional ``size`` arg
           set the number of element to allocate.  The default is 1.  The optional
           ``name`` arg set the symbol name inside the llvm IR for debugging.
           If ``zfill`` is set, fill the memory with zeros at the current
           use-site location.  Note that the memory is always zero-filled after the
           ``alloca`` at init-site (the entry block).
           """
  405:     if isinstance(size, int):
    8:         size = ir.Constant(intp_t, size)
           # suspend debug metadata emission else it links up python source lines with
           # alloca in the entry block as well as their actual location and it makes
           # the debug info "jump about".
  810:     with debuginfo.suspend_emission(builder):
  810:         with builder.goto_entry_block():
  405:             ptr = builder.alloca(ty, size=size, name=name)
                   # Always zero-fill at init-site.  This is safe.
  405:             builder.store(ty(None), ptr)
               # Also zero-fill at the use-site
  405:         if zfill:
  134:             builder.store(ptr.type.pointee(None), ptr)
  405:         return ptr
       
       
    1: def sizeof(builder, ptr_type):
           """Compute sizeof using GEP
           """
           null = ptr_type(None)
           offset = null.gep([int32_t(1)])
           return builder.ptrtoint(offset, intp_t)
       
       
    1: def alloca_once_value(builder, value, name='', zfill=False):
           """
           Like alloca_once(), but passing a *value* instead of a type.  The
           type is inferred and the allocated slot is also initialized with the
           given value.
           """
    5:     storage = alloca_once(builder, value.type, zfill=zfill)
    5:     builder.store(value, storage)
    5:     return storage
       
       
    1: def insert_pure_function(module, fnty, name):
           """
           Insert a pure function (in the functional programming sense) in the
           given module.
           """
    2:     fn = get_or_insert_function(module, fnty, name)
    2:     fn.attributes.add("readonly")
    2:     fn.attributes.add("nounwind")
    2:     return fn
       
       
    1: def get_or_insert_function(module, fnty, name):
           """
           Get the function named *name* with type *fnty* from *module*, or insert it
           if it doesn't exist.
           """
  376:     fn = module.globals.get(name, None)
  376:     if fn is None:
  267:         fn = ir.Function(module, fnty, name)
  376:     return fn
       
       
    1: def get_or_insert_named_metadata(module, name):
           try:
               return module.get_named_metadata(name)
           except KeyError:
               return module.add_named_metadata(name)
       
       
    1: def add_global_variable(module, ty, name, addrspace=0):
  166:     unique_name = module.get_unique_name(name)
  166:     return ir.GlobalVariable(module, ty, unique_name, addrspace)
       
       
    1: def terminate(builder, bbend):
   19:     bb = builder.basic_block
   19:     if bb.terminator is None:
   19:         builder.branch(bbend)
       
       
    1: def get_null_value(ltype):
  163:     return ltype(None)
       
       
    1: def is_null(builder, val):
   18:     null = get_null_value(val.type)
   18:     return builder.icmp_unsigned('==', null, val)
       
       
    1: def is_not_null(builder, val):
   26:     null = get_null_value(val.type)
   26:     return builder.icmp_unsigned('!=', null, val)
       
       
    1: def if_unlikely(builder, pred):
   80:     return builder.if_then(pred, likely=False)
       
       
    1: def if_likely(builder, pred):
   14:     return builder.if_then(pred, likely=True)
       
       
    1: def ifnot(builder, pred):
           return builder.if_then(builder.not_(pred))
       
       
    1: def increment_index(builder, val):
           """
           Increment an index *val*.
           """
   23:     one = val.type(1)
           # We pass the "nsw" flag in the hope that LLVM understands the index
           # never changes sign.  Unfortunately this doesn't always work
           # (e.g. ndindex()).
   23:     return builder.add(val, one, flags=['nsw'])
       
       
    1: Loop = collections.namedtuple('Loop', ('index', 'do_break'))
       
       
    2: @contextmanager
    2: def for_range(builder, count, start=None, intp=None):
           """
           Generate LLVM IR for a for-loop in [start, count).
           *start* is equal to 0 by default.
       
           Yields a Loop namedtuple with the following members:
           - `index` is the loop index's value
           - `do_break` is a no-argument callable to break out of the loop
           """
   19:     if intp is None:
               intp = count.type
   19:     if start is None:
   19:         start = intp(0)
   19:     stop = count
       
   19:     bbcond = builder.append_basic_block("for.cond")
   19:     bbbody = builder.append_basic_block("for.body")
   19:     bbend = builder.append_basic_block("for.end")
       
   19:     def do_break():
               builder.branch(bbend)
       
   19:     bbstart = builder.basic_block
   19:     builder.branch(bbcond)
       
   38:     with builder.goto_block(bbcond):
   19:         index = builder.phi(intp, name="loop.index")
   19:         pred = builder.icmp_signed('<', index, stop)
   19:         builder.cbranch(pred, bbbody, bbend)
       
   38:     with builder.goto_block(bbbody):
   19:         yield Loop(index, do_break)
               # Update bbbody as a new basic block may have been activated
   19:         bbbody = builder.basic_block
   19:         incr = increment_index(builder, index)
   19:         terminate(builder, bbcond)
       
   19:     index.add_incoming(start, bbstart)
   19:     index.add_incoming(incr, bbbody)
       
   19:     builder.position_at_end(bbend)
       
       
    2: @contextmanager
    2: def for_range_slice(builder, start, stop, step, intp=None, inc=True):
           """
           Generate LLVM IR for a for-loop based on a slice.  Yields a
           (index, count) tuple where `index` is the slice index's value
           inside the loop, and `count` the iteration count.
       
           Parameters
           -------------
           builder : object
               IRBuilder object
           start : int
               The beginning value of the slice
           stop : int
               The end value of the slice
           step : int
               The step value of the slice
           intp :
               The data type
           inc : boolean, optional
               Signals whether the step is positive (True) or negative (False).
       
           Returns
           -----------
               None
           """
           if intp is None:
               intp = start.type
       
           bbcond = builder.append_basic_block("for.cond")
           bbbody = builder.append_basic_block("for.body")
           bbend = builder.append_basic_block("for.end")
           bbstart = builder.basic_block
           builder.branch(bbcond)
       
           with builder.goto_block(bbcond):
               index = builder.phi(intp, name="loop.index")
               count = builder.phi(intp, name="loop.count")
               if (inc):
                   pred = builder.icmp_signed('<', index, stop)
               else:
                   pred = builder.icmp_signed('>', index, stop)
               builder.cbranch(pred, bbbody, bbend)
       
           with builder.goto_block(bbbody):
               yield index, count
               bbbody = builder.basic_block
               incr = builder.add(index, step)
               next_count = increment_index(builder, count)
               terminate(builder, bbcond)
       
           index.add_incoming(start, bbstart)
           index.add_incoming(incr, bbbody)
           count.add_incoming(ir.Constant(intp, 0), bbstart)
           count.add_incoming(next_count, bbbody)
           builder.position_at_end(bbend)
       
       
    2: @contextmanager
    2: def for_range_slice_generic(builder, start, stop, step):
           """
           A helper wrapper for for_range_slice().  This is a context manager which
           yields two for_range_slice()-alike context managers, the first for
           the positive step case, the second for the negative step case.
       
           Use:
               with for_range_slice_generic(...) as (pos_range, neg_range):
                   with pos_range as (idx, count):
                       ...
                   with neg_range as (idx, count):
                       ...
           """
           intp = start.type
           is_pos_step = builder.icmp_signed('>=', step, ir.Constant(intp, 0))
       
           pos_for_range = for_range_slice(builder, start, stop, step, intp, inc=True)
           neg_for_range = for_range_slice(builder, start, stop, step, intp, inc=False)
       
           @contextmanager
           def cm_cond(cond, inner_cm):
               with cond:
                   with inner_cm as value:
                       yield value
       
           with builder.if_else(is_pos_step, likely=True) as (then, otherwise):
               yield cm_cond(then, pos_for_range), cm_cond(otherwise, neg_for_range)
       
       
    2: @contextmanager
    2: def loop_nest(builder, shape, intp, order='C'):
           """
           Generate a loop nest walking a N-dimensional array.
           Yields a tuple of N indices for use in the inner loop body,
           iterating over the *shape* space.
       
           If *order* is 'C' (the default), indices are incremented inside-out
           (i.e. (0,0), (0,1), (0,2), (1,0) etc.).
           If *order* is 'F', they are incremented outside-in
           (i.e. (0,0), (1,0), (2,0), (0,1) etc.).
           This has performance implications when walking an array as it impacts
           the spatial locality of memory accesses.
           """
   17:     assert order in 'CF'
   17:     if not shape:
               # 0-d array
               yield ()
           else:
   17:         if order == 'F':
                   _swap = lambda x: x[::-1]
               else:
   51:             _swap = lambda x: x
   34:         with _loop_nest(builder, _swap(shape), intp) as indices:
   17:             assert len(indices) == len(shape)
   17:             yield _swap(indices)
       
       
    2: @contextmanager
    2: def _loop_nest(builder, shape, intp):
   38:     with for_range(builder, shape[0], intp=intp) as loop:
   19:         if len(shape) > 1:
    4:             with _loop_nest(builder, shape[1:], intp) as indices:
    2:                 yield (loop.index,) + indices
               else:
   17:             yield (loop.index,)
       
       
    1: def pack_array(builder, values, ty=None):
           """
           Pack a sequence of values in a LLVM array.  *ty* should be given
           if the array may be empty, in which case the type can't be inferred
           from the values.
           """
   83:     n = len(values)
   83:     if ty is None:
   67:         ty = values[0].type
   83:     ary = ir.ArrayType(ty, n)(ir.Undefined)
  225:     for i, v in enumerate(values):
  142:         ary = builder.insert_value(ary, v, i)
   83:     return ary
       
       
    1: def pack_struct(builder, values):
           """
           Pack a sequence of values into a LLVM struct.
           """
   17:     structty = ir.LiteralStructType([v.type for v in values])
    1:     st = structty(ir.Undefined)
   16:     for i, v in enumerate(values):
   15:         st = builder.insert_value(st, v, i)
    1:     return st
       
       
    1: def unpack_tuple(builder, tup, count=None):
           """
           Unpack an array or structure of values, return a Python tuple.
           """
  131:     if count is None:
               # Assuming *tup* is an aggregate
   16:         count = len(tup.type.elements)
  857:     vals = [builder.extract_value(tup, i)
  363:             for i in range(count)]
  131:     return vals
       
       
    2: def get_item_pointer(context, builder, aryty, ary, inds, wraparound=False,
    1:                      boundscheck=False):
           # Set boundscheck=True for any pointer access that should be
           # boundschecked. do_boundscheck() will handle enabling or disabling the
           # actual boundschecking based on the user config.
   16:     shapes = unpack_tuple(builder, ary.shape, count=aryty.ndim)
   16:     strides = unpack_tuple(builder, ary.strides, count=aryty.ndim)
   32:     return get_item_pointer2(context, builder, data=ary.data, shape=shapes,
   16:                              strides=strides, layout=aryty.layout, inds=inds,
   16:                              wraparound=wraparound, boundscheck=boundscheck)
       
       
    1: def do_boundscheck(context, builder, ind, dimlen, axis=None):
           def _dbg():
               # Remove this when we figure out how to include this information
               # in the error message.
               if axis is not None:
                   if isinstance(axis, int):
                       printf(builder, "debug: IndexError: index %d is out of bounds "
                              "for axis {} with size %d\n".format(axis), ind, dimlen)
                   else:
                       printf(builder, "debug: IndexError: index %d is out of bounds "
                              "for axis %d with size %d\n", ind, axis,
                              dimlen)
               else:
                   printf(builder,
                          "debug: IndexError: index %d is out of bounds for size %d\n",
                          ind, dimlen)
       
           msg = "index is out of bounds"
           out_of_bounds_upper = builder.icmp_signed('>=', ind, dimlen)
           with if_unlikely(builder, out_of_bounds_upper):
               if config.FULL_TRACEBACKS:
                   _dbg()
               context.call_conv.return_user_exc(builder, IndexError, (msg,))
           out_of_bounds_lower = builder.icmp_signed('<', ind, ind.type(0))
           with if_unlikely(builder, out_of_bounds_lower):
               if config.FULL_TRACEBACKS:
                   _dbg()
               context.call_conv.return_user_exc(builder, IndexError, (msg,))
       
       
    1: def get_item_pointer2(context, builder, data, shape, strides, layout, inds,
    1:                       wraparound=False, boundscheck=False):
           # Set boundscheck=True for any pointer access that should be
           # boundschecked. do_boundscheck() will handle enabling or disabling the
           # actual boundschecking based on the user config.
   36:     if wraparound:
               # Wraparound
               indices = []
               for ind, dimlen in zip(inds, shape):
                   negative = builder.icmp_signed('<', ind, ind.type(0))
                   wrapped = builder.add(dimlen, ind)
                   selected = builder.select(negative, wrapped, ind)
                   indices.append(selected)
           else:
   36:         indices = inds
   36:     if boundscheck:
               for axis, (ind, dimlen) in enumerate(zip(indices, shape)):
                   do_boundscheck(context, builder, ind, dimlen, axis)
       
   36:     if not indices:
               # Indexing with empty tuple
               return builder.gep(data, [int32_t(0)])
   36:     intp = indices[0].type
           # Indexing code
   36:     if layout in 'CF':
   32:         steps = []
               # Compute steps for each dimension
   32:         if layout == 'C':
                   # C contiguous
   86:             for i in range(len(shape)):
   54:                 last = intp(1)
   76:                 for j in shape[i + 1:]:
   22:                     last = builder.mul(last, j)
   54:                 steps.append(last)
               elif layout == 'F':
                   # F contiguous
                   for i in range(len(shape)):
                       last = intp(1)
                       for j in shape[:i]:
                           last = builder.mul(last, j)
                       steps.append(last)
               else:
                   raise Exception("unreachable")
       
               # Compute index
   32:         loc = intp(0)
   86:         for i, s in zip(indices, steps):
   54:             tmp = builder.mul(i, s)
   54:             loc = builder.add(loc, tmp)
   32:         ptr = builder.gep(data, [loc])
   32:         return ptr
           else:
               # Any layout
   12:         dimoffs = [builder.mul(s, i) for s, i in zip(strides, indices)]
    4:         offset = functools.reduce(builder.add, dimoffs)
    4:         return pointer_add(builder, data, offset)
       
       
    1: def _scalar_pred_against_zero(builder, value, fpred, icond):
   14:     nullval = value.type(0)
   14:     if isinstance(value.type, (ir.FloatType, ir.DoubleType)):
   10:         isnull = fpred(value, nullval)
    4:     elif isinstance(value.type, ir.IntType):
    4:         isnull = builder.icmp_signed(icond, value, nullval)
           else:
               raise TypeError("unexpected value type %s" % (value.type,))
   14:     return isnull
       
       
    1: def is_scalar_zero(builder, value):
           """
           Return a predicate representing whether *value* is equal to zero.
           """
   20:     return _scalar_pred_against_zero(
   10:         builder, value, functools.partial(builder.fcmp_ordered, '=='), '==')
       
       
    1: def is_not_scalar_zero(builder, value):
           """
           Return a predicate representing whether a *value* is not equal to zero.
           (not exactly "not is_scalar_zero" because of nans)
           """
    8:     return _scalar_pred_against_zero(
    4:         builder, value, functools.partial(builder.fcmp_unordered, '!='), '!=')
       
       
    1: def is_scalar_zero_or_nan(builder, value):
           """
           Return a predicate representing whether *value* is equal to either zero
           or NaN.
           """
           return _scalar_pred_against_zero(
               builder, value, functools.partial(builder.fcmp_unordered, '=='), '==')
       
       
    1: is_true = is_not_scalar_zero
    1: is_false = is_scalar_zero
       
       
    1: def is_scalar_neg(builder, value):
           """
           Is *value* negative?  Assumes *value* is signed.
           """
           return _scalar_pred_against_zero(
               builder, value, functools.partial(builder.fcmp_ordered, '<'), '<')
       
       
    2: @contextmanager
    2: def early_exit_if(builder, stack: ExitStack, cond):
           """
           The Python code::
       
               with contextlib.ExitStack() as stack:
                   with early_exit_if(builder, stack, cond):
                       cleanup()
                   body()
       
           emits the code::
       
               if (cond) {
                   <cleanup>
               }
               else {
                   <body>
               }
       
           This can be useful for generating code with lots of early exits, without
           having to increase the indentation each time.
           """
           then, otherwise = stack.enter_context(builder.if_else(cond, likely=False))
           with then:
               yield
           stack.enter_context(otherwise)
       
       
    1: def early_exit_if_null(builder, stack, obj):
           """
           A convenience wrapper for :func:`early_exit_if`, for the common case where
           the CPython API indicates an error by returning ``NULL``.
           """
           return early_exit_if(builder, stack, is_null(builder, obj))
       
       
    1: def guard_null(context, builder, value, exc_tuple):
           """
           Guard against *value* being null or zero.
           *exc_tuple* should be a (exception type, arguments...) tuple.
           """
           with builder.if_then(is_scalar_zero(builder, value), likely=False):
               exc = exc_tuple[0]
               exc_args = exc_tuple[1:] or None
               context.call_conv.return_user_exc(builder, exc, exc_args)
       
       
    1: def guard_memory_error(context, builder, pointer, msg=None):
           """
           Guard against *pointer* being NULL (and raise a MemoryError).
           """
    3:     assert isinstance(pointer.type, ir.PointerType), pointer.type
    3:     exc_args = (msg,) if msg else ()
    6:     with builder.if_then(is_null(builder, pointer), likely=False):
    3:         context.call_conv.return_user_exc(builder, MemoryError, exc_args)
       
       
    2: @contextmanager
    2: def if_zero(builder, value, likely=False):
           """
           Execute the given block if the scalar value is zero.
           """
   20:     with builder.if_then(is_scalar_zero(builder, value), likely=likely):
   10:         yield
       
       
    1: guard_zero = guard_null
       
       
    1: def is_pointer(ltyp):
           """
           Whether the LLVM type *typ* is a struct type.
           """
  119:     return isinstance(ltyp, ir.PointerType)
       
       
    1: def get_record_member(builder, record, offset, typ):
           pval = gep_inbounds(builder, record, 0, offset)
           assert not is_pointer(pval.type.pointee)
           return builder.bitcast(pval, typ.as_pointer())
       
       
    1: def is_neg_int(builder, val):
   24:     return builder.icmp_signed('<', val, val.type(0))
       
       
    1: def gep_inbounds(builder, ptr, *inds, **kws):
           """
           Same as *gep*, but add the `inbounds` keyword.
           """
  749:     return gep(builder, ptr, *inds, inbounds=True, **kws)
       
       
    1: def gep(builder, ptr, *inds, **kws):
           """
           Emit a getelementptr instruction for the given pointer and indices.
           The indices can be LLVM values or Python int constants.
           """
  750:     name = kws.pop('name', '')
  750:     inbounds = kws.pop('inbounds', False)
  750:     assert not kws
  750:     idx = []
 2238:     for i in inds:
 1488:         if isinstance(i, int):
                   # NOTE: llvm only accepts int32 inside structs, not int64
 1488:             ind = int32_t(i)
               else:
                   ind = i
 1488:         idx.append(ind)
  750:     return builder.gep(ptr, idx, name=name, inbounds=inbounds)
       
       
    1: def pointer_add(builder, ptr, offset, return_type=None):
           """
           Add an integral *offset* to pointer *ptr*, and return a pointer
           of *return_type* (or, if omitted, the same type as *ptr*).
       
           Note the computation is done in bytes, and ignores the width of
           the pointed item type.
           """
    6:     intptr = builder.ptrtoint(ptr, intp_t)
    6:     if isinstance(offset, int):
    2:         offset = intp_t(offset)
    6:     intptr = builder.add(intptr, offset)
    6:     return builder.inttoptr(intptr, return_type or ptr.type)
       
       
    1: def memset(builder, ptr, size, value):
           """
           Fill *size* bytes starting from *ptr* with *value*.
           """
    1:     fn = builder.module.declare_intrinsic('llvm.memset', (voidptr_t, size.type))
    1:     ptr = builder.bitcast(ptr, voidptr_t)
    1:     if isinstance(value, int):
    1:         value = int8_t(value)
    1:     builder.call(fn, [ptr, value, size, bool_t(0)])
       
       
    1: def memset_padding(builder, ptr):
           """
           Fill padding bytes of the pointee with zeros.
           """
           # Load existing value
           val = builder.load(ptr)
           # Fill pointee with zeros
           memset(builder, ptr, sizeof(builder, ptr.type), 0)
           # Store value back
           builder.store(val, ptr)
       
       
    1: def global_constant(builder_or_module, name, value, linkage='internal'):
           """
           Get or create a (LLVM module-)global constant with *name* or *value*.
           """
  123:     if isinstance(builder_or_module, ir.Module):
  123:         module = builder_or_module
           else:
               module = builder_or_module.module
  123:     data = add_global_variable(module, value.type, name)
  123:     data.linkage = linkage
  123:     data.global_constant = True
  123:     data.initializer = value
  123:     return data
       
       
    1: def divmod_by_constant(builder, val, divisor):
           """
           Compute the (quotient, remainder) of *val* divided by the constant
           positive *divisor*.  The semantics reflects those of Python integer
           floor division, rather than C's / LLVM's signed division and modulo.
           The difference lies with a negative *val*.
           """
           assert divisor > 0
           divisor = val.type(divisor)
           one = val.type(1)
       
           quot = alloca_once(builder, val.type)
       
           with builder.if_else(is_neg_int(builder, val)) as (if_neg, if_pos):
               with if_pos:
                   # quot = val / divisor
                   quot_val = builder.sdiv(val, divisor)
                   builder.store(quot_val, quot)
               with if_neg:
                   # quot = -1 + (val + 1) / divisor
                   val_plus_one = builder.add(val, one)
                   quot_val = builder.sdiv(val_plus_one, divisor)
                   builder.store(builder.sub(quot_val, one), quot)
       
           # rem = val - quot * divisor
           # (should be slightly faster than a separate modulo operation)
           quot_val = builder.load(quot)
           rem_val = builder.sub(val, builder.mul(quot_val, divisor))
           return quot_val, rem_val
       
       
    1: def cbranch_or_continue(builder, cond, bbtrue):
           """
           Branch conditionally or continue.
       
           Note: a new block is created and builder is moved to the end of the new
                 block.
           """
           bbcont = builder.append_basic_block('.continue')
           builder.cbranch(cond, bbtrue, bbcont)
           builder.position_at_end(bbcont)
           return bbcont
       
       
    1: def memcpy(builder, dst, src, count):
           """
           Emit a memcpy to the builder.
       
           Copies each element of dst to src. Unlike the C equivalent, each element
           can be any LLVM type.
       
           Assumes
           -------
           * dst.type == src.type
           * count is positive
           """
           # Note this does seem to be optimized as a raw memcpy() by LLVM
           # whenever possible...
           assert dst.type == src.type
           with for_range(builder, count, intp=count.type) as loop:
               out_ptr = builder.gep(dst, [loop.index])
               in_ptr = builder.gep(src, [loop.index])
               builder.store(builder.load(in_ptr), out_ptr)
       
       
    1: def _raw_memcpy(builder, func_name, dst, src, count, itemsize, align):
           size_t = count.type
           if isinstance(itemsize, int):
               itemsize = ir.Constant(size_t, itemsize)
       
           memcpy = builder.module.declare_intrinsic(func_name,
                                                     [voidptr_t, voidptr_t, size_t])
           is_volatile = false_bit
           builder.call(memcpy, [builder.bitcast(dst, voidptr_t),
                                 builder.bitcast(src, voidptr_t),
                                 builder.mul(count, itemsize),
                                 is_volatile])
       
       
    1: def raw_memcpy(builder, dst, src, count, itemsize, align=1):
           """
           Emit a raw memcpy() call for `count` items of size `itemsize`
           from `src` to `dest`.
           """
           return _raw_memcpy(builder, 'llvm.memcpy', dst, src, count, itemsize, align)
       
       
    1: def raw_memmove(builder, dst, src, count, itemsize, align=1):
           """
           Emit a raw memmove() call for `count` items of size `itemsize`
           from `src` to `dest`.
           """
           return _raw_memcpy(builder, 'llvm.memmove', dst, src, count,
                              itemsize, align)
       
       
    1: def muladd_with_overflow(builder, a, b, c):
           """
           Compute (a * b + c) and return a (result, overflow bit) pair.
           The operands must be signed integers.
           """
           p = builder.smul_with_overflow(a, b)
           prod = builder.extract_value(p, 0)
           prod_ovf = builder.extract_value(p, 1)
           s = builder.sadd_with_overflow(prod, c)
           res = builder.extract_value(s, 0)
           ovf = builder.or_(prod_ovf, builder.extract_value(s, 1))
           return res, ovf
       
       
    1: def printf(builder, format, *args):
           """
           Calls printf().
           Argument `format` is expected to be a Python string.
           Values to be printed are listed in `args`.
       
           Note: There is no checking to ensure there is correct number of values
           in `args` and there type matches the declaration in the format string.
           """
           assert isinstance(format, str)
           mod = builder.module
           # Make global constant for format string
           cstring = voidptr_t
           fmt_bytes = make_bytearray((format + '\00').encode('ascii'))
           global_fmt = global_constant(mod, "printf_format", fmt_bytes)
           fnty = ir.FunctionType(int32_t, [cstring], var_arg=True)
           # Insert printf()
           try:
               fn = mod.get_global('printf')
           except KeyError:
               fn = ir.Function(mod, fnty, name="printf")
           # Call
           ptr_fmt = builder.bitcast(global_fmt, cstring)
           return builder.call(fn, [ptr_fmt] + list(args))
       
       
    1: def snprintf(builder, buffer, bufsz, format, *args):
           """Calls libc snprintf(buffer, bufsz, format, ...args)
           """
           assert isinstance(format, str)
           mod = builder.module
           # Make global constant for format string
           cstring = voidptr_t
           fmt_bytes = make_bytearray((format + '\00').encode('ascii'))
           global_fmt = global_constant(mod, "snprintf_format", fmt_bytes)
           fnty = ir.FunctionType(
               int32_t, [cstring, intp_t, cstring], var_arg=True,
           )
           # Actual symbol name of snprintf is different on win32.
           symbol = 'snprintf'
           if config.IS_WIN32:
               symbol = '_' + symbol
           # Insert snprintf()
           try:
               fn = mod.get_global(symbol)
           except KeyError:
               fn = ir.Function(mod, fnty, name=symbol)
           # Call
           ptr_fmt = builder.bitcast(global_fmt, cstring)
           return builder.call(fn, [buffer, bufsz, ptr_fmt] + list(args))
       
       
    1: def snprintf_stackbuffer(builder, bufsz, format, *args):
           """Similar to `snprintf()` but the buffer is stack allocated to size
           *bufsz*.
       
           Returns the buffer pointer as i8*.
           """
           assert isinstance(bufsz, int)
           spacety = ir.ArrayType(ir.IntType(8), bufsz)
           space = alloca_once(builder, spacety, zfill=True)
           buffer = builder.bitcast(space, voidptr_t)
           snprintf(builder, buffer, intp_t(bufsz), format, *args)
           return buffer
       
       
    1: def normalize_ir_text(text):
           """
           Normalize the given string to latin1 compatible encoding that is
           suitable for use in LLVM IR.
           """
           # Just re-encoding to latin1 is enough
  133:     return text.encode('utf8').decode('latin1')
       
       
    1: def hexdump(builder, ptr, nbytes):
           """Debug print the memory region in *ptr* to *ptr + nbytes*
           as hex.
           """
           bytes_per_line = 16
           nbytes = builder.zext(nbytes, intp_t)
           printf(builder, "hexdump p=%p n=%zu",
                  ptr, nbytes)
           byte_t = ir.IntType(8)
           ptr = builder.bitcast(ptr, byte_t.as_pointer())
           # Loop to print the bytes in *ptr* as hex
           with for_range(builder, nbytes) as idx:
               div_by = builder.urem(idx.index, intp_t(bytes_per_line))
               do_new_line = builder.icmp_unsigned("==", div_by, intp_t(0))
               with builder.if_then(do_new_line):
                   printf(builder, "\n")
       
               offset = builder.gep(ptr, [idx.index])
               val = builder.load(offset)
               printf(builder, " %02x", val)
           printf(builder, "\n")
       
       
    1: def is_nonelike(ty):
           """ returns if 'ty' is none """
   43:     return (
   82:         ty is None or
   39:         isinstance(ty, types.NoneType) or
   38:         isinstance(ty, types.Omitted)
           )
       
       
    1: def create_constant_array(ty, val):
           """
           Create an LLVM-constant of a fixed-length array from Python values.
       
           The type provided is the type of the elements.
           """
    4:     return ir.Constant(ir.ArrayType(ty, len(val)), val)
