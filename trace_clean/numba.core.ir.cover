    1: from collections import defaultdict
    1: import copy
    1: import itertools
    1: import os
    1: import linecache
    1: import pprint
    1: import re
    1: import sys
    1: import operator
    1: from types import FunctionType, BuiltinFunctionType
    1: from functools import total_ordering
    1: from io import StringIO
       
    1: from numba.core import errors, config
    1: from numba.core.utils import (BINOPS_TO_OPERATORS, INPLACE_BINOPS_TO_OPERATORS,
                                     UNARY_BUITINS_TO_OPERATORS, OPERATORS_TO_BUILTINS)
    1: from numba.core.errors import (NotDefinedError, RedefinedError,
                                      VerificationError, ConstantInferenceError)
    1: from numba.core import consts
       
       # terminal color markup
    1: _termcolor = errors.termcolor()
       
       
    2: class Loc(object):
    1:     """Source location
       
           """
    1:     _defmatcher = re.compile(r'def\s+(\w+)\(.*')
       
    1:     def __init__(self, filename, line, col=None, maybe_decorator=False):
               """ Arguments:
               filename - name of the file
               line - line in file
               col - column
               maybe_decorator - Set to True if location is likely a jit decorator
               """
 1940:         self.filename = filename
 1940:         self.line = line
 1940:         self.col = col
 1940:         self.lines = None # the source lines from the linecache
 1940:         self.maybe_decorator = maybe_decorator
       
    1:     def __eq__(self, other):
               # equivalence is solely based on filename, line and col
               if type(self) is not type(other): return False
               if self.filename != other.filename: return False
               if self.line != other.line: return False
               if self.col != other.col: return False
               return True
       
    1:     def __ne__(self, other):
               return not self.__eq__(other)
       
    2:     @classmethod
    2:     def from_function_id(cls, func_id):
   24:         return cls(func_id.filename, func_id.firstlineno, maybe_decorator=True)
       
    1:     def __repr__(self):
               return "Loc(filename=%s, line=%s, col=%s)" % (self.filename,
                                                             self.line, self.col)
       
    1:     def __str__(self):
  199:         if self.col is not None:
                   return "%s (%s:%s)" % (self.filename, self.line, self.col)
               else:
  199:             return "%s (%s)" % (self.filename, self.line)
       
    1:     def _find_definition(self):
               # try and find a def, go backwards from error line
    1:         fn_name = None
    1:         lines = self.get_lines()
    8:         for x in reversed(lines[:self.line - 1]):
                   # the strip and startswith is to handle user code with commented out
                   # 'def' or use of 'def' in a docstring.
    8:             if x.strip().startswith('def '):
    1:                 fn_name = x
    1:                 break
       
    1:         return fn_name
       
    1:     def _raw_function_name(self):
    1:         defn = self._find_definition()
    1:         if defn:
    1:             return self._defmatcher.match(defn.strip()).groups()[0]
               else:
                   # Probably exec(<string>) or REPL.
                   return None
       
    1:     def get_lines(self):
   69:         if self.lines is None:
       
   53:             self.lines = linecache.getlines(self._get_path())
       
   69:         return self.lines
       
    1:     def _get_path(self):
  121:         path = None
  121:         try:
                   # Try to get a relative path
                   # ipython/jupyter input just returns as self.filename
  121:             path = os.path.relpath(self.filename)
               except ValueError:
                   # Fallback to absolute path if error occurred in getting the
                   # relative path.
                   # This may happen on windows if the drive is different
                   path = os.path.abspath(self.filename)
  121:         return path
       
       
    1:     def strformat(self, nlines_up=2):
       
   68:         lines = self.get_lines()
       
   68:         use_line = self.line
       
   68:         if self.maybe_decorator:
                   # try and sort out a better `loc`, if it's suspected that this loc
                   # points at a jit decorator by virtue of
                   # `__code__.co_firstlineno`
       
                   # get lines, add a dummy entry at the start as lines count from
                   # 1 but list index counts from 0
                   tmplines = [''] + lines
       
                   if lines and use_line and 'def ' not in tmplines[use_line]:
                       # look forward 10 lines, unlikely anyone managed to stretch
                       # a jit call declaration over >10 lines?!
                       min_line = max(0, use_line)
                       max_line = use_line + 10
                       selected = tmplines[min_line : max_line]
                       index = 0
                       for idx, x in enumerate(selected):
                           if 'def ' in x:
                               index = idx
                               break
                       use_line = use_line + index
       
       
   68:         ret = [] # accumulates output
   68:         if lines and use_line > 0:
       
   68:             def count_spaces(string):
  123:                 spaces = 0
 1015:                 for x in itertools.takewhile(str.isspace, str(string)):
  892:                     spaces += 1
  123:                 return spaces
       
                   # A few places in the code still use no `loc` or default to line 1
                   # this is often in places where exceptions are used for the purposes
                   # of flow control. As a result max is in use to prevent slice from
                   # `[negative: positive]`
   68:             selected = lines[max(0, use_line - nlines_up):use_line]
       
                   # see if selected contains a definition
   68:             def_found = False
  204:             for x in selected:
  136:                 if 'def ' in x:
   13:                     def_found = True
       
                   # no definition found, try and find one
   68:             if not def_found:
                       # try and find a def, go backwards from error line
   55:                 fn_name = None
 2061:                 for x in reversed(lines[:use_line - 1]):
 2061:                     if 'def ' in x:
   55:                         fn_name = x
   55:                         break
   55:                 if fn_name:
   55:                     ret.append(fn_name)
   55:                     spaces = count_spaces(x)
   55:                     ret.append(' '*(4 + spaces) + '<source elided>\n')
       
   68:             if selected:
   68:                 ret.extend(selected[:-1])
   68:                 ret.append(_termcolor.highlight(selected[-1]))
       
                       # point at the problem with a caret
   68:                 spaces = count_spaces(selected[-1])
   68:                 ret.append(' '*(spaces) + _termcolor.indicate("^"))
       
               # if in the REPL source may not be available
   68:         if not ret:
                   if not lines:
                       ret = "<source missing, REPL/exec in use?>"
                   elif use_line <= 0:
                       ret = "<source line number missing>"
       
       
   68:         err = _termcolor.filename('\nFile "%s", line %d:')+'\n%s'
   68:         tmp = err % (self._get_path(), use_line, _termcolor.code(''.join(ret)))
   68:         return tmp
       
    1:     def with_lineno(self, line, col=None):
               """
               Return a new Loc with this line number.
               """
 1915:         return type(self)(self.filename, line, col)
       
    1:     def short(self):
               """
               Returns a short string
               """
  475:         shortfilename = os.path.basename(self.filename)
  475:         return "%s:%s" % (shortfilename, self.line)
       
       
       # Used for annotating errors when source location is unknown.
    1: unknown_loc = Loc("unknown location", 0, 0)
       
       
    3: @total_ordering
    2: class SlotEqualityCheckMixin(object):
           # some ir nodes are __dict__ free using __slots__ instead, this mixin
           # should not trigger the unintended creation of __dict__.
    1:     __slots__ = tuple()
       
    1:     def __eq__(self, other):
               if type(self) is type(other):
                   for name in self.__slots__:
                       if getattr(self, name) != getattr(other, name):
                           return False
                   else:
                       return True
               return False
       
    1:     def __le__(self, other):
               return str(self) <= str(other)
       
    1:     def __hash__(self):
               return id(self)
       
       
    3: @total_ordering
    2: class EqualityCheckMixin(object):
    1:     """ Mixin for basic equality checking """
       
    1:     def __eq__(self, other):
  784:         if type(self) is type(other):
  585:             def fixup(adict):
 1170:                 bad = ('loc', 'scope')
 1170:                 d = dict(adict)
 3510:                 for x in bad:
 2340:                     d.pop(x, None)
 1170:                 return d
  585:             d1 = fixup(self.__dict__)
  585:             d2 = fixup(other.__dict__)
  585:             if d1 == d2:
  202:                 return True
  582:         return False
       
    1:     def __le__(self, other):
               return str(self) < str(other)
       
    1:     def __hash__(self):
 8217:         return id(self)
       
       
    2: class VarMap(object):
    1:     def __init__(self):
   48:         self._con = {}
       
    1:     def define(self, name, var):
  808:         if name in self._con:
                   raise RedefinedError(name)
               else:
  808:             self._con[name] = var
       
    1:     def get(self, name):
  668:         try:
  668:             return self._con[name]
               except KeyError:
                   raise NotDefinedError(name)
       
    1:     def __contains__(self, name):
 6715:         return name in self._con
       
    1:     def __len__(self):
               return len(self._con)
       
    1:     def __repr__(self):
               return pprint.pformat(self._con)
       
    1:     def __hash__(self):
               return hash(self.name)
       
    1:     def __iter__(self):
               return self._con.iterkeys()
       
    1:     def __eq__(self, other):
               if type(self) is type(other):
                   # check keys only, else __eq__ ref cycles, scope -> varmap -> var
                   return self._con.keys() == other._con.keys()
               return False
       
    1:     def __ne__(self, other):
               return not self.__eq__(other)
       
       
    2: class AbstractRHS(object):
    1:     """Abstract base class for anything that can be the RHS of an assignment.
           This class **does not** define any methods.
           """
       
       
    2: class Inst(EqualityCheckMixin, AbstractRHS):
    1:     """
           Base class for all IR instructions.
           """
       
    1:     def list_vars(self):
               """
               List the variables used (read or written) by the instruction.
               """
               raise NotImplementedError
       
    1:     def _rec_list_vars(self, val):
               """
               A recursive helper used to implement list_vars() in subclasses.
               """
108913:         if isinstance(val, Var):
30061:             return [val]
78852:         elif isinstance(val, Inst):
 6026:             return val.list_vars()
72826:         elif isinstance(val, (list, tuple)):
 6744:             lst = []
12008:             for v in val:
 5264:                 lst.extend(self._rec_list_vars(v))
 6744:             return lst
66082:         elif isinstance(val, dict):
24831:             lst = []
103649:             for v in val.values():
78818:                 lst.extend(self._rec_list_vars(v))
24831:             return lst
               else:
41251:             return []
       
       
    2: class Stmt(Inst):
    1:     """
           Base class for IR statements (instructions which can appear on their
           own in a Block).
           """
           # Whether this statement ends its basic block (i.e. it will either jump
           # to another block or exit the function).
    1:     is_terminator = False
           # Whether this statement exits the function.
    1:     is_exit = False
       
    1:     def list_vars(self):
15544:         return self._rec_list_vars(self.__dict__)
       
       
    2: class Terminator(Stmt):
    1:     """
           IR statements that are terminators: the last statement in a block.
           A terminator must either:
           - exit the function
           - jump to a block
       
           All subclass of Terminator must override `.get_targets()` to return a list
           of jump targets.
           """
    1:     is_terminator = True
       
    1:     def get_targets(self):
               raise NotImplementedError(type(self))
       
       
    2: class Expr(Inst):
    1:     """
           An IR expression (an instruction which can only be part of a larger
           statement).
           """
       
    1:     def __init__(self, op, loc, **kws):
  335:         assert isinstance(op, str)
  335:         assert isinstance(loc, Loc)
  335:         self.op = op
  335:         self.loc = loc
  335:         self._kws = kws
       
    1:     def __getattr__(self, name):
 5939:         if name.startswith('_'):
   29:             return Inst.__getattr__(self, name)
 5910:         return self._kws[name]
       
    1:     def __setattr__(self, name, value):
 1005:         if name in ('op', 'loc', '_kws'):
 1005:             self.__dict__[name] = value
               else:
                   self._kws[name] = value
       
    2:     @classmethod
    2:     def binop(cls, fn, lhs, rhs, loc):
   54:         assert isinstance(fn, BuiltinFunctionType)
   54:         assert isinstance(lhs, Var)
   54:         assert isinstance(rhs, Var)
   54:         assert isinstance(loc, Loc)
   54:         op = 'binop'
  108:         return cls(op=op, loc=loc, fn=fn, lhs=lhs, rhs=rhs,
   54:                    static_lhs=UNDEFINED, static_rhs=UNDEFINED)
       
    2:     @classmethod
    2:     def inplace_binop(cls, fn, immutable_fn, lhs, rhs, loc):
    5:         assert isinstance(fn, BuiltinFunctionType)
    5:         assert isinstance(immutable_fn, BuiltinFunctionType)
    5:         assert isinstance(lhs, Var)
    5:         assert isinstance(rhs, Var)
    5:         assert isinstance(loc, Loc)
    5:         op = 'inplace_binop'
   10:         return cls(op=op, loc=loc, fn=fn, immutable_fn=immutable_fn,
    5:                    lhs=lhs, rhs=rhs,
    5:                    static_lhs=UNDEFINED, static_rhs=UNDEFINED)
       
    2:     @classmethod
    2:     def unary(cls, fn, value, loc):
    4:         assert isinstance(value, (str, Var, FunctionType))
    4:         assert isinstance(loc, Loc)
    4:         op = 'unary'
    4:         fn = UNARY_BUITINS_TO_OPERATORS.get(fn, fn)
    4:         return cls(op=op, loc=loc, fn=fn, value=value)
       
    2:     @classmethod
    2:     def call(cls, func, args, kws, loc, vararg=None, varkwarg=None, target=None):
  101:         assert isinstance(func, Var)
  101:         assert isinstance(loc, Loc)
  101:         op = 'call'
  202:         return cls(op=op, loc=loc, func=func, args=args, kws=kws,
  101:                    vararg=vararg, varkwarg=varkwarg, target=target)
       
    2:     @classmethod
    2:     def build_tuple(cls, items, loc):
   16:         assert isinstance(loc, Loc)
   16:         op = 'build_tuple'
   16:         return cls(op=op, loc=loc, items=items)
       
    2:     @classmethod
    2:     def build_list(cls, items, loc):
               assert isinstance(loc, Loc)
               op = 'build_list'
               return cls(op=op, loc=loc, items=items)
       
    2:     @classmethod
    2:     def build_set(cls, items, loc):
               assert isinstance(loc, Loc)
               op = 'build_set'
               return cls(op=op, loc=loc, items=items)
       
    2:     @classmethod
    2:     def build_map(cls, items, size, literal_value, value_indexes, loc):
               assert isinstance(loc, Loc)
               op = 'build_map'
               return cls(op=op, loc=loc, items=items, size=size,
                          literal_value=literal_value, value_indexes=value_indexes)
       
    2:     @classmethod
    2:     def pair_first(cls, value, loc):
    5:         assert isinstance(value, Var)
    5:         op = 'pair_first'
    5:         return cls(op=op, loc=loc, value=value)
       
    2:     @classmethod
    2:     def pair_second(cls, value, loc):
    5:         assert isinstance(value, Var)
    5:         assert isinstance(loc, Loc)
    5:         op = 'pair_second'
    5:         return cls(op=op, loc=loc, value=value)
       
    2:     @classmethod
    2:     def getiter(cls, value, loc):
    5:         assert isinstance(value, Var)
    5:         assert isinstance(loc, Loc)
    5:         op = 'getiter'
    5:         return cls(op=op, loc=loc, value=value)
       
    2:     @classmethod
    2:     def iternext(cls, value, loc):
    5:         assert isinstance(value, Var)
    5:         assert isinstance(loc, Loc)
    5:         op = 'iternext'
    5:         return cls(op=op, loc=loc, value=value)
       
    2:     @classmethod
    2:     def exhaust_iter(cls, value, count, loc):
               assert isinstance(value, Var)
               assert isinstance(count, int)
               assert isinstance(loc, Loc)
               op = 'exhaust_iter'
               return cls(op=op, loc=loc, value=value, count=count)
       
    2:     @classmethod
    2:     def getattr(cls, value, attr, loc):
   50:         assert isinstance(value, Var)
   50:         assert isinstance(attr, str)
   50:         assert isinstance(loc, Loc)
   50:         op = 'getattr'
   50:         return cls(op=op, loc=loc, value=value, attr=attr)
       
    2:     @classmethod
    2:     def getitem(cls, value, index, loc):
   20:         assert isinstance(value, Var)
   20:         assert isinstance(index, Var)
   20:         assert isinstance(loc, Loc)
   20:         op = 'getitem'
   20:         fn = operator.getitem
   20:         return cls(op=op, loc=loc, value=value, index=index, fn=fn)
       
    2:     @classmethod
    2:     def typed_getitem(cls, value, dtype, index, loc):
               assert isinstance(value, Var)
               assert isinstance(loc, Loc)
               op = 'typed_getitem'
               return cls(op=op, loc=loc, value=value, dtype=dtype,
                          index=index)
       
    2:     @classmethod
    2:     def static_getitem(cls, value, index, index_var, loc):
    8:         assert isinstance(value, Var)
    8:         assert index_var is None or isinstance(index_var, Var)
    8:         assert isinstance(loc, Loc)
    8:         op = 'static_getitem'
    8:         fn = operator.getitem
   16:         return cls(op=op, loc=loc, value=value, index=index,
    8:                    index_var=index_var, fn=fn)
       
    2:     @classmethod
    2:     def cast(cls, value, loc):
               """
               A node for implicit casting at the return statement
               """
   36:         assert isinstance(value, Var)
   36:         assert isinstance(loc, Loc)
   36:         op = 'cast'
   36:         return cls(op=op, value=value, loc=loc)
       
    2:     @classmethod
    2:     def phi(cls, loc):
               """Phi node
               """
   17:         assert isinstance(loc, Loc)
   17:         return cls(op='phi', incoming_values=[], incoming_blocks=[], loc=loc)
       
    2:     @classmethod
    2:     def make_function(cls, name, code, closure, defaults, loc):
               """
               A node for making a function object.
               """
               assert isinstance(loc, Loc)
               op = 'make_function'
               return cls(op=op, name=name, code=code, closure=closure, defaults=defaults, loc=loc)
       
    2:     @classmethod
    2:     def null(cls, loc):
               """
               A node for null value.
       
               This node is not handled by type inference. It is only added by
               post-typing passes.
               """
               assert isinstance(loc, Loc)
               op = 'null'
               return cls(op=op, loc=loc)
       
    2:     @classmethod
    2:     def undef(cls, loc):
               """
               A node for undefined value specifically from LOAD_FAST_AND_CLEAR opcode.
               """
               assert isinstance(loc, Loc)
               op = 'undef'
               return cls(op=op, loc=loc)
       
    2:     @classmethod
    2:     def dummy(cls, op, info, loc):
               """
               A node for a dummy value.
       
               This node is a place holder for carrying information through to a point
               where it is rewritten into something valid. This node is not handled
               by type inference or lowering. It's presence outside of the interpreter
               renders IR as illegal.
               """
               assert isinstance(loc, Loc)
               assert isinstance(op, str)
               return cls(op=op, info=info, loc=loc)
       
    1:     def __repr__(self):
  753:         if self.op == 'call':
  957:             args = ', '.join(str(a) for a in self.args)
  295:             pres_order = self._kws.items() if config.DIFF_IR == 0 else sorted(self._kws.items())
 2360:             kws = ', '.join('%s=%s' % (k, v) for k, v in pres_order)
  295:             vararg = '*%s' % (self.vararg,) if self.vararg is not None else ''
  295:             arglist = ', '.join(filter(None, [args, vararg, kws]))
  295:             return 'call %s(%s)' % (self.func, arglist)
  458:         elif self.op == 'binop':
  101:             lhs, rhs = self.lhs, self.rhs
  101:             if self.fn == operator.contains:
                       lhs, rhs = rhs, lhs
  101:             fn = OPERATORS_TO_BUILTINS.get(self.fn, self.fn)
  101:             return '%s %s %s' % (lhs, fn, rhs)
               else:
  357:             pres_order = self._kws.items() if config.DIFF_IR == 0 else sorted(self._kws.items())
 1354:             args = ('%s=%s' % (k, v) for k, v in pres_order)
  357:             return '%s(%s)' % (self.op, ', '.join(args))
       
    1:     def list_vars(self):
 9287:         return self._rec_list_vars(self._kws)
       
    1:     def infer_constant(self):
   51:         raise ConstantInferenceError('%s' % self, loc=self.loc)
       
       
    2: class SetItem(Stmt):
    1:     """
           target[index] = value
           """
       
    1:     def __init__(self, target, index, value, loc):
    6:         assert isinstance(target, Var)
    6:         assert isinstance(index, Var)
    6:         assert isinstance(value, Var)
    6:         assert isinstance(loc, Loc)
    6:         self.target = target
    6:         self.index = index
    6:         self.value = value
    6:         self.loc = loc
       
    1:     def __repr__(self):
   12:         return '%s[%s] = %s' % (self.target, self.index, self.value)
       
       
    2: class StaticSetItem(Stmt):
    1:     """
           target[constant index] = value
           """
       
    1:     def __init__(self, target, index, index_var, value, loc):
               assert isinstance(target, Var)
               assert not isinstance(index, Var)
               assert isinstance(index_var, Var)
               assert isinstance(value, Var)
               assert isinstance(loc, Loc)
               self.target = target
               self.index = index
               self.index_var = index_var
               self.value = value
               self.loc = loc
       
    1:     def __repr__(self):
               return '%s[%r] = %s' % (self.target, self.index, self.value)
       
       
    2: class DelItem(Stmt):
    1:     """
           del target[index]
           """
       
    1:     def __init__(self, target, index, loc):
               assert isinstance(target, Var)
               assert isinstance(index, Var)
               assert isinstance(loc, Loc)
               self.target = target
               self.index = index
               self.loc = loc
       
    1:     def __repr__(self):
               return 'del %s[%s]' % (self.target, self.index)
       
       
    2: class SetAttr(Stmt):
    1:     def __init__(self, target, attr, value, loc):
               assert isinstance(target, Var)
               assert isinstance(attr, str)
               assert isinstance(value, Var)
               assert isinstance(loc, Loc)
               self.target = target
               self.attr = attr
               self.value = value
               self.loc = loc
       
    1:     def __repr__(self):
               return '(%s).%s = %s' % (self.target, self.attr, self.value)
       
       
    2: class DelAttr(Stmt):
    1:     def __init__(self, target, attr, loc):
               assert isinstance(target, Var)
               assert isinstance(attr, str)
               assert isinstance(loc, Loc)
               self.target = target
               self.attr = attr
               self.loc = loc
       
    1:     def __repr__(self):
               return 'del (%s).%s' % (self.target, self.attr)
       
       
    2: class StoreMap(Stmt):
    1:     def __init__(self, dct, key, value, loc):
               assert isinstance(dct, Var)
               assert isinstance(key, Var)
               assert isinstance(value, Var)
               assert isinstance(loc, Loc)
               self.dct = dct
               self.key = key
               self.value = value
               self.loc = loc
       
    1:     def __repr__(self):
               return '%s[%s] = %s' % (self.dct, self.key, self.value)
       
       
    2: class Del(Stmt):
    1:     def __init__(self, value, loc):
 1790:         assert isinstance(value, str)
 1790:         assert isinstance(loc, Loc)
 1790:         self.value = value
 1790:         self.loc = loc
       
    1:     def __str__(self):
  597:         return "del %s" % self.value
       
       
    2: class Raise(Terminator):
    1:     is_exit = True
       
    1:     def __init__(self, exception, loc):
    2:         assert exception is None or isinstance(exception, Var)
    2:         assert isinstance(loc, Loc)
    2:         self.exception = exception
    2:         self.loc = loc
       
    1:     def __str__(self):
    2:         return "raise %s" % self.exception
       
    1:     def get_targets(self):
   18:         return []
       
       
    2: class StaticRaise(Terminator):
    1:     """
           Raise an exception class and arguments known at compile-time.
           Note that if *exc_class* is None, a bare "raise" statement is implied
           (i.e. re-raise the current exception).
           """
    1:     is_exit = True
       
    1:     def __init__(self, exc_class, exc_args, loc):
    1:         assert exc_class is None or isinstance(exc_class, type)
    1:         assert isinstance(loc, Loc)
    1:         assert exc_args is None or isinstance(exc_args, tuple)
    1:         self.exc_class = exc_class
    1:         self.exc_args = exc_args
    1:         self.loc = loc
       
    1:     def __str__(self):
    1:         if self.exc_class is None:
                   return "<static> raise"
    1:         elif self.exc_args is None:
    1:             return "<static> raise %s" % (self.exc_class,)
               else:
                   return "<static> raise %s(%s)" % (self.exc_class,
                                            ", ".join(map(repr, self.exc_args)))
       
    1:     def get_targets(self):
   15:         return []
       
       
    2: class DynamicRaise(Terminator):
    1:     """
           Raise an exception class and some argument *values* unknown at compile-time.
           Note that if *exc_class* is None, a bare "raise" statement is implied
           (i.e. re-raise the current exception).
           """
    1:     is_exit = True
       
    1:     def __init__(self, exc_class, exc_args, loc):
               assert exc_class is None or isinstance(exc_class, type)
               assert isinstance(loc, Loc)
               assert exc_args is None or isinstance(exc_args, tuple)
               self.exc_class = exc_class
               self.exc_args = exc_args
               self.loc = loc
       
    1:     def __str__(self):
               if self.exc_class is None:
                   return "<dynamic> raise"
               elif self.exc_args is None:
                   return "<dynamic> raise %s" % (self.exc_class,)
               else:
                   return "<dynamic> raise %s(%s)" % (self.exc_class,
                                            ", ".join(map(repr, self.exc_args)))
       
    1:     def get_targets(self):
               return []
       
       
    2: class TryRaise(Stmt):
    1:     """A raise statement inside a try-block
           Similar to ``Raise`` but does not terminate.
           """
    1:     def __init__(self, exception, loc):
               assert exception is None or isinstance(exception, Var)
               assert isinstance(loc, Loc)
               self.exception = exception
               self.loc = loc
       
    1:     def __str__(self):
               return "try_raise %s" % self.exception
       
       
    2: class StaticTryRaise(Stmt):
    1:     """A raise statement inside a try-block.
           Similar to ``StaticRaise`` but does not terminate.
           """
    1:     def __init__(self, exc_class, exc_args, loc):
               assert exc_class is None or isinstance(exc_class, type)
               assert isinstance(loc, Loc)
               assert exc_args is None or isinstance(exc_args, tuple)
               self.exc_class = exc_class
               self.exc_args = exc_args
               self.loc = loc
       
    1:     def __str__(self):
               if self.exc_class is None:
                   return f"static_try_raise"
               elif self.exc_args is None:
                   return f"static_try_raise {self.exc_class}"
               else:
                   args = ", ".join(map(repr, self.exc_args))
                   return f"static_try_raise {self.exc_class}({args})"
       
       
    2: class DynamicTryRaise(Stmt):
    1:     """A raise statement inside a try-block.
           Similar to ``DynamicRaise`` but does not terminate.
           """
    1:     def __init__(self, exc_class, exc_args, loc):
               assert exc_class is None or isinstance(exc_class, type)
               assert isinstance(loc, Loc)
               assert exc_args is None or isinstance(exc_args, tuple)
               self.exc_class = exc_class
               self.exc_args = exc_args
               self.loc = loc
       
    1:     def __str__(self):
               if self.exc_class is None:
                   return f"dynamic_try_raise"
               elif self.exc_args is None:
                   return f"dynamic_try_raise {self.exc_class}"
               else:
                   args = ", ".join(map(repr, self.exc_args))
                   return f"dynamic_try_raise {self.exc_class}({args})"
       
       
    2: class Return(Terminator):
    1:     """
           Return to caller.
           """
    1:     is_exit = True
       
    1:     def __init__(self, value, loc):
   36:         assert isinstance(value, Var), type(value)
   36:         assert isinstance(loc, Loc)
   36:         self.value = value
   36:         self.loc = loc
       
    1:     def __str__(self):
   70:         return 'return %s' % self.value
       
    1:     def get_targets(self):
  834:         return []
       
       
    2: class Jump(Terminator):
    1:     """
           Unconditional branch.
           """
       
    1:     def __init__(self, target, loc):
   33:         assert isinstance(loc, Loc)
   33:         self.target = target
   33:         self.loc = loc
       
    1:     def __str__(self):
   53:         return 'jump %s' % self.target
       
    1:     def get_targets(self):
  861:         return [self.target]
       
       
    2: class Branch(Terminator):
    1:     """
           Conditional branch.
           """
       
    1:     def __init__(self, cond, truebr, falsebr, loc):
   37:         assert isinstance(cond, Var)
   37:         assert isinstance(loc, Loc)
   37:         self.cond = cond
   37:         self.truebr = truebr
   37:         self.falsebr = falsebr
   37:         self.loc = loc
       
   70:     def __str__(self):
   69:         return 'branch %s, %s, %s' % (self.cond, self.truebr, self.falsebr)
       
    1:     def get_targets(self):
  975:         return [self.truebr, self.falsebr]
       
       
    2: class Assign(Stmt):
    1:     """
           Assign to a variable.
           """
    1:     def __init__(self, value, target, loc):
  910:         assert isinstance(value, AbstractRHS)
  910:         assert isinstance(target, Var)
  910:         assert isinstance(loc, Loc)
  910:         self.value = value
  910:         self.target = target
  910:         self.loc = loc
       
    1:     def __str__(self):
 1110:         return '%s = %s' % (self.target, self.value)
       
       
    2: class Print(Stmt):
    1:     """
           Print some values.
           """
    1:     def __init__(self, args, vararg, loc):
               assert all(isinstance(x, Var) for x in args)
               assert vararg is None or isinstance(vararg, Var)
               assert isinstance(loc, Loc)
               self.args = tuple(args)
               self.vararg = vararg
               # Constant-inferred arguments
               self.consts = {}
               self.loc = loc
       
    1:     def __str__(self):
               return 'print(%s)' % ', '.join(str(v) for v in self.args)
       
       
    2: class Yield(Inst):
    1:     def __init__(self, value, loc, index):
               assert isinstance(value, Var)
               assert isinstance(loc, Loc)
               self.value = value
               self.loc = loc
               self.index = index
       
    1:     def __str__(self):
               return 'yield %s' % (self.value,)
       
    1:     def list_vars(self):
               return [self.value]
       
       
    2: class EnterWith(Stmt):
    1:     """Enter a "with" context
           """
    1:     def __init__(self, contextmanager, begin, end, loc):
               """
               Parameters
               ----------
               contextmanager : IR value
               begin, end : int
                   The beginning and the ending offset of the with-body.
               loc : ir.Loc instance
                   Source location
               """
               assert isinstance(contextmanager, Var)
               assert isinstance(loc, Loc)
               self.contextmanager = contextmanager
               self.begin = begin
               self.end = end
               self.loc = loc
       
    1:     def __str__(self):
               return 'enter_with {}'.format(self.contextmanager)
       
    1:     def list_vars(self):
               return [self.contextmanager]
       
       
    2: class PopBlock(Stmt):
    1:     """Marker statement for a pop block op code"""
    1:     def __init__(self, loc):
               assert isinstance(loc, Loc)
               self.loc = loc
       
    1:     def __str__(self):
               return 'pop_block'
       
       
    2: class Arg(EqualityCheckMixin, AbstractRHS):
    1:     def __init__(self, name, index, loc):
   55:         assert isinstance(name, str)
   55:         assert isinstance(index, int)
   55:         assert isinstance(loc, Loc)
   55:         self.name = name
   55:         self.index = index
   55:         self.loc = loc
       
    1:     def __repr__(self):
  112:         return 'arg(%d, name=%s)' % (self.index, self.name)
       
    1:     def infer_constant(self):
    1:         raise ConstantInferenceError('%s' % self, loc=self.loc)
       
       
    2: class Const(EqualityCheckMixin, AbstractRHS):
    1:     def __init__(self, value, loc, use_literal_type=True):
   57:         assert isinstance(loc, Loc)
   57:         self.value = value
   57:         self.loc = loc
               # Note: need better way to tell if this is a literal or not.
   57:         self.use_literal_type = use_literal_type
       
  110:     def __repr__(self):
  109:         return 'const(%s, %s)' % (type(self.value).__name__, self.value)
       
    1:     def infer_constant(self):
    8:         return self.value
       
    1:     def __deepcopy__(self, memo):
               # Override to not copy constant values in code
               return Const(
                   value=self.value, loc=self.loc,
                   use_literal_type=self.use_literal_type,
               )
       
       
    2: class Global(EqualityCheckMixin, AbstractRHS):
    1:     def __init__(self, name, value, loc):
   96:         assert isinstance(loc, Loc)
   96:         self.name = name
   96:         self.value = value
   96:         self.loc = loc
       
  188:     def __str__(self):
  187:         return 'global(%s: %s)' % (self.name, self.value)
       
    1:     def infer_constant(self):
   89:         return self.value
       
    1:     def __deepcopy__(self, memo):
               # don't copy value since it can fail (e.g. modules)
               # value is readonly and doesn't need copying
               return Global(self.name, self.value, copy.deepcopy(self.loc))
       
       
    2: class FreeVar(EqualityCheckMixin, AbstractRHS):
    1:     """
           A freevar, as loaded by LOAD_DECREF.
           (i.e. a variable defined in an enclosing non-global scope)
           """
       
    1:     def __init__(self, index, name, value, loc):
   12:         assert isinstance(index, int)
   12:         assert isinstance(name, str)
   12:         assert isinstance(loc, Loc)
               # index inside __code__.co_freevars
   12:         self.index = index
               # variable name
   12:         self.name = name
               # frozen value
   12:         self.value = value
   12:         self.loc = loc
       
   23:     def __str__(self):
   22:         return 'freevar(%s: %s)' % (self.name, self.value)
       
    1:     def infer_constant(self):
    6:         return self.value
       
    1:     def __deepcopy__(self, memo):
               # Override to not copy constant values in code
               return FreeVar(index=self.index, name=self.name, value=self.value,
                              loc=self.loc)
       
       
       
    2: class Var(EqualityCheckMixin, AbstractRHS):
    1:     """
           Attributes
           -----------
           - scope: Scope
       
           - name: str
       
           - loc: Loc
               Definition location
           """
       
    1:     def __init__(self, scope, name, loc):
               # NOTE: Use of scope=None should be removed.
  841:         assert scope is None or isinstance(scope, Scope)
  841:         assert isinstance(name, str)
  841:         assert isinstance(loc, Loc)
  841:         self.scope = scope
  841:         self.name = name
  841:         self.loc = loc
       
  476:     def __repr__(self):
  475:         return 'Var(%s, %s)' % (self.name, self.loc.short())
       
    1:     def __str__(self):
 4083:         return self.name
       
    2:     @property
    2:     def is_temp(self):
 1072:         return self.name.startswith("$")
       
    2:     @property
    2:     def unversioned_name(self):
               """The unversioned name of this variable, i.e. SSA renaming removed
               """
               for k, redef_set in self.scope.var_redefinitions.items():
                   if self.name in redef_set:
                       return k
               return self.name
       
    2:     @property
    2:     def versioned_names(self):
               """Known versioned names for this variable, i.e. known variable names in
               the scope that have been formed from applying SSA to this variable
               """
               return self.scope.get_versions_of(self.unversioned_name)
       
    2:     @property
    2:     def all_names(self):
               """All known versioned and unversioned names for this variable
               """
               return self.versioned_names | {self.unversioned_name,}
       
    1:     def __deepcopy__(self, memo):
               out = Var(copy.deepcopy(self.scope, memo), self.name, self.loc)
               memo[id(self)] = out
               return out
       
       
    2: class Scope(EqualityCheckMixin):
    1:     """
           Attributes
           -----------
           - parent: Scope
               Parent scope
       
           - localvars: VarMap
               Scope-local variable map
       
           - loc: Loc
               Start of scope location
       
           """
       
    1:     def __init__(self, parent, loc):
   48:         assert parent is None or isinstance(parent, Scope)
   48:         assert isinstance(loc, Loc)
   48:         self.parent = parent
   48:         self.localvars = VarMap()
   48:         self.loc = loc
   48:         self.redefined = defaultdict(int)
   48:         self.var_redefinitions = defaultdict(set)
       
    1:     def define(self, name, loc):
               """
               Define a variable
               """
  808:         v = Var(scope=self, name=name, loc=loc)
  808:         self.localvars.define(v.name, v)
  808:         return v
       
    1:     def get(self, name):
               """
               Refer to a variable.  Returns the latest version.
               """
  650:         if name in self.redefined:
    7:             name = "%s.%d" % (name, self.redefined[name])
  650:         return self.get_exact(name)
       
    1:     def get_exact(self, name):
               """
               Refer to a variable.  The returned variable has the exact
               name (exact variable version).
               """
  650:         try:
  650:             return self.localvars.get(name)
               except NotDefinedError:
                   if self.has_parent:
                       return self.parent.get(name)
                   else:
                       raise
       
    1:     def get_or_define(self, name, loc):
  524:         if name in self.redefined:
    1:             name = "%s.%d" % (name, self.redefined[name])
       
  524:         if name not in self.localvars:
  506:             return self.define(name, loc)
               else:
   18:             return self.localvars.get(name)
       
    1:     def redefine(self, name, loc, rename=True):
               """
               Redefine if the name is already defined
               """
  302:         if name not in self.localvars:
  258:             return self.define(name, loc)
   44:         elif not rename:
                   # Must use the same name if the variable is a cellvar, which
                   # means it could be captured in a closure.
                   return self.localvars.get(name)
               else:
   44:             while True:
   44:                 ct = self.redefined[name]
   44:                 self.redefined[name] = ct + 1
   44:                 newname = "%s.%d" % (name, ct + 1)
   44:                 try:
   44:                     res = self.define(newname, loc)
                       except RedefinedError:
                           continue
                       else:
   44:                     self.var_redefinitions[name].add(newname)
   44:                 return res
       
    1:     def get_versions_of(self, name):
               """
               Gets all known versions of a given name
               """
               vers = set()
               def walk(thename):
                   redefs = self.var_redefinitions.get(thename, None)
                   if redefs:
                       for v in redefs:
                           vers.add(v)
                           walk(v)
               walk(name)
               return vers
       
    1:     def make_temp(self, loc):
               n = len(self.localvars)
               v = Var(scope=self, name='$%d' % n, loc=loc)
               self.localvars.define(v.name, v)
               return v
       
    2:     @property
    2:     def has_parent(self):
               return self.parent is not None
       
    1:     def __repr__(self):
               return "Scope(has_parent=%r, num_vars=%d, %s)" % (self.has_parent,
                                                                 len(self.localvars),
                                                                 self.loc)
       
       
    2: class Block(EqualityCheckMixin):
    1:     """A code block
       
           """
       
    1:     def __init__(self, scope, loc):
  644:         assert isinstance(scope, Scope)
  644:         assert isinstance(loc, Loc)
  644:         self.scope = scope
  644:         self.body = []
  644:         self.loc = loc
       
    1:     def copy(self):
  112:         block = Block(self.scope, self.loc)
  112:         block.body = self.body[:]
  112:         return block
       
    1:     def find_exprs(self, op=None):
               """
               Iterate over exprs of the given *op* in this block.
               """
 5780:         for inst in self.body:
 5202:             if isinstance(inst, Assign):
 3394:                 expr = inst.value
 3394:                 if isinstance(expr, Expr):
 1850:                     if op is None or expr.op == op:
  279:                         yield expr
       
    1:     def find_insts(self, cls=None):
               """
               Iterate over insts of the given class in this block.
               """
36669:         for inst in self.body:
33076:             if isinstance(inst, cls):
 8896:                 yield inst
       
    1:     def find_variable_assignment(self, name):
               """
               Returns the assignment inst associated with variable "name", None if
               it cannot be found.
               """
               for x in self.find_insts(cls=Assign):
                   if x.target.name == name:
                       return x
               return None
       
    1:     def prepend(self, inst):
  412:         assert isinstance(inst, Stmt)
  412:         self.body.insert(0, inst)
       
    1:     def append(self, inst):
 1139:         assert isinstance(inst, Stmt)
 1139:         self.body.append(inst)
       
    1:     def remove(self, inst):
               assert isinstance(inst, Stmt)
               del self.body[self.body.index(inst)]
       
    1:     def clear(self):
   13:         del self.body[:]
       
    1:     def dump(self, file=None):
               # Avoid early bind of sys.stdout as default value
  100:         file = file or sys.stdout
  755:         for inst in self.body:
  655:             if hasattr(inst, 'dump'):
                       inst.dump(file)
                   else:
 2504:                 inst_vars = sorted(str(v) for v in inst.list_vars())
  655:                 print('    %-40s %s' % (inst, inst_vars), file=file)
       
    2:     @property
    2:     def terminator(self):
 3806:         return self.body[-1]
       
    2:     @property
    2:     def is_terminated(self):
  207:         return self.body and self.body[-1].is_terminator
       
    1:     def verify(self):
   13:         if not self.is_terminated:
                   raise VerificationError("Missing block terminator")
                   # Only the last instruction can be a terminator
  254:         for inst in self.body[:-1]:
  241:             if inst.is_terminator:
                       raise VerificationError("Terminator before the last "
                                               "instruction")
       
    1:     def insert_after(self, stmt, other):
               """
               Insert *stmt* after *other*.
               """
   25:         index = self.body.index(other)
   25:         self.body.insert(index + 1, stmt)
       
    1:     def insert_before_terminator(self, stmt):
    6:         assert isinstance(stmt, Stmt)
    6:         assert self.is_terminated
    6:         self.body.insert(-1, stmt)
       
    1:     def __repr__(self):
               return "<ir.Block at %s>" % (self.loc,)
       
       
    2: class Loop(SlotEqualityCheckMixin):
    1:     """Describes a loop-block
           """
    1:     __slots__ = "entry", "exit"
       
    1:     def __init__(self, entry, exit):
               self.entry = entry
               self.exit = exit
       
    1:     def __repr__(self):
               args = self.entry, self.exit
               return "Loop(entry=%s, exit=%s)" % args
       
       
    2: class With(SlotEqualityCheckMixin):
    1:     """Describes a with-block
           """
    1:     __slots__ = "entry", "exit"
       
    1:     def __init__(self, entry, exit):
               self.entry = entry
               self.exit = exit
       
    1:     def __repr__(self):
               args = self.entry, self.exit
               return "With(entry=%s, exit=%s)" % args
       
       
    2: class FunctionIR(object):
       
    1:     def __init__(self, blocks, is_generator, func_id, loc,
                        definitions, arg_count, arg_names):
   24:         self.blocks = blocks
   24:         self.is_generator = is_generator
   24:         self.func_id = func_id
   24:         self.loc = loc
   24:         self.arg_count = arg_count
   24:         self.arg_names = arg_names
       
   24:         self._definitions = definitions
       
   24:         self._reset_analysis_variables()
       
    1:     def equal_ir(self, other):
               """ Checks that the IR contained within is equal to the IR in other.
               Equality is defined by being equal in fundamental structure (blocks,
               labels, IR node type and the order in which they are defined) and the
               IR nodes being equal. IR node equality essentially comes down to
               ensuring a node's `.__dict__` or `.__slots__` is equal, with the
               exception of ignoring 'loc' and 'scope' entries. The upshot is that the
               comparison is essentially location and scope invariant, but otherwise
               behaves as unsurprisingly as possible.
               """
               if type(self) is type(other):
                   return self.blocks == other.blocks
               return False
       
    1:     def diff_str(self, other):
               """
               Compute a human readable difference in the IR, returns a formatted
               string ready for printing.
               """
               msg = []
               for label, block in self.blocks.items():
                   other_blk = other.blocks.get(label, None)
                   if other_blk is not None:
                       if block != other_blk:
                           msg.append(("Block %s differs" % label).center(80, '-'))
                           # see if the instructions are just a permutation
                           block_del = [x for x in block.body if isinstance(x, Del)]
                           oth_del = [x for x in other_blk.body if isinstance(x, Del)]
                           if block_del != oth_del:
                               # this is a common issue, dels are all present, but
                               # order shuffled.
                               if sorted(block_del) == sorted(oth_del):
                                   msg.append(("Block %s contains the same dels but "
                                               "their order is different") % label)
                           if len(block.body) > len(other_blk.body):
                               msg.append("This block contains more statements")
                           elif len(block.body) < len(other_blk.body):
                               msg.append("Other block contains more statements")
       
                           # find the indexes where they don't match
                           tmp = []
                           for idx, stmts in enumerate(zip(block.body,
                                                           other_blk.body)):
                               b_s, o_s = stmts
                               if b_s != o_s:
                                   tmp.append(idx)
       
                           def get_pad(ablock, l):
                               pointer = '-> '
                               sp = len(pointer) * ' '
                               pad = []
                               nstmt = len(ablock)
                               for i in range(nstmt):
                                   if i in tmp:
                                       item = pointer
                                   elif i >= l:
                                       item = pointer
                                   else:
                                       item = sp
                                   pad.append(item)
                               return pad
       
                           min_stmt_len = min(len(block.body), len(other_blk.body))
       
                           with StringIO() as buf:
                               it = [("self", block), ("other", other_blk)]
                               for name, _block in it:
                                   buf.truncate(0)
                                   _block.dump(file=buf)
                                   stmts = buf.getvalue().splitlines()
                                   pad = get_pad(_block.body, min_stmt_len)
                                   title = ("%s: block %s" % (name, label))
                                   msg.append(title.center(80, '-'))
                                   msg.extend(["{0}{1}".format(a, b) for a, b in
                                               zip(pad, stmts)])
               if msg == []:
                   msg.append("IR is considered equivalent.")
               return '\n'.join(msg)
       
    1:     def _reset_analysis_variables(self):
       
   24:         self._consts = consts.ConstantInference(self)
       
               # Will be computed by PostProcessor
   24:         self.generator_info = None
   24:         self.variable_lifetime = None
               # { ir.Block: { variable names (potentially) alive at start of block } }
   24:         self.block_entry_vars = {}
       
    2:     def derive(self, blocks, arg_count=None, arg_names=None,
    1:                force_non_generator=False):
               """
               Derive a new function IR from this one, using the given blocks,
               and possibly modifying the argument count and generator flag.
       
               Post-processing will have to be run again on the new IR.
               """
               firstblock = blocks[min(blocks)]
       
               new_ir = copy.copy(self)
               new_ir.blocks = blocks
               new_ir.loc = firstblock.loc
               if force_non_generator:
                   new_ir.is_generator = False
               if arg_count is not None:
                   new_ir.arg_count = arg_count
               if arg_names is not None:
                   new_ir.arg_names = arg_names
               new_ir._reset_analysis_variables()
               # Make fresh func_id
               new_ir.func_id = new_ir.func_id.derive()
               return new_ir
       
    1:     def copy(self):
   24:         new_ir = copy.copy(self)
   24:         blocks = {}
   24:         block_entry_vars = {}
  119:         for label, block in self.blocks.items():
   95:             new_block = block.copy()
   95:             blocks[label] = new_block
   95:             if block in self.block_entry_vars:
   95:                 block_entry_vars[new_block] = self.block_entry_vars[block]
   24:         new_ir.blocks = blocks
   24:         new_ir.block_entry_vars = block_entry_vars
   24:         return new_ir
       
    1:     def get_block_entry_vars(self, block):
               """
               Return a set of variable names possibly alive at the beginning of
               the block.
               """
               return self.block_entry_vars[block]
       
    1:     def infer_constant(self, name):
               """
               Try to infer the constant value of a given variable.
               """
  127:         if isinstance(name, Var):
  127:             name = name.name
  127:         return self._consts.infer_constant(name)
       
    1:     def get_definition(self, value, lhs_only=False):
               """
               Get the definition site for the given variable name or instance.
               A Expr instance is returned by default, but if lhs_only is set
               to True, the left-hand-side variable is returned instead.
               """
 1429:         lhs = value
 2822:         while True:
 2822:             if isinstance(value, Var):
 1209:                 lhs = value
 1209:                 name = value.name
 1613:             elif isinstance(value, str):
  226:                 lhs = value
  226:                 name = value
                   else:
 1387:                 return lhs if lhs_only else value
 1435:             defs = self._definitions[name]
 1435:             if len(defs) == 0:
                       raise KeyError("no definition for %r"
                                      % (name,))
 1435:             if len(defs) > 1:
   84:                 raise KeyError("more than one definition for %r"
   42:                                % (name,))
 1393:             value = defs[0]
       
    1:     def get_assignee(self, rhs_value, in_blocks=None):
               """
               Finds the assignee for a given RHS value. If in_blocks is given the
               search will be limited to the specified blocks.
               """
               if in_blocks is None:
                   blocks = self.blocks.values()
               elif isinstance(in_blocks, int):
                   blocks = [self.blocks[in_blocks]]
               else:
                   blocks = [self.blocks[blk] for blk in list(in_blocks)]
       
               assert isinstance(rhs_value, AbstractRHS)
       
               for blk in blocks:
                   for assign in blk.find_insts(Assign):
                       if assign.value == rhs_value:
                           return assign.target
       
               raise ValueError("Could not find an assignee for %s" % rhs_value)
       
       
    1:     def dump(self, file=None):
   24:         nofile = file is None
               # Avoid early bind of sys.stdout as default value
   24:         file = file or StringIO()
  124:         for offset, block in sorted(self.blocks.items()):
  100:             print('label %s:' % (offset,), file=file)
  100:             block.dump(file=file)
   24:         if nofile:
                   text = file.getvalue()
                   if config.HIGHLIGHT_DUMPS:
                       try:
                           import pygments
                       except ImportError:
                           msg = "Please install pygments to see highlighted dumps"
                           raise ValueError(msg)
                       else:
                           from pygments import highlight
                           from numba.misc.dump_style import NumbaIRLexer as lexer
                           from numba.misc.dump_style import by_colorscheme
                           from pygments.formatters import Terminal256Formatter
                           print(highlight(text, lexer(), Terminal256Formatter(
                               style=by_colorscheme())))
                   else:
                       print(text)
       
       
    1:     def dump_to_string(self):
   48:         with StringIO() as sb:
   24:             self.dump(file=sb)
   24:             return sb.getvalue()
       
    1:     def dump_generator_info(self, file=None):
               file = file or sys.stdout
               gi = self.generator_info
               print("generator state variables:", sorted(gi.state_vars), file=file)
               for index, yp in sorted(gi.yield_points.items()):
                   print("yield point #%d: live variables = %s, weak live variables = %s"
                         % (index, sorted(yp.live_vars), sorted(yp.weak_live_vars)),
                         file=file)
       
    1:     def render_dot(self, filename_prefix="numba_ir", include_ir=True):
               """Render the CFG of the IR with GraphViz DOT via the
               ``graphviz`` python binding.
       
               Returns
               -------
               g : graphviz.Digraph
                   Use `g.view()` to open the graph in the default PDF application.
               """
       
               try:
                   import graphviz as gv
               except ImportError:
                   raise ImportError(
                       "The feature requires `graphviz` but it is not available. "
                       "Please install with `pip install graphviz`"
                   )
               g = gv.Digraph(
                   filename="{}{}.dot".format(
                       filename_prefix,
                       self.func_id.unique_name,
                   )
               )
               # Populate the nodes
               for k, blk in self.blocks.items():
                   with StringIO() as sb:
                       blk.dump(sb)
                       label = sb.getvalue()
                   if include_ir:
                       label = ''.join(
                           [r'  {}\l'.format(x) for x in label.splitlines()],
                       )
                       label = r"block {}\l".format(k) + label
                       g.node(str(k), label=label, shape='rect')
                   else:
                       label = r"{}\l".format(k)
                       g.node(str(k), label=label, shape='circle')
               # Populate the edges
               for src, blk in self.blocks.items():
                   for dst in blk.terminator.get_targets():
                       g.edge(str(src), str(dst))
               return g
       
       
       # A stub for undefined global reference
    2: class UndefinedType(EqualityCheckMixin):
       
    1:     _singleton = None
       
    1:     def __new__(cls):
    1:         obj = cls._singleton
    1:         if obj is not None:
                   return obj
               else:
    1:             obj = object.__new__(cls)
    1:             cls._singleton = obj
    1:         return obj
       
    1:     def __repr__(self):
  228:         return "Undefined"
       
       
    1: UNDEFINED = UndefinedType()
